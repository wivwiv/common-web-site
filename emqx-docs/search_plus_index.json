{"./":{"url":"./","title":"EMQ X 消息服务器简介","summary":null,"keywords":"","body":"EMQ X 消息服务器简介开始使用认证鉴权HTTP API规则引擎数据存储消息桥接进阶教程协议介绍其他EMQ X 消息服务器简介 EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器。 Erlang/OTP是出色的软实时 (Soft-Realtime)、低延时 (Low-Latency)、分布式 (Distributed)的语言平台。 MQTT 是轻量的 (Lightweight)、发布订阅模式 (PubSub) 的物联网消息协议。 EMQ X 设计目标是实现高可靠，并支持承载海量物联网终端的MQTT连接，支持在海量物联网设备间低延时消息路由: 稳定承载大规模的 MQTT 客户端连接，单服务器节点支持50万到100万连接。 分布式节点集群，快速低延时的消息路由，单集群支持1000万规模的路由。 消息服务器内扩展，支持定制多种认证方式、高效存储消息到后端数据库。 完整物联网协议支持，MQTT、MQTT-SN、CoAP、LwM2M、WebSocket 或私有协议支持。 建议您在使用前仔细阅读一遍下面列出的文档，未列出的其他文档可以按需选择查看： 开始使用 安装：不同操作系统与安装包类型的下载、安装步骤。 启动 EMQ X：启动 EMQ X 并查看启动状态。 Dashboard：通过 Dashboard 管理 EMQ X 及在线设备。 认证鉴权 认证简介：选择内置插件、外部数据库、JWT 或者 HTTP 服务作为认证数据源，验证客户端连接合法性。 发布订阅 ACL：选择内置插件、外部数据库、或者 HTTP 服务作为 ACL 数据源，验证客户端发布订阅权限。 内置 ACL：内置 ACL 可能会影响到重要功能，使用前请详细了解。 HTTP API HTTP API 是物联网平台开发与 EMQ X 运维中频繁使用的功能，HTTP API 可以实现与外部系统的集成，例如查询并管理客户端信息、代理订阅、发布消息和创建规则等。 HTTP API：包含 HTTP API 接入点、接入认证方式。 基本信息：获取 EMQ X 版本、运行状态等基本信息。 节点：获取 EMQ X 节点信息。 客户端：查看在线客户端信息，支持踢出客户端。 订阅信息：查看订阅主题列表与订阅关系。 路由：查看已订阅的主题。 消息发布：通过 HTTP 调用 EMQ X 发布 MQTT 消息，应用程序与客户端通信可靠的方式。 主题订阅：动态管理客户端订阅列表，无需客户端主动发起订阅/取消订阅。 插件：插件的状态管理，启动、停止操作。 其他更多 API 请通过左侧目录查看。 规则引擎 规则引擎实现了消息数据与通过规则引擎能够筛选、处理、转发/存储消息到外部数据源，包括关系数据库、消息队列、Web 服务等等。 规则引擎：规则引擎的概念、基础使用方式。 创建规则：如何创建一条规则。 使用示例：规则引擎使用各类数据源的教程。 数据存储 EMQ X 企业版特有功能，数据存储将客户端上下线状态，订阅关系，离线消息、消息内容，消息抵达后发送的消息回执等操作记录到各种数据库中。数据存储包含运行时数据与消息数据，能够在服务崩溃、客户端异常离线后仍然保留数据。 数据存储：基本概念与使用场景。 数据存储配置：使用不同的数据源进行数据存储。 消息桥接 EMQ X 企业版桥接转发 MQTT 消息到 Kafka、RabbitMQ、Pulsar、RocketMQ、MQTT Broker 或其他 EMQ X 节点。 MQTT 桥接：实现跨地域、跨集群部署。 RPC 桥接 Kafka 桥接 RabbitMQ 桥接 Pulsar 桥接 RocketMQ 桥接 进阶教程 包含官方使用指南、最佳实践等信息。 设备管理 系统调优 生产部署 Prometheus 监控告警 性能测试 协议介绍 MQTT 协议 MQTT-SN 协议 LwM2M 协议 私有 TCP 协议 其他 资源：社区交流，包含社区热门教程、项目展示等资源。 .emqxee { display: none; }"},"introduction/checklist.html":{"url":"introduction/checklist.html","title":"EMQ X 消息服务器功能列表","summary":null,"keywords":"","body":"EMQ X 消息服务器功能列表EMQ X Enterprise企业版功能消息数据存储消息桥接转发规则引擎编解码EMQ X 不同版本对比EMQ X 消息服务器功能列表 完整的 MQTT V3.1/V3.1.1 及 V5.0 协议规范支持 QoS0, QoS1, QoS2 消息支持 持久会话与离线消息支持 Retained 消息支持 Last Will 消息支持 TCP/SSL 连接支持 MQTT/WebSocket/SSL 支持 HTTP 消息发布接口支持 $SYS/# 系统主题支持 客户端在线状态查询与订阅支持 客户端 ID 或 IP 地址认证支持 用户名密码认证支持 LDAP 认证 Redis、MySQL、PostgreSQL、MongoDB、HTTP 认证集成 浏览器 Cookie 认证 基于客户端 ID、IP 地址、用户名的访问控制 (ACL) 多服务器节点集群 (Cluster) 支持 manual、mcast、dns、etcd、k8s 等多种集群发现方式 网络分区自动愈合 消息速率限制 连接速率限制 按分区配置节点 多服务器节点桥接 (Bridge) MQTT Broker 桥接支持 Stomp 协议支持 MQTT-SN 协议支持 CoAP 协议支持 Stomp/SockJS 支持 延时 Publish ($delay/topic) Flapping 检测 黑名单支持 共享订阅 ($share/:group/topic) TLS/PSK 支持 规则引擎 空动作 (调试) 消息重新发布 桥接数据到 MQTT Broker 检查 (调试) 发送数据到 Web 服务 以下是 EMQ X Enterprise 特有功能 Scalable RPC 架构: 分离 Erlang 自身的集群通道与 EMQ X 节点间的数据通道 数据持久化 Redis 存储订阅关系、设备在线状态、MQTT 消息、保留消息，发布 SUB/UNSUB 事件 MySQL 存储订阅关系、设备在线状态、MQTT 消息、保留消息 PostgreSQL 存储订阅关系、设备在线状态、MQTT 消息、保留消息 MongoDB 存储订阅关系、设备在线状态、MQTT 消息、保留消息 Cassandra 存储订阅关系、设备在线状态、MQTT 消息、保留消息 DynamoDB 存储订阅关系、设备在线状态、MQTT 消息、保留消息 InfluxDB 存储 MQTT 时序消息 OpenTDSB 存储 MQTT 时序消息 TimescaleDB 存储 MQTT 时序消息 消息桥接 Kafka 桥接：EMQ X 内置 Bridge 直接转发 MQTT 消息、设备上下线事件到 Kafka RabbitMQ 桥接：EMQ X 内置 Bridge 直接转发 MQTT 消息、设备上下线事件到 RabbitMQ Pulsar 桥接：EMQ X 内置 Bridge 直接转发 MQTT 消息、设备上下线事件到 Pulsar RocketMQ 桥接：EMQ X 内置 Bridge 直接转发 MQTT 消息、设备上下线事件到 RocketMQ 规则引擎 消息编解码 桥接数据到 Kafka 桥接数据到 RabbitMQ 桥接数据到 RocketMQ 桥接数据到 Pulsar 保存数据到 PostgreSQL 保存数据到 MySQL 保存数据到 OpenTSDB 保存数据到 Redis 保存数据到 DynamoDB 保存数据到 MongoDB 保存数据到 InfluxDB 保存数据到 Timescale 保存数据到 Cassandra Schema Registry：将 EMQ X 的事件、消息 提供了数据编解码能力 EMQ X EnterpriseEMQ X Enterprise 是一个强大的企业级物联网 MQTT 消息平台，由开发开源 EMQ X 的人员构建。EMQ X Enterprise 支持百万级物联网设备一站式接入、MQTT&CoAP 多协议处理、低时延实时消息通信。它保持了 EMQ X 的简单性和高性能，同时增加了许多企业特性：连接性能增强到百万级、千万级，支持私有协议及行业协议定制，基于 TCP/UDP 私有协议的旧网设备接入兼容，支持全网络多协议设备接入； 支持 Redis, MySQL, PostgreSQL, MongoDB 多种数据库消息数据持久化，消息转换写入 InfluxDB, OpenTSDB, TimescaleDB 多种时序数据库，支持自动从 Redis 或数据库加载订阅，无需客户端主动发起； 消息与流中间件消息桥接：10万/秒高性能高可靠转发消息到 Kafka 流处理中间件，无缝集成 RabbitMQ、Pulsar 企业消息中间件； 全球专业团队技术支持，我们的团队覆盖全球北美、欧洲、中国 5 个分支机构，有来自华为、IBM、Amazon 专业创始团队，以及欧洲、北美、印度近十家合作伙伴，能够全天侯相应一流的技术支持与咨询服务。 企业版功能 消息数据存储 EMQ X 企业版支持存储订阅关系、MQTT 消息、设备状态到 Redis、MySQL、PostgreSQL、MongoDB、Cassandra、TimescaleDB、InfluxDB、DynamoDB、OpenTDSB 数据库: 数据存储相关配置，详见\"数据存储\"章节。 消息桥接转发 EMQ X 企业版支持直接转发 MQTT 消息到 RabbitMQ、Kafka、Pulsar、RocketMQ、MQTT Broker，可作为百万级的物联网接入服务器(IoT Hub): 规则引擎 EMQ X 规则引擎可以灵活地处理消息和事件。 EMQ X 企业版规则引擎支持消息重新发布；桥接数据到 Kafka、Pulsar、RocketMQ、RabbitMQ、MQTT Broker；保存数据到 MySQL、PostgreSQL、Redis、MongoDB、DynamoDB、Cassandra、InfluxDB、OpenTSDB、TimescaleDB；发送数据到 WebServer: 规则引擎相关配置，详见\"规则引擎\"章节。 编解码 Schema Registry 目前可支持三种格式的编解码：Avro，Protobuf，以及自定义编码。其中 Avro 和 Protobuf 是依赖 Schema 的数据格式，编码后的数据为二进制，解码后为 Map 格式 。解码后的数据可直接被规则引擎和其他插件使用。用户自定义的 (3rd-party) 编解码服务通过 HTTP 或 TCP 回调的方式，进行更加贴近业务需求的编解码。 编解码相关配置，详见\"编解码\"章节。 EMQ X 不同版本对比 .emqxee { display: none; }"},"getting-started/install.html":{"url":"getting-started/install.html","title":"安装","summary":null,"keywords":"","body":"安装Shell 脚本一键安装 (Linux)包管理器安装 (Linux)二进制包安装 (Linux)ZIP 压缩包安装 (Linux、MaxOS、Windows)通过 Homebrew 安装 (MacOS)通过 Docker 运行 (包含简单的 docker-compose 集群)通过 Helkm 安装并集群 (K8S、K3S)源码编译安装安装 EMQ X 目前支持的操作系统: Centos6 Centos7 OpenSUSE tumbleweed Debian 8 Debian 9 Debian 10 Ubuntu 14.04 Ubuntu 16.04 Ubuntu 18.04 macOS 10.13 macOS 10.14 macOS 10.15 Windows Server 2019 产品部署建议 Linux 服务器，不推荐 Windows 服务器。 Shell 脚本安装包管理器安装二进制包安装ZIP 压缩包安装Homebrew 安装Docker 运行Helm 安装并集群源码编译安装Shell 脚本一键安装 (Linux)curl https://repos.emqx.io/install_emqx.sh | bash 包管理器安装 (Linux)Centos安装所需要的依赖包$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 使用以下命令设置稳定存储库，以 CentOS7 为例$ sudo yum-config-manager --add-repo https://repos.emqx.io/emqx-ce/redhat/centos/7/emqx-ce.repo 安装最新版本的 EMQ X Broker$ sudo yum install emqx 如果提示接受 GPG 密钥，请确认密钥符合 fc84 1ba6 3775 5ca8 487b 1e3c c0b4 0946 3e64 0d53，并接受该指纹。 安装特定版本的 EMQ X Broker查询可用版本$ yum list emqx --showduplicates | sort -r emqx.x86_64 4.0.0-1.el7 emqx-stable emqx.x86_64 3.0.1-1.el7 emqx-stable emqx.x86_64 3.0.0-1.el7 emqx-stable 根据第二列中的版本字符串安装特定版本，例如 4.0.0$ sudo yum install emqx-4.0.0 启动 EMQ X Broker直接启动$ emqx start emqx 4.0.0 is started successfully! $ emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running systemctl 启动$ sudo systemctl start emqx service 启动$ sudo service emqx start 停止 EMQ X Broker$ emqx stop ok 卸载 EMQ X Broker$ sudo yum remove emqx Ubuntu、Debian安装所需要的依赖包$ sudo apt update && sudo apt install -y \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 添加 EMQ X 的官方 GPG 密钥$ curl -fsSL https://repos.emqx.io/gpg.pub | sudo apt-key add - 验证密钥$ sudo apt-key fingerprint 3E640D53 pub rsa2048 2019-04-10 [SC] FC84 1BA6 3775 5CA8 487B 1E3C C0B4 0946 3E64 0D53 uid [ unknown] emqx team 使用以下命令设置 stable 存储库。 如果要添加 unstable 存储库，请在以下命令中的单词 stable 之后添加单词 unstable。$ sudo add-apt-repository \\ \"deb [arch=amd64] https://repos.emqx.io/emqx-ce/deb/ubuntu/ \\ ./$(lsb_release -cs) \\ stable\" lsb_release -cs 子命令返回发行版的名称，例如 xenial。 有时，在像 Linux Mint 这样的发行版中，您可能需要将 $(lsb_release -cs) 更改为您的父发行版。 例如，如果您使用的是 Linux Mint Tessa，则可以使用 bionic。 EMQ X Broker 不对未经测试和不受支持的发行版提供任何保证。 更新 apt 包索引$ sudo apt update 安装最新版本的 EMQ X Broker$ sudo apt install emqx 在启用了多个 EMQ X 仓库的情况下，如果 apt install 和 apt update 命令没有指定版本号，那么会自动安装最新版的 EMQ X Broker。这对于有稳定性需求的用户来说是一个问题。 安装特定版本的 EMQ X Broker查询可用版本$ sudo apt-cache madison emqx emqx | 4.0.0 | https://repos.emqx.io/emqx-ce/deb/ubuntu bionic/stable amd64 Packages emqx | 3.0.1 | https://repos.emqx.io/emqx-ce/deb/ubuntu bionic/stable amd64 Packages emqx | 3.0.0 | https://repos.emqx.io/emqx-ce/deb/ubuntu bionic/stable amd64 Packages 使用第二列中的版本字符串安装特定版本，例如 4.0.0$ sudo apt install emqx=4.0.0 启动 EMQ X Broker直接启动$ emqx start emqx 4.0.0 is started successfully! $ emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running systemctl 启动$ sudo systemctl start emqx service 启动$ sudo service emqx start 停止 EMQ X Broker$ emqx stop ok 卸载 EMQ X Broker$ sudo apt remove emqx OpenSUSE下载 GPG 公钥并导入。$ curl -L -o /tmp/gpg.pub https://repos.emqx.io/gpg.pub $ sudo rpmkeys --import /tmp/gpg.pub 添加储存库地址$ sudo zypper ar -f -c https://repos.emqx.io/emqx-ce/redhat/opensuse/leap/stable emqx 安装最新版本的 EMQ X Broker$ sudo zypper in emqx 安装特定版本的 EMQ X Broker查询可用版本$ sudo zypper pa emqx Loading repository data... Reading installed packages... S | Repository | Name | Version | Arch --+------------+------+----------+------- | emqx | emqx | 4.0.0-1 | x86_64 | emqx | emqx | 3.0.1-1 | x86_64 | emqx | emqx | 3.0.0-1 | x86_64 使用 Version 安装特定版本，例如 4.0.0$ sudo zypper in emqx-4.0.0 启动 EMQ X Broker直接启动$ emqx start emqx 4.0.0 is started successfully! $ emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running systemctl 启动$ sudo systemctl start emqx service 启动$ sudo service emqx start 停止 EMQ X Broker$ emqx stop ok 卸载 EMQ X Broker$ sudo zypper rm emqx 二进制包安装 (Linux)通过 emqx.io 或 Github 选择系统发行版，然后下载要安装的 EMQ X 版本的二进制包。 安装 EMQ X Broker，将下面的路径更改为您下载 EMQ X 软件包的路径。RPM 包: $ sudo rpm -ivh emqx-cenots7-v4.0.0.x86_64.rpm DEB 包:$ sudo dpkg -i emqx-ubuntu18.04-v4.0.0_amd64.deb 启动 EMQ X Broker直接启动$ emqx start emqx 4.0.0 is started successfully! $ emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running systemctl 启动$ sudo systemctl start emqx service 启动$ sudo service emqx start 停止 EMQ X Broker$ emqx stop ok 卸载 EMQ X BrokerDEB 包:$ dpkg -r emqx 或$ dpkg -P emqx RPM 包:$ rpm -e emqx ZIP 压缩包安装 (Linux、MaxOS、Windows)通过 emqx.io 或 Github 下载要安装的 EMQ X 版本的 zip 包。 解压程序包$ unzip emqx-ubuntu18.04-v4.0.0.zip 启动 EMQ X Broker$ ./bin/emqx start emqx 4.0.0 is started successfully! $ ./bin/emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running 停止 EMQ X Broker$ ./bin/emqx stop ok 卸载 EMQ X Broker直接删除 EMQ X 目录即可 通过 Homebrew 安装 (MacOS)添加 EMQ X 的 tap$ brew tap emqx/emqx 安装 EMQ X Broker$ brew install emqx 启动 EMQ X Broker$ emqx start emqx 4.0.0 is started successfully! $ emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running 停止 EMQ X Broker$ emqx stop ok 卸载 EMQ X Broker$ brew uninstall emqx 通过 Docker 运行 (包含简单的 docker-compose 集群)运行单个容器获取 docker 镜像通过 Docker Hub 获取$ docker pull emqx/emqx:v4.0.0 通过 emqx.io 或 Github 下载 Docker 镜像，并手动加载$ wget -O emqx-docker.zip https://www.emqx.io/downloads/broker/v4.0.0/emqx-docker-v4.0.0-alpine3.10-amd64.zip $ unzip emqx-docker.zip $ docker load 启动 docker 容器$ docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8883:8883 -p 8084:8084 -p 18083:18083 emqx/emqx:v4.0.0 使用 docker-compose 创建简单的 static 集群创建 docker-compose.yaml 文件version: '3' services: emqx1: image: emqx/emqx:v4.0.0 environment: - \"EMQX_NAME=emqx\" - \"EMQX_HOST=node1.emqx.io\" - \"EMQX_CLUSTER__DISCOVERY=static\" - \"EMQX_CLUSTER__STATIC__SEEDS=emqx@node1.emqx.io, emqx@node2.emqx.io\" healthcheck: test: [\"CMD\", \"/opt/emqx/bin/emqx_ctl\", \"status\"] interval: 5s timeout: 25s retries: 5 networks: emqx-bridge: aliases: - node1.emqx.io emqx2: image: emqx/emqx:v4.0.0 environment: - \"EMQX_NAME=emqx\" - \"EMQX_HOST=node2.emqx.io\" - \"EMQX_CLUSTER__DISCOVERY=static\" - \"EMQX_CLUSTER__STATIC__SEEDS=emqx@node1.emqx.io, emqx@node2.emqx.io\" healthcheck: test: [\"CMD\", \"/opt/emqx/bin/emqx_ctl\", \"status\"] interval: 5s timeout: 25s retries: 5 networks: emqx-bridge: aliases: - node2.emqx.io networks: emqx-bridge: driver: bridge 启动 docker-compose 集群$ docker-compose -p my_emqx up -d 查看集群$ docker exec -it my_emqx_emqx1_1 sh -c \"emqx_ctl cluster status\" Cluster status: #{running_nodes => ['emqx@node1.emqx.io','emqx@node2.emqx.io'], stopped_nodes => []} 更多关于 EMQ X Docker 的信息请查看 Docker Hub 或 Github通过 Helkm 安装并集群 (K8S、K3S)添加 helm 仓库$ helm repo add emqx https://repos.emqx.io/charts $ helm repo update 查询 EMQ X Brokerhelm search repo emqx NAME CHART VERSION APP VERSION DESCRIPTION emqx/emqx v4.0.0 v4.0.0 A Helm chart for EMQ X emqx/emqx-ee v4.0.0 v4.0.0 A Helm chart for EMQ X emqx/kuiper 0.1.1 0.1.1 A lightweight IoT edge analytic software 启动 EMQ X 集群$ helm install my-emqx emqx/emqx 查看 EMQ X 集群情况$ kubectl get pods NAME READY STATUS RESTARTS AGE my-emqx-0 1/1 Running 0 56s my-emqx-1 1/1 Running 0 40s my-emqx-2 1/1 Running 0 21s $ kubectl exec -it my-emqx-0 -- emqx_ctl cluster status Cluster status: #{running_nodes => ['my-emqx@my-emqx-0.my-emqx-headless.default.svc.cluster.local', 'my-emqx@my-emqx-1.my-emqx-headless.default.svc.cluster.local', 'my-emqx@my-emqx-2.my-emqx-headless.default.svc.cluster.local'], stopped_nodes => []} 源码编译安装获取源码 $ git clone -b v4.0.0 https://github.com/emqx/emqx-rel.git 设置环境变量 $ export EMQX_DEPS_DEFAULT_VSN=v4.0.0 编译 $ cd emqx-rel && make 启动 EMQ X Broker $ cd _build/emqx-rel/_rel/emqx $ ./bin/emqx start emqx 4.0.0 is started successfully! $ ./bin/emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running .emqxee { display: none; }"},"getting-started/start.html":{"url":"getting-started/start.html","title":"启动 EMQ X","summary":null,"keywords":"","body":"启动 EMQ X查看 EMQ X 的状态启动 EMQ X Enterprise申请试用 License放置 License启动 EMQ X 后台启动 EMQ X $ emqx start EMQ X v4.0.0 is started successfully! systemctl 启动 $ sudo systemctl start emqx EMQ X v4.0.0 is started successfully! service 启动 $ sudo service emqx start EMQ X v4.0.0 is started successfully! 查看 EMQ X 的状态 EMQ X 正常启动: $ emqx_ctl status Node 'emqx@127.0.0.1' is started emqx 4.0.0 is running EMQ X 未能正常启动: $ emqx_ctl status Node 'emqx@127.0.0.1' not responding to pings。 你可以查看 logs 下的日志文件并确认是否属于 常见错误。 启动 EMQ X EnterpriseEMQ X Enterprise 需要 License 文件才能正常启动，EMQ X 可以略过这一步。 申请试用 License 访问 https://emqx.io，在 EMQ X Enterprise 下载页面，点击 Get FREE Trial License。 注册登陆并申请 License 文件试用，下载 License 文件。 放置 License 替换默认证书目录下的 License 文件（etc/emqx.lic），当然你也可以选择变更证书文件的读取路径，修改 etc/emqx.conf 文件中的 license.file，并确保 License 文件位于更新后的读取路径且 EMQ X Enterprise 拥有读取权限，然后启动 EMQ X Enterprise。EMQ X Enterprise 的启动方式与 EMQ X 相同，见下文。 如果是正在运行的 EMQ X Enterprise 需要更新 License 文件，那么可以使用 emqx_ctl license reload [license 文件所在路径] 命令直接更新 License 文件，无需重启 EMQ X Enterprise。 emqx_ctl license reload 命令加载的证书仅在 EMQ X Enterprise 本次运行期间生效，如果需要永久更新 License 证书的路径，依然需要替换旧证书或修改配置文件。 .emqxee { display: none; }"},"getting-started/command-line.html":{"url":"getting-started/command-line.html","title":"基本命令","summary":null,"keywords":"","body":"基本命令基本命令 EMQ X 提供了 emqx 命令行工具，方便用户对 EMQ X 进行启动、关闭、进入控制台等操作。 emqx start 后台启动 EMQ X Broker； emqx stop 关闭 EMQ X Broker； emqx restart 重启 EMQ X Broker； emqx console 使用控制台启动 EMQ X Broker； emqx foreground 使用控制台启动 EMQ X Broker，与 emqx console 不同，emqx foreground 不支持输入 Erlang 命令； emqx ping Ping EMQ X Broker。 以上命令为用户常用命令，此外 emqx 命令还有一些其他选项为方便开发者使用，普通用户无需关心。 .emqxee { display: none; }"},"getting-started/directory.html":{"url":"getting-started/directory.html","title":"目录结构","summary":null,"keywords":"","body":"目录结构目录结构 不同安装方式得到的 EMQ X 其目录结构会有所不同，具体如下: 描述 使用 ZIP 压缩包安装 使用二进制包安装 可执行文件目录 ./bin /usr/lib/emqx/bin 数据文件 ./data /var/lib/emqx/data Erlang 虚拟机文件 ./erts-* /usr/lib/emqx/erts-* 配置文件目录 ./etc /etc/emqx/etc 依赖项目录 ./lib /usr/lib/emqx/lib 日志文件 ./log /var/log/emqx 启动相关的脚本、schema 文件 ./releases /usr/lib/emqx/releases 以上目录中，用户经常接触与使用的是 bin、etc、data、log 目录。 bin 目录 emqx、emqx.cmd EMQ X 的可执行文件，具体使用可以查看 基本命令。 emqx_ctl、emqx_ctl.cmd EMQ X 管理命令的可执行文件，具体使用可以查看 管理命令 CLI。 etc 目录 EMQ X 通过 etc 目录下配置文件进行设置，主要配置文件包括: 配置文件 说明 emqx.conf EMQ X 配置文件 acl.conf EMQ X 默认 ACL 规则配置文件 plugins/*.conf EMQ X 各类插件配置文件 certs EMQ X SSL 证书文件 emqx.lic License 文件仅限 EMQ X Enterprise EMQ X 具体的配置内容可以查看 配置项。 data 目录 EMQ X 将运行数据存储在 data 目录下，主要的文件包括: configs/app.*.config EMQ X 读取 etc/emqx.conf 和 etc/plugins/*.conf 中的配置后，转换为 Erlang 原生配置文件格式，并在运行时读取其中的配置。 loaded_plugins loaded_plugins 文件记录了 EMQ X 默认启动的插件列表，可以修改此文件以增删默认启动的插件。loaded_plugins 中启动项格式为 {, }.， 字段为布尔类型，EMQ X 会在启动时根据 的值判断是否需要启动该插件。关于插件的更多内容，请查看 插件。 $ cat loaded_plugins {emqx_management,true}. {emqx_recon,true}. {emqx_retainer,true}. {emqx_dashboard,true}. {emqx_rule_engine,true}. {emqx_bridge_mqtt,false}. mnesia Mnesia 数据库是 Erlang 内置的一个分布式 DBMS，可以直接存储 Erlang 的各种数据结构。 EMQ X 使用 Mnesia 数据库存储自身运行数据，例如告警记录、规则引擎已创建的资源和规则、Dashbaord 用户信息等数据，这些数据都将被存储在 mnesia 目录下，因此一旦删除该目录，将导致 EMQ X 丢失所有业务数据。 可以通过 emqx_ctl mnesia 命令查询 EMQ X 中 Mnesia 数据库的系统信息，具体请查看 管理命令 CLI。 log 目录 emqx.log.* EMQ X 运行时产生的日志文件，具体请查看 日志与追踪。 crash.dump EMQ X 的崩溃转储文件，可以通过 etc/emqx.conf 修改配置，具体内容可以查看 配置项。 erlang.log.* 以 emqx start 方式后台启动 EMQ X 时，控制台日志的副本文件。 .emqxee { display: none; }"},"getting-started/config.html":{"url":"getting-started/config.html","title":"配置说明","summary":null,"keywords":"","body":"配置说明简介语法规则数据类型默认配置Zone & ListenerListenerZone配置更新配置说明 简介 EMQ X 的配置文件通常以 .conf 作为后缀名，你可以在 etc 目录找到这些配置文件，主要配置文件包括： 配置文件 说明 etc/emqx.conf EMQ X 配置文件 etc/acl.conf EMQ X 默认 ACL 规则配置文件 etc/plugins/*.conf EMQ X 扩展插件配置文件 需要注意的是，安装方式不同 etc 目录所处的路径可能不同，具体请参见 目录结构。 语法规则 采用类似 sysctl 的 k = v 通用格式 单个配置项的所有信息都在同一行内，换行意味着创建一个新的配置项 键可以通过 . 进行分层，支持按树形结构管理配置项 值的类型可以是 integer, fload, percent, enum, ip, string, atom, flag, duration and bytesize 任何以＃开头的行均被视为注释 示例： mqtt.max_packet_size = 1MB 数据类型 integer 整型数据。 float 浮点型数据。 percent 以 % 结尾的百分比数据，最终会被转换为 float 类型。 enum 通常我们会在类型为 enum 的配置项附近列出它的所有可选值。当然，你也可以查找 配置项。 ip 当你看到某个配置项的数据类型为 ip 时，意味着你可以使用 : 的形式来设置该配置项，例如 0.0.0.0:1883。 string *.conf 文件中除注释以外的所有内容都会先被解析成字符串再转换为其他类型，因此没有必要对 string 类型的值额外使用双引号对值进行修饰，并且这种方式也不被支持。 Yes! dir = tmp No!!! dir = \"tmp\" atom atom 类型的值最终会转换成 Erlang 的 atom，但它在 *.conf 文件中的使用方式与 string 完全一致。 flag flag 用于那些具有两个可能值的变量，flag 默认可用值为 on 和 off，它们将映射为 true 和 false 以供应用程序使用。如果我们为某个配置项建立了其他的映射关系，我们会在配置文件中注明，你也可以在 配置项 中查找这些信息。 duration duration 用于指定那些固定的时间间隔，你可以使用以下时间单位： f - fortnight w - week d - day h - hour m - minute s - second ms - millisecond 你可以任意组合这些时间单位，例如 1w13ms，也可以使用浮点数，例如 0.5d，这些时间间隔最终将会被转换成我们指定的基准单位。这里有一点需要注意，如果你以毫秒为单位设置了某个配置项，而它的基准单位为秒，那么它将向上舍入至最接近的描述，例如 1s50ms = 2s。因此，我们会列出这一类配置项的基准单位。 bytesize bytesize 支持以更易读的方式来设置报文大小、缓冲区大小等配置，单位可以是 KB，MB 和 GB，你也可以使用小写，例如 kb，但不支持大小写混合，例如 Kb，它们最终都将被转换为字节数。如果你未指定任何单位，那么它被直接作为字节数使用。 默认配置 在 EMQ X 的配置文件中，你会看到很多被注释掉的配置项，这意味着这些配置项会使用他们的默认值，通常我们会列出这些配置的默认值。 Zone & Listener EMQ X 提供了非常多的配置项，并支持全局配置和局部配置。例如，EMQ X 提供了匿名访问的功能，即允许客户端不需要用户名与密码就能连接 Broker，通常在用户的生产环境中，此功能被默认关闭，但用户可能又希望在他的内网环境中启用此功能。从 3.0 版本开始，EMQ X 就通过 Zone 与 Listener 为用户提供了这种可能。 Listener Listener 主要用于配置不同协议的监听端口和相关参数，EMQ X 支持配置多个 Listener 以同时监听多个协议或端口，以下是支持的 Listener： 监听器 说明 TCP Listener A listener for MQTT which uses TCP SSL Listener A secure listener for MQTT which uses TLS Websocket Listener A listener for MQTT over WebSockets Secure Websocket Listener A secure listener for MQTT over secure WebSockets (TLS) EMQ X 默认提供 5 个 Listener，它们将占用以下端口： 端口 说明 1883 MQTT/TCP 协议端口 11883 MQTT/TCP 协议内部端口，仅用于本机客户端连接 8883 MQTT/SSL 协议端口 8083 MQTT/WS 协议端口 8084 MQTT/WSS 协议端口 Listener 配置项的命名规则为 listener...xxx， 即 Listener 使用的协议，目前支持 tcp, ssl, ws, wss。 可以随意命名，但建议是全小写的英文单词，xxx 则是具体的配置项。不同协议的 Listener 的 可以重复，listener.tcp.external 与 listener.ssl.external 是两个不同的 Listener。 由于默认配置的存在，我们能够非常快速地展示如何添加新的 Listener，以 TCP Listener 为例，我们只需要在 emqx.conf 中添加以下一条配置即可： listener.tcp.example = 12345 当然这种情况我们更建议您复制一份默认 Listener 的配置进行修改。 Zone 一个 Zone 定义了一组配置项 (比如最大连接数等)，Listener 可以通过配置项 listener...zone 指定使用某个 Zone，以使用该 Zone 下的所有配置。多个 Listener 可以共享同一个 Zone。Zone 的命名规则为 zone..xxx，Zone Name 可以随意命名，但同样建议是全小写的英文单词，xxx 是具体的配置项，你可以在 配置项 中查看 Zone 支持的所有配置项。 此时，我们的每个配置项都存在三个可用值，分别是全局的值，Zone 里设置的值以及默认值，它们的优先级顺序为：Zone > Global > Default。 配置更新 配置项会在 EMQ X Broker 与扩展插件被启动时读取并载入，EMQ X Broker 目前尚不支持运行时更新配置，但由于扩展插件支持动态加载和卸载，因此可以在修改插件配置后重新加载插件来应用最新的配置项。 .emqxee { display: none; }"},"getting-started/log.html":{"url":"getting-started/log.html","title":"日志与追踪","summary":null,"keywords":"","body":"日志与追踪 控制日志输出 日志级别 日志文件和日志滚动 针对日志级别输出日志文件 日志格式 日志级别和 log handlers 运行时修改日志级别 日志追踪 日志追踪的原理 日志与追踪 控制日志输出 EMQ X 支持将日志输出到控制台或者日志文件，或者同时使用两者。可在 emqx.conf 中配置： log.to = both log.to 默认值是 both，可选的值为： off: 完全关闭日志功能 file: 仅将日志输出到文件 console: 仅将日志输出到标准输出(emqx 控制台) both: 同时将日志输出到文件和标准输出(emqx 控制台) 日志级别 EMQ X 的日志分 8 个等级 (RFC 5424)，由低到高分别为： debug EMQ X 的默认日志级别为 warning，可在 emqx.conf 中修改： log.level = warning 此配置将所有 log handler 的配置设置为 warning。 日志文件和日志滚动 EMQ X 的默认日志文件目录在 ./log (zip包解压安装) 或者 /var/log/emqx (二进制包安装)。可在 emqx.conf 中配置： log.dir = log 在文件日志启用的情况下 (log.to = file 或 both)，日志目录下会有如下几种文件: emqx.log.N: 以 emqx.log 为前缀的文件为日志文件，包含了 EMQ X 的所有日志消息。比如 emqx.log.1, emqx.log.2 ... emqx.log.siz 和 emqx.log.idx: 用于记录日志滚动信息的系统文件。 run_erl.log: 以 emqx start 方式后台启动 EMQ X 时，用于记录启动信息的系统文件。 erlang.log.N: 以 erlang.log 为前缀的文件为日志文件，是以 emqx start 方式后台启动 EMQ X 时，控制台日志的副本文件。比如 erlang.log.1, erlang.log.2 ... 可在 emqx.conf 中修改日志文件的前缀，默认为 emqx.log： log.file = emqx.log EMQ X 默认在单日志文件超过 10MB 的情况下，滚动日志文件，最多可有 5 个日志文件：第 1 个日志文件为 emqx.log.1，第 2 个为 emqx.log.2，并以此类推。当最后一个日志文件也写满 10MB 的时候，将从序号最小的日志的文件开始覆盖。文件大小限制和最大日志文件个数可在 emqx.conf 中修改： log.rotation.size = 10MB log.rotation.count = 5 针对日志级别输出日志文件 如果想把大于或等于某个级别的日志写入到单独的文件，可以在 emqx.conf 中配置 log..file： 将 info 及 info 以上的日志单独输出到 info.log.N 文件中： log.info.file = info.log 将 error 及 error 以上的日志单独输出到 error.log.N 文件中 log.error.file = error.log 日志格式 可在 emqx.conf 中修改单个日志消息的最大字符长度，如长度超过限制则截断日志消息并用 ... 填充。默认不限制长度： 将单个日志消息的最大字符长度设置为 8192: log.chars_limit = 8192 日志消息的格式为(各个字段之间用空格分隔)： date time level client_info module_info msg date: 当地时间的日期。格式为：YYYY-MM-DD time: 当地时间，精确到毫秒。格式为：hh:mm:ss.ms level: 日志级别，使用中括号包裹。格式为：[Level] client_info: 可选字段，仅当此日志消息与某个客户端相关时存在。其格式为：ClientId@Peername 或 ClientId 或 Peername module_info: 可选字段，仅当此日志消息与某个模块相关时存在。其格式为：[Module Info] msg: 日志消息内容。格式任意，可包含空格。 日志消息举例 1： 2020-02-18 16:10:03.872 [debug] >@127.0.0.1:57105 [MQTT/WS] SEND CONNACK(Q0, R0, D0, AckFlags=0, ReasonCode=0) 此日志消息里各个字段分别为: date: 2020-02-18 time: 16:10:03.872 level: [debug] client_info: >@127.0.0.1:57105 module_info: [MQTT/WS] msg: SEND CONNACK(Q0, R0, D0, AckFlags=0, ReasonCode=0) 日志消息举例 2： 2020-02-18 16:10:08.474 [warning] [Alarm Handler] New Alarm: system_memory_high_watermark, Alarm Info: [] 此日志消息里各个字段分别为: date: 2020-02-18 time: 16:10:08.474 level: [warning] module_info: [Alarm Handler] msg: New Alarm: system_memory_high_watermark, Alarm Info: [] 注意此日志消息中，client_info 字段不存在。 日志级别和 log handlers EMQ X 使用了分层的日志系统，在日志级别上，包括全局日志级别 (primary log level)、以及各 log hanlder 的日志级别。 [Primary Level] -- global log level and filters / \\ [Handler 1] [Handler 2] -- log levels and filters at each handler log handler 是负责日志处理和输出的工作进程，它由 log handler id 唯一标识，并负有如下任务： 接收什么级别的日志 如何过滤日志消息 将日志输出到什么地方 我们来看一下 emqx 默认安装的 log handlers: $ emqx_ctl log handlers list LogHandler(id=ssl_handler, level=debug, destination=console) LogHandler(id=file, level=debug, destination=log/emqx.log) LogHandler(id=default, level=debug, destination=console) file: 负责输出到日志文件的 log handler。它没有设置特殊过滤条件，即所有日志消息只要级别满足要求就输出。输出目的地为日志文件。 default: 负责输出到控制台的 log handler。它没有设置特殊过滤条件，即所有日志消息只要级别满足要求就输出。输出目的地为控制台。 ssl_handler: ssl 的 log handler。它的过滤条件设置为当日志是来自 ssl 模块时输出。输出目的地为控制台。 日志消息输出前，首先检查消息是否高于 primary log level，日志消息通过检查后流入各 log handler，再检查各 handler 的日志级别，如果日志消息也高于 handler level，则由对应的 handler 执行相应的过滤条件，过滤条件通过则输出。 设想一个场景，假设 primary log level 设置为 info，log handler default (负责输出到控制台) 的级别设置为 debug，log handler file (负责输出到文件) 的级别设置为 warning： 虽然 console 日志是 debug 级别，但此时 console 日志只能输出 info 以及 info 以上的消息，因为经过 primary level 过滤之后，流到 default 和 file 的日志只剩下 info 及以上的级别； emqx.log.N 文件里面，包含了 warning 以及 warning 以上的日志消息。 在 日志级别 章节中提到的 log.level 是修改了全局的日志级别。这包括 primary log level 和各个 handlers 的日志级别，都设置为了同一个值。 Primary Log Level 相当于一个自来水管道系统的总开关，一旦关闭则各个分支管道都不再有水流通过。这个机制保证了日志系统的高性能运作。 运行时修改日志级别 你可以使用 EMQ X 的命令行工具 emqx_ctl 在运行时修改 emqx 的日志级别： 修改全局日志级别： 例如，将 primary log level 以及所有 log handlers 的级别设置为 debug： $ emqx_ctl log set-level debug 修改主日志级别： 例如，将 primary log level 设置为 debug: $ emqx_ctl log primary-level debug 修改某个 log handler 的日志级别： 例如，将 log handler file 设置为 debug: $ emqx_ctl log handlers set-level file debug 日志追踪 EMQ X 支持针对 ClientID 或 Topic 过滤日志并输出到文件。在使用日志追踪功能之前，必须将 primary log level 设置为 debug： $ emqx_ctl log primary-level debug 开启 ClientID 日志追踪，将所有 ClientID 为 'my_client' 的日志都输出到 log/my_client.log: $ emqx_ctl log primary-level debug debug $ emqx_ctl trace start client my_client log/my_client.log trace clientid my_client successfully 开启 Topic 日志追踪，将主题能匹配到 't/#' 的消息发布日志输出到 log/topic_t.log: $ emqx_ctl log primary-level debug debug $ emqx_ctl trace start topic 't/#' log/topic_t.log trace topic t/# successfully 即使 emqx.conf 中，log.level 设置为 error，使用消息追踪功能仍然能够打印出某 client 或 topic 的 debug 级别的信息。这在生产环境中非常有用。 日志追踪的原理 日志追踪的原理是给 emqx 安装一个新的 log handler，并设置 handler 的过滤条件。在 日志级别和 log handlers 小节，我们讨论过 log handler 的细节。 比如使用如下命令启用 client 日志追踪： $ emqx_ctl log primary-level debug && emqx_ctl trace start client my_client log/my_client.log 然后查询已经开启的追踪: $ emqx_ctl trace list Trace(clientid=my_client, level=debug, destination=\"log/my_client.log\") 在后台，emqx 会安装一个新的 log handler，并给其指定过滤条件为：仅当 ClientID 为 \"my_client\" 的时候，输出日志： $ emqx_ctl log handlers list LogHandler(id=trace_clientid_my_client, level=debug, destination=log/my_client.log) ... 这里看到新添加的 log handler 的 id 为 trace_clientid_my_client，并且 handler level 为 debug。这就是为什么在 trace 之前，我们必须将 primary log level 设置为 debug。 如果使用默认的 primary log level (warning)，这个log handler 永远不会输出 warning 以下的日志消息。 另外，由于我们是启用了一个新的 log handler，所以我们的日志追踪不受控制台日志和 emqx.log.N 文件日志的级别的约束。即使 log.level = warning，我们任然可以追踪到 my_client 的 debug 级别的日志。 .emqxee { display: none; }"},"getting-started/dashboard.html":{"url":"getting-started/dashboard.html","title":"Dashboard","summary":null,"keywords":"","body":"Dashboard简介启用 Dashboard查看 Dashboard配置 DashboardDashboard 界面MONITORINGRULE ENGINEMANAGEMENTTOOLSADMINDashboard 简介 EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，你可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。 启用 Dashboard EMQ X Dashboard 功能由 emqx-dashboard 插件实现，该插件默认处于启用状态，它将在 EMQ X 启动时自动加载。如果你希望禁用 Dashboard 功能，你可以将 data/loaded_plugins（请参见 插件）中的 {emqx_dashboard, true} 修改为 {emqx_dashboard, false}。 {emqx_dashboard, true}. 查看 Dashboard EMQ X Dashboard 是一个 Web 应用程序，你可以直接通过浏览器来访问它，无需安装任何其他软件。 当 EMQ X 成功运行在你的本地计算机上且 EMQ X Dashboard 被默认启用时，你可以访问 http://localhost:18083 来查看你的 Dashboard，默认用户名是 admin，密码是 public。 配置 Dashboard 您可以在 etc/plugins/emqx_dashboard.conf 中查看或修改 EMQ X Dashboard 的配置，注意此处的 etc 并非指系统目录，请参见 目录结构。 EMQ X Dashboard 配置项可以分为默认用户与监听器两个部分： 默认用户 EMQ X Dashboard 可以配置多个用户，但在配置文件中仅支持配置默认用户。 需要注意的是，一旦您通过 Dashboard 修改了默认用户的密码，则默认用户的相关信息将以您在 Dashboard 上的最新改动为准，配置文件中的默认用户配置将被忽略。 监听器 EMQ X Dashboard 支持 HTTP 和 HTTPS 两种 Listener，但默认只启用了监听端口为 18083 的 HTTP Listener，关于 Listener 的介绍请参见 配置说明。 关于 Dashboard 的详细配置项说明，请参见 配置项。 Dashboard 界面 为了使用户在操作和浏览中可以快速地定位和切换当前位置，EMQ X Dashboard 采用了侧边导航的模式，默认情况下 Dashboard 包含以下一级导航项目： 导航项目 说明 MONITORING 提供了服务端与客户端监控信息的展示页面 RULE ENGINE 提供了规则引擎的可视化操作页面 MANAGEMENT 提供了扩展插件与应用的管理页面 TOOLS 提供了 WebSocket 客户端工具以及 HTTP API 速查页面 ADMIN 提供了 Dashboard 用户管理和显示设置等页面 MONITORING EMQ X Dashboard 提供了非常丰富的数据监控项目，完整地覆盖了服务端与客户端，这些信息都将在 MONITORING 下的页面中被合理地展示给用户。 Overview Overview 作为 Dashboard 的默认展示页面，提供了 EMQ X 当前节点的详细信息和集群其他节点的关键信息，以帮助用户快速掌握每个节点的状态。 Clients Clients 页面提供了连接到指定节点的客户端列表，同时支持通过 Client ID 直接搜索客户端。除了查看客户端的基本信息，您还可以点击每条记录右侧的 Kick Out 按钮踢掉该客户端，注意此操作将断开客户端连接并终结其会话。 Clients 页面使用快照的方式来展示客户端列表，因此当客户端状态发生变化时页面并不会自动刷新，需要您手动刷新浏览器来获取最新客户端数据。 如果你无法在客户端列表获取到你需要的信息，你可以单击 Client ID 来查看客户端的详细信息。 我们将客户端详情中的各个字段分为了 连接，会话 和 指标 三类，以下为各字段的说明： 连接 字段名 说明 Node 客户端连接的节点名称 Client ID 客户端标识符 Username 客户端连接时使用的用户名，出于安全性考虑，密码将不会被展示 Protocol 客户端使用的协议名称及其版本 IP Address 客户端的网络 IP 地址，地址可以是 IPv4 或 IPv6 Port 客户端源端口 Is Bridge 指示客户端是否通过桥接方式连接 Connected At 客户端连接时间 Disconnected At 客户端离线时间 Connection Status 客户端连接状态 Zone 指示客户端所使用的配置组 Keepalive 保持连接时间，单位：秒 会话 字段名 说明 Clean Session 指示客户端是否使用了全新的会话 Expiry Interval 会话过期间隔，单位：秒 Created At 会话创建时间 Subscriptions Count 当前订阅数量 Maximum Subscriptions Count 允许建立的最大订阅数量 Inflight Window Size 当前飞行窗口大小，请参见 飞行窗口与消息队列 Maximum Inflight Window Size 飞行窗口最大大小 Message Queue Size 当前消息队列大小，请参见 飞行窗口与消息队列 Maximum Message Queue Size 消息队列最大大小 Uncomfirmed PUBREC Packets 未确认的 PUBREC 报文数量 Maximum Uncomfirmed PUBREC Packets 允许存在未确认的 PUBREC 报文的最大数量 指标 字段名 说明 Number of Bytes Received EMQ X Broker（下同）接收的字节数量 Number of TCP Packets Received 接收的 TCP 报文数量 Number of MQTT Packets Received 接收的 MQTT 报文数量 Number of PUBLISH Packets Received 接收的 PUBLISH 报文数量 Number of Bytes Sent 发送的字节数量 Number of TCP Packets Sent 发送的 TCP 报文数量 Number of MQTT Packets Sent 发送的 MQTT 报文数量 Number of PUBLISH Packets Sent 发送的 PUBLISH 报文数量 在客户端详情的 Subscriptions 标签页中，您可以查看当前客户端的订阅信息，以及新建或取消订阅： Subscriptions Subscriptions 页面提供了指定节点下的所有订阅信息，并且支持用户通过 Client ID 查询指定客户端的所有订阅。 RULE ENGINE 使用 EMQ X 的规则引擎可以灵活地处理消息和事件，例如将消息转换成指定格式后存入数据库表或者重新发送到消息队列等等。为了方便用户更好地使用规则引擎，EMQ X Dashboard 提供了相应的可视化操作页面，您可以点击 RULE ENGINE 导航项目来访问这些页面。 鉴于规则引擎的相关概念比较复杂， 涉及到的操作可能会占据相当大的篇幅，考虑到您的阅读体验，我们将通过额外的文档来介绍规则引擎，请参见 规则引擎。 MANAGEMENT 目前 EMQ X Dashboard 的 MANAGEMENT 导航项目下主要包括扩展插件（请参见 插件）的监控管理页面和用于 HTTP API 认证的 AppID 与 AppSerect（请参见 HTTP API）的管理页面。 Plugins Plugins 页面列举了 EMQ X 能够发现的所有插件，包括 EMQ X 官方插件与您遵循 EMQ X 官方标准自行开发的插件，您可以在此页面查看插件当前的运行状态以及随时启停插件。 您可以看到，除了 emqx-dashboard 以外，EMQ X 还将默认启动 emqx-rule-engine 等 4 个插件： Applications Applications 页面列举了当前已创建的应用，您可以在此页面进行诸如创建应用、临时禁用或启动某个应用的访问权限等操作。EMQ X 会创建一个 AppID 为 admin，AppSecret 为 publish 的默认应用方便用户首次访问： 您可以点击 Application 页面右上角的 New App 按钮来创建一个新的应用，其中 AppID 与 AppSecret 是必选项。创建完成后您可以点击 View 按钮来查看应用详情，AppSecret 也会在详情中显示。以下是相关字段的说明： 字段名 说明 AppID 应用标识符，用于区分不同的应用，因此不可重复，在创建应用时 Dashboard 将自动为你生成一个随机的建议应用标识符 AppName 应用名称，可以重复，但为了方便您自己使用，我们不建议使用重复的应用名称 AppSecret 由 EMQ X 分配的应用密钥，可以在应用详情中查看 Expired date 应用的过期时间，默认为永不过期 Remark 您对应用的描述，方便后期管理 Status 应用状态，只有 Allowed 与 Denied 两种，Denied 状态下 EMQ X 将拒绝使用该 AppID 与 App Secret 的 HTTP API 的访问请求 TOOLS 目前 EMQ X Dashboard 的 TOOLS 导航项目下主要包括 WebSocket 客户端工具页面以及 HTTP API 速查页面。 Websocket Websocket 页面为您提供了一个简易但有效的 WebSocket 客户端工具，它包含了连接、订阅和发布功能，同时还能查看自己发送和接收的报文数据，我们期望它可以帮助您快速地完成某些场景或功能的测试验证： HTTP API HTTP API 页面列举了 EMQ X 目前支持的所有 HTTP API 及其说明： ADMIN Users 您可以在 Users 页面查看和管理能够访问和操作 Dashboard 的用户： Settings 目前 EMQ X Dashboard 仅支持修改主题和语言两种设置： Help 如果您在使用 EMQ X 的过程中遇到了任何问题，我们在 Help 页面为您提供了 FAQ 等文档的链接。如果我们现有的文档依然无法解决您的问题，您可以前往我们在 Github 的开源社区咨询我们的技术人员。 .emqxee { display: none; }"},"advanced/retained.html":{"url":"advanced/retained.html","title":"保留消息","summary":null,"keywords":"","body":"保留消息简介配置保留消息 简介 服务端收到 Retain 标志为 1 的 PUBLISH 报文时，会将该报文视为保留消息，除了被正常转发以外，保留消息会被存储在服务端，每个主题下只能存在一份保留消息，因此如果已经存在相同主题的保留消息，则该保留消息被替换。 当客户端建立订阅时，如果服务端存在主题匹配的保留消息，则这些保留消息将被立即发送给该客户端。借助保留消息，新的订阅者能够立即获取最近的状态，而不需要等待无法预期的时间，这在很多场景下非常重要的。 EMQ X 默认开启保留消息的功能，可以在 etc/emqx.conf 中修改 mqtt.retain_available 为 false 以禁用保留消息功能。如果 EMQ X 在保留消息功能被禁用的情况下依然收到了保留消息，那么将返回原因码为 0x9A（不支持保留消息）的 DISCONNECT 报文。 配置 EMQ X 的保留消息功能是由 emqx_retainer 插件实现，该插件默认开启，通过修改 emqx_retainer 插件的配置，可以调整 EMQ X 储存保留消息的位置，限制接收保留消息数量和 Payload 最大长度，以及调整保留消息的过期时间。关于 EMQ X 插件的更多信息， 请参见 插件。 emqx_retainer 插件默认开启，插件的配置路径为 etc/plugins/emqx_retainer.conf。 配置项 类型 可取值 默认值 说明 retainer.storage_type enum ram, disc, disc_only ram ram：仅储存在内存中；disc：储存在内存和硬盘中；disc_only：仅储存在硬盘中。 retainer.max_retained_messages integer >= 0 0 保留消息的最大数量，0 表示没有限制。保留消息数量超出最大值限制后，可以替换已存在的保留消息，但不能为新的主题储存保留消息。 retainer.max_payload_size bytesize 1MB 保留消息的最大 Payload 值。Payload 大小超出最大值后 EMQ Ｘ 消息服务器会把收到的保留消息作为普通消息处理。 retainer.expiry_interval duration ０ 保留消息的过期时间，0 表示永不过期。如果 PUBLISH 报文中设置了消息过期间隔，那么以 PUBLISH 报文中的消息过期间隔为准。 EMQ X Enterprise 中可将保留消息存储到多种外部数据库。 .emqxee { display: none; }"},"advanced/shared-subscriptions.html":{"url":"advanced/shared-subscriptions.html","title":"共享订阅","summary":null,"keywords":"","body":"共享订阅带群组的共享订阅不带群组的共享订阅均衡策略与派发 Ack 配置共享订阅 共享订阅是在多个订阅者之间实现负载均衡的订阅方式： [subscriber1] got msg1 msg1, msg2, msg3 / [publisher] ----------------> \"$share/g/topic\" -- [subscriber2] got msg2 \\ [subscriber3] got msg3 上图中，共享 3 个 subscriber 用共享订阅的方式订阅了同一个主题 $share/g/topic，其中topic 是它们订阅的真实主题名，而 $share/g/ 是共享订阅前缀。EMQ X 支持两种格式的共享订阅前缀： 示例 前缀 真实主题名 $queue/t/1 $queue/ t/1 $share/abc/t/1 $share/abc t/1 带群组的共享订阅 以 $share/ 为前缀的共享订阅是带群组的共享订阅： group-name 可以为任意字符串，属于同一个群组内部的订阅者将以负载均衡接收消息，但 EMQ X 会向不同群组广播消息。 例如，假设订阅者 s1，s2，s3 属于群组 g1，订阅者 s4，s5 属于群组 g2。那么当 EMQ X 向这个主题发布消息 msg1 的时候： EMQ X 会向两个群组 g1 和 g2 同时发送 msg1 s1，s2，s3 中只有一个会收到 msg1 s4，s5 中只有一个会收到 msg1 [s1] msg1 / [emqx] ------> \"$share/g1/topic\" - [s2] got msg1 | \\ | [s3] | msg1 ----> \"$share/g2/topic\" -- [s4] \\ [s5] got msg1 不带群组的共享订阅 以 $queue/ 为前缀的共享订阅是不带群组的共享订阅。它是 $share 订阅的一种特例，相当与所有订阅者都在一个订阅组里面： [s1] got msg1 msg1,msg2,msg3 / [emqx] ---------------> \"$queue/topic\" - [s2] got msg2 \\ [s3] got msg3 均衡策略与派发 Ack 配置 EMQ X 的共享订阅支持均衡策略与派发 Ack 配置： # etc/emqx.conf # 均衡策略 broker.shared_subscription_strategy = random # 适用于 QoS1 QoS2 消息，启用时在其中一个组离线时，将派发给另一个组 broker.shared_dispatch_ack_enabled = false 均衡策略 描述 random 在所有订阅者中随机选择 round_robin 按照订阅顺序 sticky 一直发往上次选取的订阅者 hash 按照发布者 ClientID 的哈希值 无论是单客户端订阅还是共享订阅都要注意客户端性能与消息接收速率，否则会引发消息堆积、客户端崩溃等错误。 .emqxee { display: none; }"},"advanced/delay-publish.html":{"url":"advanced/delay-publish.html","title":"延迟发布","summary":null,"keywords":"","body":"延迟发布延迟发布 EMQ X 的延迟发布功能可以实现按照用户配置的时间间隔延迟发布 PUBLISH 报文的功能。当客户端使用特殊主题前缀 $delayed/{DelayInteval} 发布消息到 EMQ X 时，将触发延迟发布功能。 延迟发布主题的具体格式如下： $delayed/{DelayInterval}/{TopicName} $delayed: 使用 $delay 作为主题前缀的消息都将被视为需要延迟发布的消息。延迟间隔由下一主题层级中的内容决定。 {DelayInterval}: 指定该 MQTT 消息延迟发布的时间间隔，单位是秒，允许的最大间隔是 4294967 秒。如果 {DelayInterval} 无法被解析为一个整型数字，EMQ X 将丢弃该消息，客户端不会收到任何信息。 {TopicName}: MQTT 消息的主题名称。 例如: $delayed/15/x/y: 15 秒后将 MQTT 消息发布到主题 x/y。 $delayed/60/a/b: 1 分钟后将 MQTT 消息发布到 a/b。 $delayed/3600/$SYS/topic: 1 小时后将 MQTT 消息发布到 $SYS/topic。 延迟发布功能由 emqx_mod_delayed 内置模块提供，此功能默认开启，支持动态启停，请参见 内置模块。 .emqxee { display: none; }"},"advanced/proxy-subscriptions.html":{"url":"advanced/proxy-subscriptions.html","title":"代理订阅","summary":null,"keywords":"","body":"代理订阅开启代理订阅功能配置代理订阅规则动态代理订阅代理订阅 EMQ X 的代理订阅功能使得客户端在连接建立时，不需要发送额外的 SUBSCRIBE 报文，便能自动建立用户预设的订阅关系。 开启代理订阅功能 代理订阅功能由 emqx_mod_subscription 内置模块提供，此功能默认关闭，支持在 EMQ X Broker 运行期间动态启停，请参见 内置模块。 配置代理订阅规则 代理订阅功能开启之后还需要配置相应的规则，EMQ X 的代理订阅规则支持用户自行配置，用户可以自行添加多条代理订阅规则，代理订阅规则支持用户配置 Topic 和订阅选项（QoS、No Local、Retain As Published、Retain Handling），其中 Topic 为必填项，订阅选项如果不配置的话 EMQ X 会应用默认的配置。 代理订阅规则的格式如下： ## 代理订阅的主题 module.subscription..topic = ## 代理订阅的订阅选项：QoS ## 可选值: 0、1、2 ## 默认值：1 module.subscription..qos = ## 代理订阅的订阅选项：No Local ## 可选值: 0、1 ## 默认值：0 module.subscription..nl = ## 代理订阅的订阅选项：Retain As Published ## 可选值: 0、1 ## 默认值：0 module.subscription..rap = ## 代理订阅的订阅选项：Retain Handling ## 可选值: 0、1、2 ## 默认值：0 module.subscription..rh = 需要注意的是，订阅选项中的 No Local、Retain As Published、Retain Handling 仅支持 MQTT V5 协议，当客户端以 MQTT V3 或 MQTT V3.1.1 连接时，代理订阅配置中仅有 Topic 与 QoS 的配置生效。 在配置代理订阅的主题时，EMQ X 提供了 %c 和 %u 两个占位符供用户使用，EMQ X 会在执行代理订阅时将配置中的 %c 和 %u 分别替换为客户端的 Client ID 和 Username，需要注意的是，%c 和 %u 必须占用一整个主题层级。 例如，在 etc/emqx.conf 文件中添加以下代理订阅规则： module.subscription.1.topic = client/%c module.subscription.2.topic = user/%u module.subscription.2.qos = 2 module.subscription.2.nl = 1 module.subscription.2.rap = 1 module.subscription.2.rh = 1 配置 A、B 两个客户端，客户端 A 的 Client ID 为 testclientA，Username 为 testerA，客户端 B 的 Client ID 为 testclientB，Username 为 testerB。 A 客户端使用 MQTT V3.1.1 协议连接 EMQ X，根据上文的配置规则，代理订阅功能会主动帮客户端订阅 QoS 为 1 的 client/testclientA 和 QoS 为 2 的 user/testerA 这两个主题，因为连接协议为 MQTT V3.1.1，所以配置中的 No Local、Retain As Published、Retain Handling 不生效。 B 客户端使用 MQTT V5 协议连接 EMQ X，根据上文的配置规则，代理订阅功能会主动帮客户端订阅 client/testclientB 和 user/testerB 这两个主题，其中 client/testclientB 的订阅选项为 Qos = 1，No Local、Retain As Published、Retain Handling 均为 0；user/testerB 的订阅选项为 Qos = 2、No Local = 1、Retain As Published = 1 、Retain Handling = 1。 动态代理订阅 EMQ X Enterprise 版本中支持动态代理订阅，即通过外部数据库设置主题列表在设备连接时读取列表实现代理订阅。 .emqxee { display: none; }"},"advanced/bridge.html":{"url":"advanced/bridge.html","title":"消息桥接","summary":null,"keywords":"","body":"消息桥接 RPC 桥接的优缺点 RPC 桥接举例 MQTT 桥接举例 EMQ X 桥接缓存配置 消息桥接 EMQ X 支持两种桥接方式: RPC 桥接: 使用 Erlang RPC 协议的桥接方式，只能在 EMQ X 间使用 MQTT 桥接: 使用 MQTT 协议、作为客户端连接到远程 Broker 的桥接方式，可桥接到其他 MQTT Broker 以及 EMQ X Broker 其概念如下图所示: 发布者可通过桥接将消息发布到远程的 Broker: EMQ X 根据不同的 name 来区分不同的 bridge。可在 etc/plugins/emqx_bridge_mqtt.conf 中添加 Bridge: bridge.mqtt.aws.address = 211.182.34.1:1883 bridge.mqtt.huawei.address = 54.33.120.8:1883 该项配置声明了两个 bridge，一个名为 aws，另一个名为 huawei，并分别指向响应的服务地址，使用 MQTT 方式桥接。 如果该配置的值是另一个 EMQ X 的节点名，则使用 RPC 方式桥接: bridge.mqtt.emqx2.address = emqx2@57.122.76.34 使用桥接功能需要启动 emqx_bridge_mqtt 插件: $ emqx_ctl plugins load emqx_bridge_mqtt ok RPC 桥接的优缺点 RPC 桥接的优点在于其不涉及 MQTT 协议编解码，效率高于 MQTT 桥接。 RPC 桥接的缺点: RPC 桥接只能将两个 EMQ X 桥接在一起（版本须相同），无法桥接 EMQ X 到其他的 MQTT Broker 上 RPC 桥接只能将本地的消息转发到远程桥接节点上，无法将远程桥接节点的消息同步到本地节点上 RPC 桥接举例 假设有两个 emqx 节点: 名称 节点 MQTT 端口 emqx1 emqx1@192.168.1.1 1883 emqx2 emqx2@192.168.1.2 1883 现在我们要将 emqx1 桥接到 emqx2。首先需要在 emqx1 的 etc/plugins/emqx_bridge_mqtt.conf 配置文件里添加 Bridge 配置并指向emqx2: bridge.mqtt.emqx2.address = emqx2@192.168.1.2 接下来定义 forwards 规则，这样本节点上发到 sensor1/#、sensor2/# 上的消息都会被转发到 emqx2: bridge.mqtt.emqx2.forwards = sensor1/#,sensor2/# 如果想要在消息转发前给 emqx2 之前，给主题加上特定前缀，可以设置挂载点: bridge.mqtt.emqx2.mountpoint = bridge/emqx2/${node}/ 挂载点利于 emqx2 区分桥接消息和本地消息。例如，以上配置中，原主题为 sensor1/hello 的消息，转发到 emqx2 后主题会变为 bridge/emqx2/emqx1@192.168.1.1/sensor1/hello。 MQTT 桥接举例 MQTT 桥接是让 EMQ X 作为 MQTT 客户端连接到远程的 MQTT Broker。 首先需要配置 MQTT 客户端参数: 远程 Broker 地址: bridge.mqtt.aws.address = 211.182.34.1:1883 MQTT 协议版本，可以为 mqttv3、mqttv4 或 mqttv5 其中之一: bridge.mqtt.aws.proto_ver = mqttv4 MQTT 客户端的 clientid: bridge.mqtt.aws.clientid = bridge_emq MQTT 客户端的 username 字段: bridge.mqtt.aws.username = user MQTT 客户端的 password 字段: bridge.mqtt.aws.password = passwd Keepalive 设置: bridge.mqtt.aws.keepalive = 60s 然后是客户端的 clean_start 字段，有些 IoT Hub 要求 clean_start（或 clean_session) 字段必须为 true: bridge.mqtt.aws.clean_start = true 可设置桥接断线重连间隔: bridge.mqtt.aws.reconnect_interval = 30s 如需使用 TLS 连接，可以设置 bridge.mqtt.aws.ssl = on 并设置 TLS 证书: bridge.mqtt.aws.ssl = off bridge.mqtt.aws.cacertfile = etc/certs/cacert.pem bridge.mqtt.aws.certfile = etc/certs/client-cert.pem bridge.mqtt.aws.keyfile = etc/certs/client-key.pem bridge.mqtt.aws.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384 bridge.mqtt.aws.tls_versions = tlsv1.2,tlsv1.1,tlsv1 接下来定义 forwards 规则，这样本节点上发到 sensor1/#、sensor2/# 上的消息都会被转发到远程 Broker: bridge.mqtt.aws.forwards = sensor1/#,sensor2/# 还可指定 QoS1 与 QoS2 消息的重传间隔以及批量发送报文数: bridge.mqtt.aws.retry_interval = 20s bridge.mqtt.aws.max_inflight_batches = 32 如果想要在消息转发前给 aws 之前，给主题加上特定前缀，可以设置挂载点，详见 RPC 桥接举例 章节: bridge.mqtt.aws.mountpoint = bridge/aws/${node}/ 如果想让本地 Broker \"拉取\" 远程 Broker 的消息，可以向远程 Broker 订阅某些主题: bridge.mqtt.aws.subscription.1.topic = cmd/topic1 bridge.mqtt.aws.subscription.1.qos = 1 EMQ X 桥接缓存配置 EMQ X 的 Bridge 拥有消息缓存机制，当 Bridge 连接断开时会将 forwards 主题的消息缓存，等到桥接恢复时，再把消息重新转发到远程节点上。缓存机制同时适用于 RPC 桥接和 MQTT 桥接。 设置缓存队列总大小: bridge.mqtt.aws.queue.max_total_size = 5GB 将消息缓存到磁盘的某个路径（如不设置，则仅缓存到内存）: bridge.mqtt.emqx2.queue.replayq_dir = data/emqx_emqx2_bridge/ 设置单个缓存文件的大小，如超过则会创建新的文件来存储消息队列: bash bridge.mqtt.emqx2.queue.replayq_seg_bytes = 10MB .emqxee { display: none; }"},"advanced/topic-rewrite.html":{"url":"advanced/topic-rewrite.html","title":"主题重写","summary":null,"keywords":"","body":"主题重写启停主题重写功能配置主题重写规则示例主题重写 EMQ X 的主题重写功能支持根据用户配置的规则在客户端订阅主题、发布消息、取消订阅的时候将 A 主题重写为 B 主题。 EMQ X 的 保留消息 和 延迟发布 可以与主题重写配合使用，例如，当用户想使用延迟发布功能，但不方便修改客户端发布的主题时，可以使用主题重写将相关主题重写为延迟发布的主题格式。 启停主题重写功能 主题重写功能由 emqx_mod_rewrite 内置模块提供, 此功能默认关闭，支持在 EMQ X Broker 运行期间动态启停，请参见 内置模块。 配置主题重写规则 EMQ X 的主题重写规则需要用户自行配置，用户可以自行添加多条主题重写规则，规则的数量没有限制，但由于任何携带主题的 MQTT 报文都需要匹配一遍重写规则，因此此功能在高吞吐场景下带来的性能损耗与规则数量是成正比的，用户需要谨慎地使用此功能。 每条主题重写规则的格式如下： module.rewrite.rule. = 主题过滤器 正则表达式 目标表达式 每条重写规则都由以空格分隔的主题过滤器、正则表达式、目标表达式三部分组成。在主题重写功能开启的前提下，EMQ X 在收到诸如 PUBLISH 报文等带有主题的 MQTT 报文时，将使用报文中的主题去依次匹配配置文件中规则的主题过滤器部分，一旦成功匹配，则使用正则表达式提取主题中的信息，然后替换至目标表达式以构成新的主题。 目标表达式中可以使用 $N 这种格式的变量匹配正则表达中提取出来的元素，$N 的值为正则表达式中提取出来的第 N 个元素，比如 $1 即为正则表达式提取的第一个元素。 需要注意的是，EMQ X 使用倒序读取配置文件中的重写规则，当一条主题可以同时匹配多条主题重写规则的主题过滤器时，EMQ X 仅会使用它匹配到的第一条规则进行重写，如果该条规则中的正则表达式与 MQTT 报文主题不匹配，则重写失败，不会再尝试使用其他的规则进行重写。因此用户在使用时需要谨慎的设计 MQTT 报文主题以及主题重写规则。 示例 假设 etc/emqx.conf 文件中已经添加了以下主题重写规则： module.rewrite.rule.1 = y/+/z/# ^y/(.+)/z/(.+)$ y/z/$2 module.rewrite.rule.2 = x/# ^x/y/(.+)$ z/y/x/$1 module.rewrite.rule.3 = x/y/+ ^x/y/(\\d+)$ z/y/$1 此时我们分别订阅 y/a/z/b、y/def、x/1/2、x/y/2、x/y/z 五个主题： y/def 不匹配任何一个主题过滤器，因此不执行主题重写，直接订阅 y/def 主题。 y/a/z/b 匹配 y/+/z/# 主题过滤器，EMQ X 执行 module.rewrite.rule.1 规则，通过正则正则表达式匹配出元素 [a、b] ，将匹配出来的第二个元素带入 y/z/$2，实际订阅了 y/z/b 主题。 x/1/2 匹配 x/# 主题过滤器，EMQ X 执行 module.rewrite.rule.2 规则，通过正则表达式未匹配到元素，不执行主题重写，实际订阅 x/1/2 主题。 x/y/2 同时匹配 x/# 和 x/y/+ 两个主题过滤器，EMQ X 通过倒序读取配置，所以优先匹配 module.rewrite.rule.3，通过正则替换，实际订阅了 z/y/2 主题。 x/y/z 同时匹配 x/# 和 x/y/+ 两个主题过滤器，EMQ X 通过倒序读取配置，所以优先匹配 module.rewrite.rule.3，通过正则表达式未匹配到元素，不执行主题重写，实际订阅 x/y/z 主题。需要注意的是，即使 module.rewrite.rule.3 的正则表达式匹配失败，也不会再次去匹配 module.rewrite.rule.2 的规则。 .emqxee { display: none; }"},"advanced/system-topic.html":{"url":"advanced/system-topic.html","title":"$SYS 系统主题","summary":null,"keywords":"","body":"$SYS 系统主题集群状态信息客户端上下线事件系统统计 (Statistics)收发流量 / 报文 / 消息统计Alarms - 系统告警Sysmon - 系统监控$SYS 系统主题 EMQ X 周期性发布自身运行状态、消息统计、客户端上下线事件到以 $SYS/ 开头系统主题。 $SYS 主题路径以 $SYS/brokers/{node}/ 开头。{node} 是指产生该 事件 / 消息 所在的节点名称，例如: $SYS/brokers/emqx@127.0.0.1/version $SYS/brokers/emqx@127.0.0.1/uptime $SYS 系统消息发布周期配置项： broker.sys_interval = 1m EMQ X 默认只允许本机的 MQTT 客户端订阅 $SYS 主题，请参照 内置 ACL 修改发布订阅 ACL 规则。 EMQ X 中 $SYS 主题中绝大部分数据都可以通过其他更耦合性更低的方式获取，设备上下线状态可通过 Webhook 获取，节点与集群状态可通过 HTTP API - 统计指标 获取。 集群状态信息 主题 说明 $SYS/brokers 集群节点列表 $SYS/brokers/${node}/version EMQ X 版本 $SYS/brokers/${node}/uptime EMQ X 运行时间 $SYS/brokers/${node}/datetime EMQ X 系统时间 $SYS/brokers/${node}/sysdescr EMQ X 描述 客户端上下线事件 $SYS 主题前缀: $SYS/brokers/${node}/clients/ 主题 (Topic) 说明 ${clientid}/connected 上线事件。当任意客户端上线时，EMQ X 就会发布该主题的消息 ${clientid}/disconnected 下线事件。当任意客户端下线时，EMQ X 就会发布该主题的消息 connected 事件消息的 Payload 解析成 JSON 格式如下: { \"username\":\"undefined\", \"ts\":1582687922392, \"sockport\":1883, \"proto_ver\":5, \"proto_name\":\"MQTT\", \"keepalive\":300, \"ipaddress\":\"127.0.0.1\", \"expiry_interval\":0, \"connected_at\":1582687922, \"connack\":0, \"clientid\":\"emqtt-8348fe27a87976ad4db3\", \"clean_start\":true } disconnected 事件消息的 Payload 解析成 JSON 格式如下: { \"username\":\"undefined\", \"ts\":1582688032203, \"reason\":\"tcp_closed\", \"disconnected_at\":1582688032, \"clientid\":\"emqtt-8348fe27a87976ad4db3\" } 系统统计 (Statistics) 系统主题前缀: $SYS/brokers/${node}/stats/ 客户端统计 主题 (Topic) 说明 connections/count 当前客户端总数 connections/max 客户端数量历史最大值 订阅统计 主题 (Topic) 说明 suboptions/count 当前订阅选项个数 suboptions/max 订阅选项总数历史最大值 subscribers/count 当前订阅者数量 subscribers/max 订阅者总数历史最大值 subscriptions/count 当前订阅总数 subscriptions/max 订阅数量历史最大值 subscriptions/shared/count 当前共享订阅个数 subscriptions/shared/max 当前共享订阅总数 主题统计 主题 (Topic) 说明 topics/count 当前 Topic 总数 topics/max Topic 数量历史最大值 路由统计 主题 (Topic) 说明 routes/count 当前 Routes 总数 routes/max Routes 数量历史最大值 topics/count 和 topics/max 与 routes/count 和 routes/max 数值上是相等的。 收发流量 / 报文 / 消息统计 系统主题 (Topic) 前缀: $SYS/brokers/${node}/metrics/ 收发流量统计 主题 (Topic) 说明 bytes/received 累计接收流量 bytes/sent 累计发送流量 MQTT 报文收发统计 主题 (Topic) 说明 packets/received 累计接收 MQTT 报文 packets/sent 累计发送 MQTT 报文 packets/connect 累计接收 MQTT CONNECT 报文 packets/connack 累计发送 MQTT CONNACK 报文 packets/publish/received 累计接收 MQTT PUBLISH 报文 packets/publish/sent 累计发送 MQTT PUBLISH 报文 packets/puback/received 累计接收 MQTT PUBACK 报文 packets/puback/sent 累计发送 MQTT PUBACK 报文 packets/puback/missed 累计丢失 MQTT PUBACK 报文 packets/pubrec/received 累计接收 MQTT PUBREC 报文 packets/pubrec/sent 累计发送 MQTT PUBREC 报文 packets/pubrec/missed 累计丢失 MQTT PUBREC 报文 packets/pubrel/received 累计接收 MQTT PUBREL 报文 packets/pubrel/sent 累计发送 MQTT PUBREL 报文 packets/pubrel/missed 累计丢失 MQTT PUBREL 报文 packets/pubcomp/received 累计接收 MQTT PUBCOMP 报文 packets/pubcomp/sent 累计发送 MQTT PUBCOMP 报文 packets/pubcomp/missed 累计丢失 MQTT PUBCOMP 报文 packets/subscribe 累计接收 MQTT SUBSCRIBE 报文 packets/suback 累计发送 MQTT SUBACK 报文 packets/unsubscribe 累计接收 MQTT UNSUBSCRIBE 报文 packets/unsuback 累计发送 MQTT UNSUBACK 报文 packets/pingreq 累计接收 MQTT PINGREQ 报文 packets/pingresp 累计发送 MQTT PINGRESP 报文 packets/disconnect/received 累计接收 MQTT DISCONNECT 报文 packets/disconnect/sent 累计接收 MQTT DISCONNECT 报文 packets/auth 累计接收 MQTT AUTH 报文 MQTT 消息收发统计 主题 (Topic) 说明 messages/received 累计接收消息 messages/sent 累计发送消息 messages/expired 累计过期消息 messages/retained Retained 消息总数 messages/dropped 丢弃消息总数 messages/forward 节点转发消息总数 messages/qos0/received 累计接收 QoS 0 消息 messages/qos0/sent 累计发送 QoS 0 消息 messages/qos1/received 累计接收 QoS 1 消息 messages/qos1/sent 累计发送 QoS 1 消息 messages/qos2/received 累计接收 QoS 2 消息 messages/qos2/sent 累计发送 QoS 2 消息 messages/qos2/expired QoS 2 过期消息总数 messages/qos2/dropped QoS 2 丢弃消息总数 Alarms - 系统告警 系统主题 (Topic) 前缀: $SYS/brokers/${node}/alarms/ 主题 (Topic) 说明 alert 新产生的告警 clear 被清除的告警 Sysmon - 系统监控 系统主题 (Topic) 前缀: $SYS/brokers/${node}/sysmon/ 主题 (Topic) 说明 long_gc GC 时间过长警告 long_schedule 调度时间过长警告 large_heap Heap 内存占用警告 busy_port Port 忙警告 busy_dist_port Dist Port 忙警告 .emqxee { display: none; }"},"advanced/blacklist.html":{"url":"advanced/blacklist.html","title":"黑名单","summary":null,"keywords":"","body":"黑名单黑名单 EMQ X 为用户提供了黑名单功能，用户可以通过相关的 HTTP API 将指定客户端加入黑名单以拒绝该客户端访问，除了客户端标识符以外，还支持直接封禁用户名甚至 IP 地址。 相关 HTTP API 的具体使用方法，请参见 HTTP API - 黑名单。 黑名单只适用于少量客户端封禁需求，如果有大量客户端需要认证管理，请使用 认证 功能。 在黑名单功能的基础上，EMQ X 支持自动封禁那些被检测到短时间内频繁登录的客户端，并且在一段时间内拒绝这些客户端的登录，以避免此类客户端过多占用服务器资源而影响其他客户端的正常使用。 需要注意的是，自动封禁功能只封禁客户端标识符，并不封禁用户名和 IP 地址，即该机器只要更换客户端标识符就能够继续登录。 此功能默认关闭，用户可以在 emqx.conf 配置文件中将 enable_flapping_detect 配置项设为 on 以启用此功能。 zone.external.enable_flapping_detect = off 用户可以为此功能调整触发阈值和封禁时长，对应配置项如下： flapping_detect_policy = 30, 1m, 5m 此配置项的值以 , 分隔，依次表示客户端离线次数，检测的时间范围以及封禁时长，因此上述默认配置即表示如果客户端在 1 分钟内离线次数达到 30 次，那么该客户端使用的客户端标识符将被封禁 5 分钟。当然你也可以使用其他诸如秒、小时在内的时间单位，关于这部分内容，请参见 配置说明。 .emqxee { display: none; }"},"advanced/webhook.html":{"url":"advanced/webhook.html","title":"WebHook","summary":null,"keywords":"","body":"WebHook配置项触发规则Event 触发事件NumberRuleWebhook 事件参数WebHook WebHook 是由 emqx_web_hook 插件提供的 将 EMQ X 中的钩子事件通知到某个 Web 服务 的功能。 WebHook 的内部实现是基于 钩子，但它更靠近顶层一些。它通过在钩子上的挂载回调函数，获取到 EMQ X 中的各种事件，并转发至 emqx_web_hook 中配置的 Web 服务器。 以 客户端成功接入(client.connected) 事件为例，其事件的传递流程如下： Client | EMQ X | emqx_web_hook | HTTP +------------+ =============>| - - - - - - -> - - - - - - - ->===========> | Web Server | | Broker | | Request +------------+ WebHook 对于事件的处理是单向的，它仅支持将 EMQ X 中的事件推送给 Web 服务，并不关心 Web 服务的返回。 借助 Webhook 可以完成设备在线、上下线记录，订阅与消息存储、消息送达确认等诸多业务。 配置项 Webhook 的配置文件位于 etc/plugins/emqx_web_hook.conf： 配置项 类型 可取值 默认值 说明 api.url string - http://127.0.0.1:8080 事件需要转发的目的服务器地址 encode_payload enum base64, base62 undefined 对消息类事件中的 Payload 字段进行编码，注释或其他则表示不编码 当消息内容是不可见字符（如二进制数据）时，为了能够在 HTTP 协议中传输，使用 encode_payload 是十分有用的。 触发规则 在 etc/plugins/emqx_web_hooks.conf 可配置触发规则，其配置的格式如下： ## 格式示例 web.hook.rule.. = ## 示例值 web.hook.rule.message.publish.1 = {\"action\": \"on_message_publish\", \"topic\": \"a/b/c\"} web.hook.rule.message.publish.2 = {\"action\": \"on_message_publish\", \"topic\": \"foo/#\"} Event 触发事件 目前支持以下事件： 名称 说明 执行时机 client.connect 处理连接报文 服务端收到客户端的连接报文时 client.connack 下发连接应答 服务端准备下发连接应答报文时 client.connected 成功接入 客户端认证完成并成功接入系统后 client.disconnected 连接断开 客户端连接层在准备关闭时 client.subscribe 订阅主题 收到订阅报文后，执行 client.check_acl 鉴权前 client.unsubscribe 取消订阅 收到取消订阅报文后 session.subscribed 会话订阅主题 完成订阅操作后 session.unsubscribed 会话取消订阅 完成取消订阅操作后 message.publish 消息发布 服务端在发布（路由）消息前 message.delivered 消息投递 消息准备投递到客户端前 message.acked 消息回执 服务端在收到客户端发回的消息 ACK 后 message.dropped 消息丢弃 发布出的消息被丢弃后 Number 同一个事件可以配置多个触发规则，配置相同的事件应当依次递增。 Rule 触发规则，其值为一个 JSON 字符串，其中可用的 Key 有： action：字符串，取固定值 topic：字符串，表示一个主题过滤器，操作的主题只有与该主题匹配才能触发事件的转发 例如，我们只将与 a/b/c 和 foo/# 主题匹配的消息转发到 Web 服务器上，其配置应该为： web.hook.rule.message.publish.1 = {\"action\": \"on_message_publish\", \"topic\": \"a/b/c\"} web.hook.rule.message.publish.2 = {\"action\": \"on_message_publish\", \"topic\": \"foo/#\"} 这样 Webhook 仅会转发与 a/b/c 和 foo/# 主题匹配的消息，例如 foo/bar 等，而不是转发 a/b/d 或 fo/bar。 Webhook 事件参数 事件触发时 Webhook 会按照配置将每个事件组成一个 HTTP 请求发送到 api.url 所配置的 Web 服务器上。其请求格式为： URL: # 来自于配置中的 `api.url` 字段 Method: POST # 固定为 POST 方法 Body: # Body 为 JSON 格式字符串 对于不同的事件，请求 Body 体内容有所不同，下表列举了各个事件中 Body 的参数列表： client.connect Key 类型 说明 action string 事件名称固定为：\"client_connect\" clientid string 客户端 ClientId username string 客户端 Username，不存在时该值为 \"undefined\" ipaddress string 客户端源 IP 地址 keepalive integer 客户端申请的心跳保活时间 proto_ver integer 协议版本号 client.connack Key 类型 说明 action string 事件名称固定为：\"client_connack\" clientid string 客户端 ClientId username string 客户端 Username，不存在时该值为 \"undefined\" ipaddress string 客户端源 IP 地址 keepalive integer 客户端申请的心跳保活时间 proto_ver integer 协议版本号 conn_ack string \"success\" 表示成功，其它表示失败的原因 client.connected Key 类型 说明 action string 事件名称固定为：\"client_connected\" clientid string 客户端 ClientId username string 客户端 Username，不存在时该值为 \"undefined\" ipaddress string 客户端源 IP 地址 keepalive integer 客户端申请的心跳保活时间 proto_ver integer 协议版本号 connected_at integer 时间戳(秒) client.disconnected Key 类型 说明 action string 事件名称固定为：\"client_disconnected\" clientid string 客户端 ClientId username string 客户端 Username，不存在时该值为 \"undefined\" reason string 错误原因 client.subscribe Key 类型 说明 action string 事件名称固定为：\"client_subscribe\" clientid string 客户端 ClientId username string 客户端 Username，不存在时该值为 \"undefined\" topic string 将订阅的主题 opts json 订阅参数 opts 包含 Key 类型 说明 qos enum QoS 等级，可取 0 1 2 client.unsubscribe Key 类型 说明 action string 事件名称固定为：\"client_unsubscribe\" clientid string 客户端 ClientId username string 客户端 Username，不存在时该值为 \"undefined\" topic string 取消订阅的主题 session.subscribed：同 client.subscribe，action 为 session_subscribed session.unsubscribed：同 client.unsubscribe，action 为 session_unsubscribe session.terminated： 同 client.disconnected，action 为 session_terminated message.publish Key 类型 说明 action string 事件名称固定为：\"message_publish\" from_client_id string 发布端 ClientId from_username string 发布端 Username，不存在时该值为 \"undefined\" topic string 取消订阅的主题 qos enum QoS 等级，可取 0 1 2 retain bool 是否为 Retain 消息 payload string 消息 Payload ts integer 消息的时间戳(毫秒) message.delivered Key 类型 说明 action string 事件名称固定为：\"message_delivered\" clientid string 接收端 ClientId username string 接收端 Username，不存在时该值为 \"undefined\" from_client_id string 发布端 ClientId from_username string 发布端 Username，不存在时该值为 \"undefined\" topic string 取消订阅的主题 qos enum QoS 等级，可取 0 1 2 retain bool 是否为 Retain 消息 payload string 消息 Payload ts integer 消息时间戳(毫秒) message.acked Key 类型 说明 action string 事件名称固定为：\"message_acked\" clientid string 接收端 ClientId from_client_id string 发布端 ClientId from_username string 发布端 Username，不存在时该值为 \"undefined\" topic string 取消订阅的主题 qos enum QoS 等级，可取 0 1 2 retain bool 是否为 Retain 消息 payload string 消息 Payload ts integer 消息时间戳(毫秒) .emqxee { display: none; }"},"advanced/cluster.html":{"url":"advanced/cluster.html","title":"分布集群","summary":null,"keywords":"","body":"分布式集群分布式 Erlang 节点与分布式 Erlang 安全 EMQ X 集群协议设置 EMQ X 分布式集群设计 订阅表: 主题 - 订阅者 路由表: 主题 - 节点 主题树: 带统配符的主题匹配 消息派发过程 数据分片与共享方式 节点发现与自动集群 manual 手动创建集群 基于 static 节点列表自动集群 基于 mcast 组播自动集群 基于 DNS A 记录自动集群 基于 etcd 自动集群 基于 kubernetes 自动集群 手动(manual) 方式管理集群介绍 集群脑裂与自动愈合 集群节点自动清除 防火墙设置 分布式集群 分布式 Erlang Erlang/OTP 最初是爱立信为开发电信设备系统设计的编程语言平台，电信设备 (路由器、接入网关...) 典型设计是通过背板连接主控板卡与多块业务板卡的分布式系统。 节点与分布式 Erlang Erlang/OTP 语言平台的分布式程序，由分布互联的 Erlang 运行时系统组成，每个 Erlang 运行时系统被称为节点(Node)，节点间通过 TCP 两两互联，组成一个网状结构。 Erlang 节点由唯一的节点名称标识，节点名称由 @ 分隔的两部分组成: @ 节点间通过节点名称进行通信寻址。例如在本机启动四个 shell 终端，然后使用 -name 参数分别启动四个 Erlang 节点: erl -name node1@127.0.0.1 -setcookie my_nodes erl -name node2@127.0.0.1 -setcookie my_nodes erl -name node3@127.0.0.1 -setcookie my_nodes erl -name node4@127.0.0.1 -setcookie my_nodes 使用 node(). 可查看本节点名，使用 nodes(). 可查看已与当前节点建立连接的其他节点。我们现在到 'node1@127.0.0.1' 的控制台下，查看当前节点名和已连接的节点: (node1@127.0.0.1) 4> node(). 'node1@127.0.0.1' (node1@127.0.0.1) 4> nodes(). [] 然后我们让 node1 发起与其他节点的连接: (node1@127.0.0.1) 1> net_kernel:connect_node('node2@127.0.0.1'). true (node1@127.0.0.1) 2> net_kernel:connect_node('node3@127.0.0.1'). true (node1@127.0.0.1) 3> net_kernel:connect_node('node4@127.0.0.1'). true 现在再次可查看已与 node1 建立连接的其他节点: (node1@127.0.0.1) 4> nodes(). ['node2@127.0.0.1','node3@127.0.0.1','node4@127.0.0.1'] 可以看到 node2、node3、node4 都已与 node1 建立了分布式连接，四个节点组成了一个集群。注意每当一个新的节点加入集群时，它会与集群中所有的节点都建立一个 TCP 连接。至此，四个节点完成了如下图所示的网状结构: 安全 Erlang 节点间通过 cookie 进行互连认证。cookie 是一个字符串，只有 cookie 相同的两个节点才能建立连接。上节 中我们曾经使用 -setcookie my_nodes 参数给四个节点设置了相同的 cookie: my_nodes。 详见: http://erlang.org/doc/reference_manual/distributed.html EMQ X 集群协议设置 Erlang 集群中各节点可通过 TCPv4、TCPv6 或 TLS 方式连接，可在 etc/emqx.conf 中配置连接方式: 配置名 类型 默认值 描述 cluster.proto_dist enum inet_tcp 分布式协议，可选值： - inet_tcp: 使用 TCP IPv4 - inet6_tcp: 使用 TCP IPv6 - inet_tls: 使用 TLS node.ssl_dist_optfile 文件路径 etc/ssl_dist.conf 当 cluster.proto_dist 选定为 inet_tls 时，需要配置 etc/ssl_dist.conf 文件，指定 TLS 证书等 EMQ X 分布式集群设计 EMQ X 分布式的基本功能是将消息转发和投递给各节点上的订阅者，如下图所示： 为实现此过程，EMQ X 维护了几个与之相关的数据结构：订阅表，路由表，主题树。 订阅表: 主题 - 订阅者 MQTT 客户端订阅主题时，EMQ X 会维护主题(Topic) -> 订阅者(Subscriber) 映射的订阅表。订阅表只存在于订阅者所在的 EMQ X 节点上，例如: node1: topic1 -> client1, client2 topic2 -> client3 node2: topic1 -> client4 路由表: 主题 - 节点 而同一集群的所有节点，都会复制一份主题(Topic) -> 节点(Node) 映射的路由表，例如: topic1 -> node1, node2 topic2 -> node3 topic3 -> node2, node4 主题树: 带统配符的主题匹配 除路由表之外，EMQ X 集群中的每个节点也会维护一份主题树(Topic Trie) 的备份。 例如下述主题订阅关系: 客户端 节点 订阅主题 client1 node1 t/+/x, t/+/y client2 node2 t/# client3 node3 t/+/x, t/a 在所有订阅完成时，EMQ X 中会维护如下主题树 (Topic Trie) 和路由表 (Route Table): 消息派发过程 当 MQTT 客户端发布消息时，所在节点会根据消息主题，检索路由表并转发消息到相关节点，再由相关节点检索本地的订阅表并将消息发送给相关订阅者。 例如 client1 向主题 t/a 发布消息，消息在节点间的路由与派发流程: client1 发布主题为 t/a 的消息到节点 node1 node1 通过查询主题树，得知 t/a 可匹配到现有的 t/a、t/# 这两个主题。 node1 通过查询路由表，得知主题 t/a 只在 node3 上有订阅者，而主题 t/# 只在 node2 上有订阅者。故 node1 将消息转发给 node2 和 node3。 node2 收到转发来的 t/a 消息后，查询本地订阅表，获取本节点上订阅了 t/# 的订阅者，并把消息投递给他们。 node3 收到转发来的 t/a 消息后，查询本地订阅表，获取本节点上订阅了 t/a 的订阅者，并把消息投递给他们。 消息转发和投递结束。 数据分片与共享方式 EMQ X 的订阅表在集群中是分片(partitioned)的，而主题树和路由表是共享(replicated)的。 节点发现与自动集群 EMQ X 支持基于 Ekka 库的集群自动发现 (Autocluster)。Ekka 是为 Erlang/OTP 应用开发的集群管理库，支持 Erlang 节点自动发现 (Service Discovery)、自动集群 (Autocluster)、脑裂自动愈合 (Network Partition Autoheal)、自动删除宕机节点 (Autoclean)。 EMQ X 支持多种节点发现策略: 策略 说明 manual 手动命令创建集群 static 静态节点列表自动集群 mcast UDP 组播方式自动集群 dns DNS A 记录自动集群 etcd 通过 etcd 自动集群 k8s Kubernetes 服务自动集群 manual 手动创建集群 默认配置为手动创建集群，节点须通过 ./bin/emqx_ctl join \\ 命令加入: cluster.discovery = manual 基于 static 节点列表自动集群 配置固定的节点列表，自动发现并创建集群: cluster.discovery = static cluster.static.seeds = emqx1@127.0.0.1,emqx2@127.0.0.1 基于 mcast 组播自动集群 基于 UDP 组播自动发现并创建集群: cluster.discovery = mcast cluster.mcast.addr = 239.192.0.1 cluster.mcast.ports = 4369,4370 cluster.mcast.iface = 0.0.0.0 cluster.mcast.ttl = 255 cluster.mcast.loop = on 基于 DNS A 记录自动集群 基于 DNS A 记录自动发现并创建集群: cluster.discovery = dns cluster.dns.name = localhost cluster.dns.app = ekka 基于 etcd 自动集群 基于 etcd 自动发现并创建集群: cluster.discovery = etcd cluster.etcd.server = http://127.0.0.1:2379 cluster.etcd.prefix = emqcl cluster.etcd.node_ttl = 1m 基于 kubernetes 自动集群 Kubernetes 下自动发现并创建集群: cluster.discovery = k8s cluster.k8s.apiserver = http://10.110.111.204:8080 cluster.k8s.service_name = ekka cluster.k8s.address_type = ip cluster.k8s.app_name = ekka 手动(manual) 方式管理集群介绍 假设要在两台服务器 s1.emqx.io, s2.emqx.io 上部署 EMQ X 集群: 节点名 主机名 (FQDN) IP 地址 emqx@s1.emqx.io 或 emqx@192.168.0.10 s1.emqx.io 192.168.0.10 emqx@s2.emqx.io 或 emqx@192.168.0.20 s2.emqx.io 192.168.0.20 注意： 节点名格式为 Name@Host, Host 必须是 IP 地址或 FQDN (主机名。域名) 配置 emqx@s1.emqx.io 节点 emqx/etc/emqx.conf: node.name = emqx@s1.emqx.io # 或 node.name = emqx@192.168.0.10 也可通过环境变量: export EMQX_NODE_NAME=emqx@s1.emqx.io && ./bin/emqx start 注意: 节点启动加入集群后，节点名称不能变更。 配置 emqx@s2.emqx.io 节点 emqx/etc/emqx.conf: node.name = emqx@s2.emqx.io # 或 node.name = emqx@192.168.0.20 节点加入集群 启动两台节点后，在 s2.emqx.io 上执行: $ ./bin/emqx_ctl cluster join emqx@s1.emqx.io Join the cluster successfully. Cluster status: [{running_nodes,['emqx@s1.emqx.io','emqx@s2.emqx.io']}] 或者在 s1.emqx.io 上执行: $ ./bin/emqx_ctl cluster join emqx@s2.emqx.io Join the cluster successfully. Cluster status: [{running_nodes,['emqx@s1.emqx.io','emqx@s2.emqx.io']}] 在任意节点上查询集群状态: $ ./bin/emqx_ctl cluster status Cluster status: [{running_nodes,['emqx@s1.emqx.io','emqx@s2.emqx.io']}] 退出集群 节点退出集群，两种方式: leave: 让本节点退出集群 force-leave: 从集群删除其他节点 让 emqx@s2.emqx.io 主动退出集群: $ ./bin/emqx_ctl cluster leave 或在 s1.emqx.io 上，从集群删除 emqx@s2.emqx.io 节点: $ ./bin/emqx_ctl cluster force-leave emqx@s2.emqx.io 集群脑裂与自动愈合 EMQ X 支持集群脑裂自动恢复(Network Partition Autoheal)，可在 etc/emqx.conf 中配置: cluster.autoheal = on 集群脑裂自动恢复流程: 节点收到 Mnesia 的 inconsistent_database 事件 3 秒后进行集群脑裂确认； 节点确认集群脑裂发生后，向 Leader 节点 (集群中最早启动节点) 上报脑裂消息； Leader 节点延迟一段时间后，在全部节点在线状态下创建脑裂视图 (SplitView)； Leader 节点在多数派 (majority) 分区选择集群自愈的 Coordinator 节点； Coordinator 节点重启少数派 (minority) 分区节点恢复集群。 集群节点自动清除 EMQ X 支持从集群自动删除宕机节点 (Autoclean)，可在 etc/emqx.conf 中配置: cluster.autoclean = 5m 防火墙设置 若预先设置了环境变量 WITH_EPMD=1, 启动 emqx 时会使用启动 epmd (监听端口 4369) 做节点发现。称为 epmd 模式。 若环境变量 WITH_EPMD 没有设置，则启动 emqx 时不启用 epmd，而使用 emqx ekka 的节点发现，这也是 4.0 之后的默认节点发现方式。称为 ekka 模式。 epmd 模式： 如果集群节点间存在防火墙，防火墙需要开启 TCP 4369 端口和一个 TCP 端口段。4369 由 epmd 端口映射服务使用，TCP 端口段用于节点间建立连接与通信。 防火墙设置后，需要在 emqx/etc/emqx.conf 中配置相同的端口段: ## Distributed node port range node.dist_listen_min = 6369 node.dist_listen_max = 7369 ekka 模式（4.0 版本之后的默认模式）： 如果集群节点间存在防火墙，默认情况下，只需要开启 TCP 4370 端口。 但如果 node.name 配置制定的节点名字里，带有数字后缀(Offset)，则需要开启 4370 + Offset 端口。 比如： node.name = emqx-1@192.168.0.12 则需要开启 4371 端口。 .emqxee { display: none; }"},"advanced/hooks.html":{"url":"advanced/hooks.html","title":"钩子","summary":null,"keywords":"","body":"钩子定义回调链挂载点 挂载与取消挂载回调函数 钩子 定义 钩子(Hooks) 是 EMQ X 提供的一种机制，它通过拦截模块间的函数调用、消息传递、事件传递来修改或扩展系统功能。 简单来讲，该机制目的在于增强软件系统的扩展性、方便与其他三方系统的集成、或者改变其系统原有的默认行为。如： 当系统中不存在 钩子 (Hooks) 机制时，整个事件处理流程 从 事件 (Event) 的输入，到 处理 (Handler)，再到完成后的返回 结果 (Result) 对于系统外部而讲，都是不可见、且无法修改的。 而在这个过程中加入一个可挂载函数的点 (HookPoint)，允许外部插件挂载多个回调函数，形成一个调用链。达到对内部事件处理过程的扩展和修改。 系统中常用到的认证插件则是按照该逻辑进行实现的。以最简单的 emqx_auth_username 为例： 在只开启 emqx_auth_username 认证插件，且关闭匿名用户登录时。按照上图对事件的处理逻辑可知，此时认证模块的逻辑为： 收到用户认证请求 (Authenticate) 读取 是否允许匿名登录 参数，得到 拒绝登录 执行 认证事件的钩子，即回调到 emqx_auth_username 插件中，假设其认为此次登录合法，得到 允许登录 返回 认证成功，成功接入系统 即，如下图所示： EMQ X Core Hooks & Plugins ||| | | | Authenticate | Allow | emqx_auth_username | Authenticate =============> > - - - - - - No -> - - - - - - - - - - -Yes->==============> Success Request | Anonymous? | authenticate? | Result | | | +-----------------+--------------------------+ 因此，在 EMQ X 中，钩子 (Hooks) 这种机制极大地方便了系统的扩展。我们不需要修改 emqx 核心代码，仅需要在特定的位置埋下 挂载点 (HookPoint) ，便能允许外部插件扩展 EMQ X 的各种行为。 对于实现者来说仅需要关注： 挂载点 (HookPoint) 的位置：包括其作用、执行的时机、和如何挂载和取消挂载。 回调函数 的实现：包括回调函数的入参个数、作用、数据结构等，及返回值代表的含义。 了解回调函数在 链 上执行的机制：包括回调函数执行的顺序，及如何提前终止链的执行。 如果你是在开发扩展插件中使用钩子，你应该能 完全地明白这三点，且尽量不要在钩子内部使用阻塞函数，这会影响系统的吞吐。 回调链 单个 挂载点 上可能会存在多个插件都需要关心该事件并执行相应操作，所以每个 挂载点 上都可能会存在多个回调函数。 我们称这种由多个回调函数顺序执行所构成的链为 回调链 (Callback Functions Chain)。 回调链 目前按照 职责链(Chain-of-Responsibility) 的理念进行实现。为了满足钩子的功能和使用的灵活性，它必须具有以下属性： 回调链 上的回调函数必须按某种先后顺序执行。 回调链 一定会存在一个输入、和输出 (在通知类事件输出则是非必须的，例如 “某客户端已成功登陆”)。 回调链 具有传递性，意思是指，链会将输入给链的入参输入给第一个回调函数，第一个回调函数的返回值会传递给第二个回调函数，直到最后一个函数，最后一个函数的返回值则为整个链的返回值。 回调链 需要允许其上面的函数 提前终止链 和 忽略本次操作。 提前终止：本函数执行完成后，直接终止链的执行。忽略链上后续所有的回调函数。例如：某认证插件认为，此类客户端允许登录后便不需要再检查其他认证插件，所以需要提前终止。 忽略本次操作：不修改链上的处理结果，直接透传给下一个回调函数。例如：存在多个认证插件的情况下，某认证插件认为，此类客户端不属于其认证范围，所以我不需要修改认证结果，应当忽略本次操作，直接将前一个函数的返回值传递给链上的下一个函数。 由此，我们可以得到一个链的设计简图： 该图的含义是指： 链的入参为只读的 Args 与用于链上的函数修改的参数 Acc 链无论以何种方式终止执行，其返回值均为新的 Acc 图中链上一共注册了三个回调函数；分别为 Fun1 Fun2 Fun3 并按所表示的顺序执行 回调函数执行顺序，由一个优先级确定，同一优先级的按挂载的先后顺序执行 回调函数通过返回： ok：忽略本次操作，以只读的 Args 和上个函数返回的 Acc 继续链的执行 {ok, NewAcc}：执行了某些操作，修改了 Acc 内容，以只读的 Args 和新的 NewAcc 继续链的执行 回调函数也可通过返回： stop：表示终止链的传递，立即返回上个函数的结果 Acc {stop, NewAcc}：表示终止链的传递，立即返回本次修改的结果 NewAcc 以上为回调链的主要设计理念，它规范了钩子上的回调函数的执行逻辑。 接下来 挂载点，回调函数 两节中，对于钩子的所有操作都是依赖于 emqx 提供的 Erlang 代码级的 API。他们是整个钩子逻辑实现的基础。如需寻求： 钩子和 HTTP 服务器的应用，参见： WebHook 钩子与其他语言的应用，参见： Multipe-Language-Support 目前仅支持 Lua，参见：emqx_lua_hook 挂载点 EMQ X 以一个客户端在其生命周期内的关键活动为基础，预置了大量的 挂载点 (HookPoint)。目前系统中预置的挂载点有： 名称 说明 执行时机 client.connect 处理连接报文 服务端收到客户端的连接报文时 client.connack 下发连接应答 服务端准备下发连接应答报文时 client.connected 成功接入 客户端认证完成并成功接入系统后 client.disconnected 连接断开 客户端连接层在准备关闭时 client.authenticate 连接认证 执行完 client.connect 后 client.check_acl ACL 鉴权 执行 发布/订阅 操作前 client.subscribe 订阅主题 收到订阅报文后，执行 client.check_acl 鉴权前 client.unsubscribe 取消订阅 收到取消订阅报文后 session.created 会话创建 client.connected 执行完成，且创建新的会话后 session.subscribed 会话订阅主题 完成订阅操作后 session.unsubscribed 会话取消订阅 完成取消订阅操作后 session.resumed 会话恢复 client.connected 执行完成，且成功恢复旧的会话信息后 session.discarded 会话被移除 会话由于被移除而终止后 session.takeovered 会话被接管 会话由于被接管而终止后 session.terminated 会话终止 会话由于其他原因被终止后 message.publish 消息发布 服务端在发布（路由）消息前 message.delivered 消息投递 消息准备投递到客户端前 message.acked 消息回执 服务端在收到客户端发回的消息 ACK 后 message.dropped 消息丢弃 发布出的消息被丢弃后 会话被移除 是指：当客户端以 清除会话 的方式登入时，如果服务端中已存在该客户端的会话，那么旧的会话就会被丢弃。 会话被接管 是指：当客户端以 保留会话 的方式登入时，如果服务端中已存在该客户端的会话，那么旧的会话就会被新的连接所接管。 挂载与取消挂载 EMQ X 提供了 API 进行钩子的挂载与取消挂载的操作。 挂载： %% Name: 钩子的名称（挂载点）如：'client.authenticate' %% {Module, Function, Args}: 回调函数的模块、方法、和附加参数 %% Priority：优先级，整数; 不提供则默认为 0 emqx:hook(Name, {Module, Function, Args}, Priority). 挂载完成后，回调函数会按优先级从大到小执行，同一优先级按挂载的先后顺序执行。所有官方插件挂载的钩子优先级都为 0。 取消挂载： %% Name: 钩子的名称（挂载点）如：'client.authenticate' %% {Module, Function}: 回调函数的模块、方法 emqx:unhook(Name, {Module, Function}). 回调函数 回调函数的入参及返回值要求，见下表： (参数数据结构参见：emqx_types.erl) 名称 入参 返回 client.connect ConnInfo：客户端连接层参数Props：MQTT v5.0 连接报文的 Properties 属性 新的 Props client.connack ConnInfo：客户端连接层参数 Rc：返回码Props: MQTT v5.0 连接应答报文的 Properties 属性 新的 Props client.connected ClientInfo: 客户端信息参数ConnInfo： 客户端连接层参数 - client.disconnected ClientInfo：客户端信息参数ConnInfo：客户端连接层参数ReasonCode：错误码 - client.authenticate ClientInfo：客户端信息参数AuthResult：认证结果 新的 AuthResult client.check_acl ClientInfo：客户端信息参数Topic：发布/订阅的主题PubSub: 发布或订阅ACLResult：鉴权结果 新的 ACLResult client.subscribe ClientInfo：客户端信息参数Props：MQTT v5.0 订阅报文的 Properties 参数TopicFilters：需订阅的主题列表 新的 TopicFilters client.unsubscribe ClientInfo：客户端信息参数Props：MQTT v5.0 取消订阅报文的 Properties 参数TopicFilters：需取消订阅的主题列表 新的 TopicFilters session.created ClientInfo：客户端信息参数SessInfo：会话信息 - session.subscribed ClientInfo：客户端信息参数Topic：订阅的主题SubOpts：订阅操作的配置选项 - session.unsubscribed ClientInfo：客户端信息参数Topic：取消订阅的主题SubOpts：取消订阅操作的配置选项 - session.resumed ClientInfo：客户端信息参数SessInfo：会话信息 - session.discarded ClientInfo：客户端信息参数SessInfo：会话信息 - session.takeovered ClientInfo：客户端信息参数SessInfo：会话信息 session.terminated ClientInfo：客户端信息参数Reason：终止原因 SessInfo：会话信息 - message.publish Message：消息对象 新的 Message message.delivered ClientInfo：客户端信息参数Message：消息对象 新的 Message message.acked ClientInfo：客户端信息参数Message：消息对象 - message.dropped Message：消息对象By：被谁丢弃Reason：丢弃原因 - 具体对于这些钩子的应用，参见：emqx_plugin_template .emqxee { display: none; }"},"advanced/multiple-language-support.html":{"url":"advanced/multiple-language-support.html","title":"多语言支持","summary":null,"keywords":"","body":"多语言支持架构快速使用Python Java 其他Lua 多语言支持 从 4.1 开始，EMQ X 提供了专门的多语言支持插件：emqx_extension_hook 以优化多语言的支持效果。 该插件允许你使用其它编程语言来处理 EMQ X 中的钩子事件，例如： 认证某客户端的登录权限。 校验某客户端的 PUB/SUB 的操作权限。 处理 会话(Session) 和 消息(Message) 事件。 注：消息(Message) 类钩子，仅在企业版中支持。 架构 其整体的事件传递的架构如下： EMQ X +============================+ | Extension | +----------+ CONNECT | Hooks +----------------+ | | Client | - - - ->| Drivers | | +----------+ PUB/SUB | +----------------+ | | | | +===============|============+ | | Callbacks Third-party Runtimes | +=======================+ | | Python Script/ Java | emqx_extension_hook 作为 EMQ X 的插件： 它会接收 EMQ X 所有的钩子事件，并将其分发到对应的 驱动(Driver) 上。 提供对驱动的管理、各个指标的统计。 不同语言的支持，需要对应的驱动支持。 三方语言的运行时和 Erlang 的运行时相互独立，他们仅通过操作系统提供的管道进行通信。 理论上，对于其他任意的编程语言都能通过该插件进行扩展，仅需完成对应的驱动即可。 目前仅提供 Python 和 Java 的支持，并提供了对应的 SDK 以方便开发。 快速使用 Python Python 开发可参考：emqx-extension-python-sdk Java Java 开发可参考：emqx-extension-java-sdk 其他 在 EMQ X 4.1 之前。我们仅提供 Lua 的多语言支持。它的架构与上面提到的不同，它会将整个语言的运行时，包含在 Erlang VM 中： 多语言支持是作为一个插件出现，不同的语言环境，需要有不同的语言支持插件。 该支持插件内嵌了该语言运行时的所有环境。 为了保持兼容，该插件仍然保留在 EMQ X 的发行版本中。 Lua Lua 的支持由 emqx_lua_hook 实现。它包括： 一套 Lua 的运行时环境，由 luerl 实现。 一些控制命令，用于管理 Lua 的加载和卸载等。 示例 在 EMQ X 发行包中，用户自定义的 Lua 脚本文件应该放在 data/script/ 中。 以控制消息的发送内容为例，新增文件 data/script/test.lua： function on_message_publish(clientid, username, topic, payload, qos, retain) return topic, \"hello\", qos, retain end function register_hook() return \"on_message_publish\" end 该脚本表明： 实现了一个回调函数 on_message_publish，将所有发布消息的 payload 字段修改为 hello。 用 register_hook 告诉 emqx_lua_hook，需要注册的回调函数名称列表。 值得注意的是，这些回调函数的名称、参数、返回值的数据类型和个数都是固定，必须与提供的示例一致。 脚本编写完成后，需要手动将其加载至 emqx_lua_hook 插件中： 首先确保 emqx_lua_hook 插件已经启动： ./bin/emqx_ctl plugins load emqx_lua_hook 加载 test.lua 到 emqx_lua_hook 中： ./bin/emqx_ctl luahook load test.lua 执行成功，则表示脚本已成功加载。否则，请检查源文件的语法格式是否正确。 完成后，可以启动两个 MQTT 客户端，一个订阅主任意主题，另一个发布任意消息到刚刚订阅的主题上。可发现订阅端收到的消息内容都是 hello。证明 test.lua 脚本已经生效。 回调函数 支持的回调函数，及参数类型参考：emqx-lua-hook - README.md 示例参考：examples.lua 命令 加载指定 Lua 脚本： ## Script：脚本文件名称 luahook load 卸载指定 Lua 脚本： luahook unload 重新加载指定 Lua 脚本： luahook reload 加载指定 Lua 脚本，并设置其跟随 emqx_lua_hook 启动时一同启动： luahook enable 卸载指定 Lua 脚本，并取消跟随 emqx_lua_hook 一同启动： luahook disable .emqxee { display: none; }"},"advanced/metrics-and-stats.html":{"url":"advanced/metrics-and-stats.html","title":"指标监控","summary":null,"keywords":"","body":"指标监控Metrics & StatsMetrics字节报文消息 (PUBLISH 报文)事件Stats指标监控 EMQ X 为用户提供了指标监控功能，允许用户以及运维人员根据这些指标来了解当前服务状态。指标监控功能强制启用，但此功能拥有很高的性能，用户不必担心影响高吞吐场景下的系统性能。 EMQ X 为用户提供了多种查看指标与状态的手段。最直接的，用户可以在 EMQ X Dashboard 的 Overview 页面看到这些数据。 如果不方便访问 Dashboard，你还可以通过 HTTP API 和系统主题消息来获取这些数据，具体操作方法分别参见 HTTP API 与 $SYS 系统主题。 EMQ X 提供 emqx_statsd 插件，用于将系统的监控数据输出到第三方的监控系统中，使用示例参考 Prometheus 监控告警。 Metrics & Stats EMQ X 将指标分为了 Metrics 与 Stats 两种。Metrics 通常指那些只会单调递增的数据，例如发送字节数量、发送报文数量。EMQ X 目前提供的 Metrics 覆盖了字节、报文、消息和事件四个维度。Stats 则通常指那些成对出现的数据，包括当前值和历史最大值，例如当前订阅数量和订阅历史最大数量。 从 v4.1.0 版本开始，EMQ X 增加了针对指定主题的 Metrics 统计，包括消息收发数量和收发速率。我们提供了新建主题统计、取消主题统计和返回指定主题统计信息的 HTTP API，参见 HTTP API，你也可以直接在 Dashboard -> Analysis -> Topic Metrics 页面进行相关操作。 Metrics 字节 Name Data Type Description bytes.received Integer 接收字节数量 bytes.sent Integer 发送字节数量 报文 Name Data Type Description packets.received Integer 接收的报文数量 packets.sent Integer 发送的报文数量 packets.connect.received Integer 接收的 CONNECT 报文数量 packets.connack.auth_error Integer 发送的原因码为 0x86 和 0x87 的 CONNACK 报文数量 packets.connack.error Integer 发送的原因码不为 0x00 的 CONNACK 报文数量，此指标的值大于等于 packets.connack.auth_error 的值 packets.connack.sent Integer 发送的 CONNACK 报文数量 packets.publish.received Integer 接收的 PUBLISH 报文数量 packets.publish.sent Integer 发送的 PUBLISH 报文数量 packets.publish.inuse Integer 接收的报文标识符已被占用的 PUBLISH 报文数量 packets.publish.auth_error Integer 接收的未通过 ACL 检查的 PUBLISH 报文数量 packets.publish.error Integer 接收的无法被发布的 PUBLISH 报文数量 packets.publish.dropped Integer 超出接收限制而被丢弃的 PUBLISH 报文数量 packets.puback.received Integer 接收的 PUBACK 报文数量 packets.puback.sent Integer 发送的 PUBACK 报文数量 packets.puback.inuse Integer 接收的报文标识符已被占用的 PUBACK 报文数量 packets.puback.missed Integer 接收的未知报文标识符 PUBACK 报文数量 packets.pubrec.received Integer 接收的 PUBREC 报文数量 packets.pubrec.sent Integer 发送的 PUBREC 报文数量 packets.pubrec.inuse Integer 接收的报文标识符已被占用的 PUBREC 报文数量 packets.pubrec.missed Integer 接收的未知报文标识符 PUBREC 报文数量 packets.pubrel.received Integer 接收的 PUBREL 报文数量 packets.pubrel.sent Integer 发送的 PUBREL 报文数量 packets.pubrel.missed Integer 接收的未知报文标识符 PUBREL 报文数量 packets.pubcomp.received Integer 接收的 PUBCOMP 报文数量 packets.pubcomp.sent Integer 发送的 PUBCOMP 报文数量 packets.pubcomp.inuse Integer 接收的报文标识符已被占用的 PUBCOMP 报文数量 packets.pubcomp.missed Integer 发送的 PUBCOMP 报文数量 packets.subscribe.received Integer 接收的 SUBSCRIBE 报文数量 packets.subscribe.error Integer 接收的订阅失败的 SUBSCRIBE 报文数量 packets.subscribe.auth_error Integer 接收的未通过 ACL 检查的 SUBACK 报文数量 packets.suback.sent Integer 发送的 SUBACK 报文数量 packets.unsubscribe.received Integer 接收的 UNSUBSCRIBE 报文数量 packets.unsubscribe.error Integer 接收的取消订阅失败的 UNSUBSCRIBE 报文数量 packets.unsuback.sent Integer 发送的 UNSUBACK 报文数量 packets.pingreq.received Integer 接收的 PINGREQ 报文数量 packets.pingresp.sent Integer 发送的 PUBRESP 报文数量 packets.disconnect.received Integer 接收的 DISCONNECT 报文数量 packets.disconnect.sent Integer 发送的 DISCONNECT 报文数量 packets.auth.received Integer 接收的 AUTH 报文数量 packets.auth.sent Integer 发送的 AUTH 报文数量 消息 (PUBLISH 报文) Name Data Type Description delivery.dropped.too_large Integer 发送时由于长度超过限制而被丢弃的消息数量 delivery.dropped.queue_full Integer 发送时由于消息队列满而被丢弃的 QoS 不为 0 的消息数量 delivery.dropped.qos0_msg Integer 发送时由于消息队列满而被丢弃的 QoS 为 0 的消息数量 delivery.dropped.expired Integer 发送时由于消息过期而被丢弃的消息数量 delivery.dropped.no_local Integer 发送时由于 No Local 订阅选项而被丢弃的消息数量 delivery.dropped Integer 发送时丢弃的消息总数 messages.delayed Integer EMQ X 存储的延迟发布的消息数量 messages.delivered Integer EMQ X 内部转发到订阅进程的消息数量 messages.dropped Integer EMQ X 内部转发到订阅进程前丢弃的消息总数 messages.dropped.expired Integer 接收时由于消息过期而被丢弃的消息数量 messages.dropped.no_subscribers Integer 由于没有订阅者而被丢弃的消息数量 messages.forward Integer 向其他节点转发的消息数量 messages.publish Integer 除系统消息外发布的消息数量 messages.qos0.received Integer 接收来自客户端的 QoS 0 消息数量 messages.qos2.received Integer 接收来自客户端的 QoS 1 消息数量 messages.qos1.received Integer 接收来自客户端的 QoS 2 消息数量 messages.qos0.sent Integer 发送给客户端的 QoS 0 消息数量 messages.qos1.sent Integer 发送给客户端的 QoS 1 消息数量 messages.qos2.sent Integer 发送给客户端的 QoS 2 消息数量 messages.received Integer 接收来自客户端的消息数量，等于 messages.qos0.received，messages.qos1.received 与 messages.qos2.received 之和 messages.sent Integer 发送给客户端的消息数量，等于 messages.qos0.sent，messages.qos1.sent 与 messages.qos2.sent 之和 messages.retained Integer EMQ X 存储的保留消息数量 messages.acked Integer 已经应答的消息数量 事件 Name Data Type Description actions.failure Integer 规则引擎 action 执行成功次数 actions.success Integer 规则引擎 action 执行失败次数 rules.matched Integer 规则的匹配次数 client.auth.anonymous Integer 客户端最终匿名形式登录的次数 client.connect Integer client.connect 钩子触发次数 client.authenticate Integer client.authenticate 钩子触发次数 client.connack Integer client.connack 钩子触发次数 client.connected Integer client.connected 钩子触发次数 client.disconnected Integer client.disconnected 钩子触发次数 client.check_acl Integer client.check_acl 钩子触发次数 client.subscribe Integer client.subscribe 钩子触发次数 client.unsubscribe Integer client.unsubscribe 钩子触发次数 session.created Integer session.created 钩子触发次数 session.discarded Integer session.discarded 钩子触发次数 session.resumed Integer session.resumed 钩子触发次数 session.takeovered Integer session.takeovered 钩子触发次数 session.terminated Integer session.terminated 钩子触发次数 Stats Name Data Type Description connections.count Integer 当前连接数量 connections.max Integer 连接数量的历史最大值 channels.count Integer 即 sessions.count channels.max Integer 即 session.max sessions.count Integer 当前会话数量 sessions.max Integer 会话数量的历史最大值 topics.count Integer 当前主题数量 topics.max Integer 主题数量的历史最大值 suboptions.count Integer 即 subscriptions.count suboptions.max Integer 即 subscriptions.max subscribers.count Integer 当前订阅者数量 subscribers.max Integer 订阅者数量的历史最大值 subscriptions.count Integer 当前订阅数量，包含共享订阅 subscriptions.max Integer 订阅数量的历史最大值 subscriptions.shared.count Integer 当前共享订阅数量 subscriptions.shared.max Integer 共享订阅数量的历史最大值 routes.count Integer 当前路由数量 routes.max Integer 路由数量的历史最大值 retained.count Integer 当前保留消息数量 retained.max Integer 保留消息的历史最大值 .emqxee { display: none; }"},"advanced/rate-limit.html":{"url":"advanced/rate-limit.html","title":"速率限制","summary":null,"keywords":"","body":"速率限制 速率限制原理 令牌桶算法在 EMQ X 中的应用速率限制 EMQ X 提供对接入速度、消息速度的限制：当客户端连接请求速度超过指定限制的时候，暂停新连接的建立；当消息接收速度超过指定限制的时候，暂停接收消息。 速率限制是一种 backpressure 方案，从入口处避免了系统过载，保证了系统的稳定和可预测的吞吐。速率限制可在 etc/emqx.conf 中配置： 配置项 类型 默认值 描述 listener.tcp.external.max_conn_rate Number 1000 本节点上允许的最大连接速率 (conn/s) zone.external.publish_limit Number,Duration 无限制 单连接上允许的最大发布速率 (msg/s) listener.tcp.external.rate_limit Size,Duration 无限制 单连接上允许的最大报文速率 (bytes/s) max_conn_rate 是单个 emqx 节点上连接建立的速度限制。1000 代表秒最多允许 1000 个客户端接入。 publish_limit 是单个连接上接收 PUBLISH 报文的速率限制。100,10s 代表每个连接上允许收到的最大 PUBLISH 消息速率是每 10 秒 100 个。 rate_limit 是单个连接上接收 TCP数据包的速率限制。100KB,10s 代表每个连接上允许收到的最大 TCP 报文速率是每 10 秒 100KB。 publish_limit 和 rate_limit 提供的都是针对单个连接的限制，EMQ X 目前没有提供全局的消息速率限制。 速率限制原理 EMQ X 使⽤令牌桶 (Token Bucket) 算法来对所有的 Rate Limit 来做控制。 令牌桶算法 的逻辑如下图: 存在一个可容纳令牌(Token) 的最大值 burst 的桶(Bucket)，最大值 burst 简记为 b 。 存在一个 rate 为每秒向桶添加令牌的速率，简记为 r 。当桶满时则不不再向桶中加⼊入令牌。 每当有 1 个(或 N 个)请求抵达时，则从桶中拿出 1 个 (或 N 个) 令牌。如果令牌不不够则阻塞，等待令牌的⽣生成。 由此可知该算法中: 长期来看，所限制的请求速率的平均值等于 rate 的值。 记实际请求达到速度为 M，且 M > r，那么，实际运⾏中能达到的最大(峰值)速率为 M = b + r，证明： 容易想到，最大速率 M 为：能在1个单位时间内消耗完满状态令牌桶的速度。而桶中令牌的消耗速度为 M - r，故可知：b / (M - r) = 1，得 M = b + r 令牌桶算法在 EMQ X 中的应用 当使用如下配置做报文速率限制的时候： listener.tcp.external.rate_limit = 100KB,10s EMQ X 将使用两个值初始化每个连接的 rate-limit 处理器： rate = 100 KB / 10s = 10240 B/s burst = 100 KB = 102400 B 根据 消息速率限制原理 中的算法，可知： 长期来看允许的平均速率限制为 10240 B/s 允许的峰值速率为 102400 + 10240 = 112640 B/s 为提高系统吞吐，EMQ X 的接入模块不会一条一条的从 socket 读取报文，而是每次从 socket 读取 N 条报文。rate-limit 检查的时机就是在收到这 N 条报文之后，准备继续收取下个 N 条报文之前。故实际的限制速率不会如算法一样精准。EMQ X 只提供了一个大概的速率限制。N 的值可以在 etc/emqx.conf 中配置： 配置项 类型 默认值 描述 listener.tcp.external.active_n Number 100 emqx 每次从 TCP 栈读取多少条消息 .emqxee { display: none; }"},"advanced/inflight-window-and-message-queue.html":{"url":"advanced/inflight-window-and-message-queue.html","title":"飞行窗口与消息队列","summary":null,"keywords":"","body":"飞行窗口和消息队列简介飞行队列与 Receive Maximum配置项飞行窗口和消息队列 简介 为了提高消息吞吐效率和减少网络波动带来的影响，EMQ X 允许多个未确认的 QoS 1 和 QoS 2 报文同时存在于网路链路上。这些已发送但未确认的报文将被存放在 Inflight Window 中直至完成确认。 当网络链路中同时存在的报文超出限制，即 Inflight Window 到达长度限制（见 max_inflight）时，EMQ X 将不再发送后续的报文，而是将这些报文存储在 Message Queue 中。一旦 Inflight Window 中有报文完成确认，Message Queue 中的报文就会以先入先出的顺序被发送，同时存储到 Inflight Window 中。 当客户端离线时，Message Queue 还会被用来存储 QoS 0 消息，这些消息将在客户端下次上线时被发送。这功能默认开启，当然你也可以手动关闭，见 mqueue_store_qos0。 需要注意的是，如果 Message Queue 也到达了长度限制，后续的报文将依然缓存到 Message Queue，但相应的 Message Queue 中最先缓存的消息将被丢弃。如果队列中存在 QoS 0 消息，那么将优先丢弃 QoS 0 消息。因此，根据你的实际情况配置一个合适的 Message Queue 长度限制（见 max_mqueue_len）是非常重要的。 飞行队列与 Receive Maximum MQTT v5.0 协议为 CONNECT 报文新增了一个 Receive Maximum 的属性，官方对它的解释是： 客户端使用此值限制客户端愿意同时处理的 QoS 为 1 和 QoS 为 2 的发布消息最大数量。没有机制可以限制服务端试图发送的 QoS 为 0 的发布消息 。 也就是说，服务端可以在等待确认时使用不同的报文标识符向客户端发送后续的 PUBLISH 报文，直到未被确认的报文数量到达 Receive Maximum 限制。 不难看出，Receive Maximum 其实与 EMQ X 中的 Inflight Window 机制如出一辙，只是在 MQTT v5.0 协议发布前，EMQ X 就已经对接入的 MQTT 客户端提供了这一功能。现在，使用 MQTT v5.0 协议的客户端将按照 Receive Maximum 的规范来设置 Inflight Window 的最大长度，而更低版本 MQTT 协议的客户端则依然按照配置来设置。 配置项 配置项 类型 可取值 默认值 说明 max_inflight integer >= 0 32 (external), 128 (internal) Inflight Window 长度限制，0 即无限制 max_mqueue_len integer >= 0 1000 (external),10000 (internal) Message Queue 长度限制，0 即无限制 mqueue_store_qos0 enum true, false true 客户端离线时 EMQ X 是否存储 QoS 0 消息至 Message Queue .emqxee { display: none; }"},"advanced/retransmission.html":{"url":"advanced/retransmission.html","title":"消息重传","summary":null,"keywords":"","body":"消息重传基础配置协议规范与设计重传的对象飞行窗口与最大接收值消息顺序相关配置消息重传 消息重传 (Message Retransmission) 是属于 MQTT 协议标准规范的一部分。 协议中规定了作为通信的双方 服务端 和 客户端 对于自己发送到对端的 PUBLISH 消息都应满足其 服务质量 (Quality of Service levels) 的要求。如： QoS 1：表示 消息至少送达一次 (At least once delivery)；即发送端会一直重发该消息，除非收到了对端对该消息的确认。意思是在 MQTT 协议的上层（即业务的应用层）相同的 QoS 1 消息可能会收到多次。 QoS 2：表示 消息只送达一次 (Exactly once delivery)；即该消息在上层仅会接收到一次。 虽然，QoS 1 和 QoS 2 的 PUBLISH 报文在 MQTT 协议栈这一层都会发生重传，但请你谨记的是： QoS 1 消息发生重传后，在 MQTT 协议栈上层，也会收到这些重发的 PUBLISH 消息。 QoS 2 消息无论如何重传，最终在 MQTT 协议栈上层，都只会收到一条 PUBLISH 消息 基础配置 有两种场景会导致消息重发： PUBLISH 报文发送给对端后，规定时间内未收到应答。则重发这个报文。 在保持会话的情况下，客户端重连后；EMQ X 会自动重发 未应答的消息，以确保 QoS 流程的正确。 在 etc/emqx.conf 中可配置： 配置项 类型 可取值 默认值 说明 retry_interval duration - 30s 等待一个超时间隔，如果没收到应答则重传消息 一般来说，你只需要关心以上内容就足够了。 如需了解更多 EMQ X 在处理 MQTT 协议的重传的细节见以下内容。 协议规范与设计 重传的对象 首先，在了解 EMQ X 对于重传机制的设计前，我们需要先确保你已经了解协议中 QoS 1 和 QoS 2 的传输过程，否则请参见 MQTTv3.1.1 - QoS 1: At least once delivery 和 MQTTv3.1.1 - QoS 2: Exactly once delivery。 此处，仅作一个简单的回顾，用来说明不同 QoS 下重传的对象有哪些。 QoS 1 QoS 1 要求消息至少送达一次；所以消息在 MQTT 协议层中，可能会不断的重传，直到发送端收到了该消息的确认报文。 其流程示意图如下： PUBLISH #1 Sender ---------------> Receiver (*) PUBACK #2 Sender 涉及到 2 个报文；共 2 次发送动作，发送端和接收端各 1 次；这 2 个报文都持有相同的 PacketId。 行尾标记为 * 号的，表示发送方在等待确认报文超时后，可能会主动发起重传。 可见 QoS 1 消息只需要对 PUBLISH 报文进行重发 QoS 2 QoS 2 要求消息只送达一次；所以在实现它时，需要更复杂的流程。其流程示意图如下： PUBLISH #1 Sender ---------------> Receiver (*) PUBREC #2 Sender Receiver (*) PUBCOM #4 Sender 涉及到 4 个报文；共 4 次发送动作，发送端和接收端各 2 次；这 4 个报文都持有相同的 PacketId。 行尾标记为 * 号的，表示发送方在等待确认报文超时后，可能会主动发起重传。 可见 QoS 2 消息需要对 PUBLISH 和 PUBREL 报文进行重发 综上： 重传动作 都是由于 发送端 报文发送后，在 规定时间 内未收到其期待的返回而触发的。 重传对象 仅包含以下三种： QoS 1 的 PUBLISH 报文 QoS 2 的 PUBLISH 报文 QoS 2 的 PUBREL 报文 当 EMQ X 作为 PUBLISH 消息的接收端时，它不需要重发操作 飞行窗口与最大接收值 其概念的定义和解释参见 飞行窗口与消息队列 引入这两个概念的作用是为了理解： EMQ X 作为发送端时，再次重发的消息，必然是已存储在飞行窗口中的消息 EMQ X 作为接收端时，发送端重发的消息时： 如 QoS 1，EMQ X 则直接回复 PUBACK 进行应答； 如 QoS 2，EMQ X 则会释放，存储在 最大接收消息 队列中的 PUBLISH 或者 PUBREL 报文。 消息顺序 当然，以上的概念仅需要了解即可，你最需要关心的是，消息在被重复发送后，消息顺序出现的变化，尤其是 QoS 1 类的消息。例如： 假设，当前飞行窗口设置为 2 时，EMQ X 计划向客户端的某主题投递 4 条 QoS 1 的消息。并假设客户端程序、或网络在中间出现过问题，那么整个发送流程会变成： #1 [4,3,2,1 || ] -----> [] #2 [4,3 || 2, 1] -----> [1, 2] #3 [4 || 3, 2] -----> [1, 2, 3] #4 [4 || 3, 2] -----> [1, 2, 3, 2, 3] #5 [ || 4] -----> [1, 2, 3, 2, 3, 4] #6 [ || ] -----> [1, 2, 3, 2, 3, 4] 流程共 6 个步骤；左边表示 EMQ X 的 消息队列 和 飞行窗口，以 || 分割；右侧表示客户端收到的消息顺序，其中每步表示： Broker 将 4 条消息放入消息队列中。 Broker 依次发送 1 2，并将其放入 飞行窗口 中；客户端仅应答消息 1；且此时由于客户端发送流出现了问题，无法发送后续应答报文。 Broker 收到消息 1 的应答；从飞行窗口移除消息 1；并将 3 发送出去；继续等待 2 3 的应答； Broker 等待应答超时，重发了报文 2 3；客户端收到重发的报文 2 3 并正常应答。 Broker 从飞行窗口移除了消息 2 3，并发送报文 4；客户端收到了报文 4 并回复应答。 至此，所有报文处理完成。客户端收到的报文顺序为 [1, 2, 3, 2, 3, 4]，并也依次上报给 MQTT 协议栈的上层。 虽然，存在重复的报文消息。但这是完全符合协议的规范的，每个报文第一次出现的位置都是有序的，并且重复收到的报文 2 3 的报文中，会携带一个标识位，表明其为重发报文。 MQTT 协议和 EMQ X 将这个主题认为是 有序的主题 (Ordered Topic) 参见: MQTTv3.1.1 - Message ordering。 它确保 相同的主题和 QoS 下，消息是按顺序投递和应答的。 此外，如果用户期望所有主题下的 QoS 1 与 QoS 2 消息都严格有序，那么需要设置飞行窗口的最大长度为 1，但代价是会降低该客户端的吞吐。 相关配置 此节列举了上述机制中，用到的所有配置。它们都包含在 etc/emqx.conf 中： 配置项 类型 可取值 默认值 说明 mqueue_store_qos0 bool true, false true 是否将 QoS 0 消息存入消息队列中 max_mqueue_len integer >= 0 1000 消息队列长度 max_inflight integer >= 0 0 飞行窗口大小；默认 0 即无限制 max_awaiting_rel integer >= 0 0 最大接收；默认 0 即无限制 await_rel_timeout durtaion > 0 300s 最大接收 中消息等待释放的最大超时时间；超过则直接丢弃 .emqxee { display: none; }"},"advanced/plugins.html":{"url":"advanced/plugins.html","title":"插件","summary":null,"keywords":"","body":"插件插件列表启停插件插件开发创建插件项目创建 认证/访问控制 模块挂载钩子注册 CLI 命令插件配置文件编译和发布插件插件 EMQ X 发行包中，包含了大量的官方插件，提供了一些基础的、或各类扩展的功能。 它们依赖于 emqx 的代码 API 或者 钩子 进行实现其特殊的功能。 然后通过打包编译工具 emqx-rel 将其与 emqx 核心项目一起编译并打包至一个可运行的软件包中。 插件列表 目前 EMQ X 发行包提供的插件包括： 插件 配置文件 说明 emqx_dashboard etc/plugins/emqx_dashbord.conf Web 控制台插件 (默认加载) emqx_management etc/plugins/emqx_management.conf HTTP API 与 CLI 管理插件 emqx_auth_clientid etc/plugins/emqx_auth_clientid.conf ClientId 认证插件 emqx_auth_username etc/plugins/emqx_auth_username.conf 用户名、密码认证插件 emqx_auth_jwt etc/plugins/emqx_auth_jwt.conf JWT 认证 / 访问控制 emqx_auth_ldap etc/plugins/emqx_auth_ldap.conf LDAP 认证 / 访问控制 emqx_auth_http etc/plugins/emqx_auth_http.conf HTTP 认证 / 访问控制 emqx_auth_mongo etc/plugins/emqx_auth_mongo.conf MongoDB 认证 / 访问控制 emqx_auth_mysql etc/plugins/emqx_auth_mysql.conf MySQL 认证 / 访问控制 emqx_auth_pgsql etc/plugins/emqx_auth_pgsql.conf PostgreSQL 认证 / 访问控制 emqx_auth_redis etc/plugins/emqx_auth_redis.conf Redis 认证 / 访问控制 emqx_psk_file etc/plugins/emqx_psk_file.conf PSK 支持 emqx_web_hook etc/plugins/emqx_web_hook.conf Web Hook 插件 emqx_lua_hook etc/plugins/emqx_lua_hook.conf Lua Hook 插件 emqx_retainer etc/plugins/emqx_retainer.conf Retain 消息存储模块 emqx_rule_engine etc/plugins/emqx_rule_engine.conf 规则引擎 emqx_bridge_mqtt etc/plugins/emqx_bridge_mqtt.conf MQTT 消息桥接插件 emqx_delayed_publish etc/plugins/emqx_delayed_publish.conf 客户端延时发布消息支持 emqx_coap etc/plugins/emqx_coap.conf CoAP 协议支持 emqx_lwm2m etc/plugins/emqx_lwm2m.conf LwM2M 协议支持 emqx_sn etc/plugins/emqx_sn.conf MQTT-SN 协议支持 emqx_stomp etc/plugins/emqx_stomp.conf Stomp 协议支持 emqx_recon etc/plugins/emqx_recon.conf Recon 性能调试 emqx_reloader etc/plugins/emqx_reloader.conf 代码热加载插件 emqx_plugin_template etc/plugins/emqx_plugin_template.conf 插件开发模版 启停插件 目前启动插件有以下四种方式： 默认加载 命令行启停插件 使用 Dashboard 启停插件 调用管理 API 启停插件 开启默认加载 如需在 EMQ X 启动时就默认启动某插件，则直接在 data/loaded_plugins 添加需要启动的插件名称。 例如，目前 EMQ X 自动加载的插件有： {emqx_management, true}. {emqx_recon, true}. {emqx_retainer, true}. {emqx_dashboard, true}. {emqx_rule_engine, true}. {emqx_bridge_mqtt, false}. 命令行启停插件 在 EMQ X 运行过程中，可通过 CLI - Load/Unload Plugin 的方式查看、和启停某插件。 使用 Dashboard 启停插件 若开启了 Dashbord 的插件，可以直接通过访问 http://localhost:18083/plugins 中的插件管理页面启停插件。 使用管理 API 启停插件 在 EMQ X 运行过程中，可通过 管理监控 API - Load Plugin 的方式查看、和启停某插件。 插件开发 创建插件项目 参考 emqx_plugin_template 插件模版创建新的插件项目。 备注：在 \\_app.erl 文件中必须加上标签 -emqx_plugin(?MODULE). 以表明这是一个 EMQ X 的插件。 创建 认证/访问控制 模块 接入认证示例代码 - emqx_auth_demo.erl： -module(emqx_auth_demo). -export([ init/1 , check/2 , description/0 ]). init(Opts) -> {ok, Opts}. check(_ClientInfo = #{clientid := ClientId, username := Username, password := Password}, _State) -> io:format(\"Auth Demo: clientId=~p, username=~p, password=~p~n\", [ClientId, Username, Password]), ok. description() -> \"Auth Demo Module\". 访问控制示例代码 - emqx_acl_demo.erl： -module(emqx_acl_demo). -include_lib(\"emqx/include/emqx.hrl\"). %% ACL callbacks -export([ init/1 , check_acl/5 , reload_acl/1 , description/0 ]). init(Opts) -> {ok, Opts}. check_acl({ClientInfo, PubSub, _NoMatchAction, Topic}, _State) -> io:format(\"ACL Demo: ~p ~p ~p~n\", [ClientInfo, PubSub, Topic]), allow. reload_acl(_State) -> ok. description() -> \"ACL Demo Module\". 挂载认证、访问控制钩子示例代码 - emqx_plugin_template_app.erl： ok = emqx:hook('client.authenticate', fun emqx_auth_demo:check/2, []), ok = emqx:hook('client.check_acl', fun emqx_acl_demo:check_acl/5, []). 挂载钩子 在扩展插件中，可通过挂载 钩子 来处理客户端上下线、主题订阅、消息收发等事件。 钩子挂载示例代码 - emqx_plugin_template.erl： load(Env) -> emqx:hook('client.connect', {?MODULE, on_client_connect, [Env]}), emqx:hook('client.connack', {?MODULE, on_client_connack, [Env]}), emqx:hook('client.connected', {?MODULE, on_client_connected, [Env]}), emqx:hook('client.disconnected', {?MODULE, on_client_disconnected, [Env]}), emqx:hook('client.authenticate', {?MODULE, on_client_authenticate, [Env]}), emqx:hook('client.check_acl', {?MODULE, on_client_check_acl, [Env]}), emqx:hook('client.subscribe', {?MODULE, on_client_subscribe, [Env]}), emqx:hook('client.unsubscribe', {?MODULE, on_client_unsubscribe, [Env]}), emqx:hook('session.created', {?MODULE, on_session_created, [Env]}), emqx:hook('session.subscribed', {?MODULE, on_session_subscribed, [Env]}), emqx:hook('session.unsubscribed',{?MODULE, on_session_unsubscribed, [Env]}), emqx:hook('session.resumed', {?MODULE, on_session_resumed, [Env]}), emqx:hook('session.discarded', {?MODULE, on_session_discarded, [Env]}), emqx:hook('session.takeovered', {?MODULE, on_session_takeovered, [Env]}), emqx:hook('session.terminated', {?MODULE, on_session_terminated, [Env]}), emqx:hook('message.publish', {?MODULE, on_message_publish, [Env]}), emqx:hook('message.delivered', {?MODULE, on_message_delivered, [Env]}), emqx:hook('message.acked', {?MODULE, on_message_acked, [Env]}), emqx:hook('message.dropped', {?MODULE, on_message_dropped, [Env]}). 注册 CLI 命令 处理命令行命令示例代码 - emqx_cli_demo.erl： -module(emqx_cli_demo). -export([cmd/1]). cmd([\"arg1\", \"arg2\"]) -> emqx_cli:print (\"ok\"); cmd(_) -> emqx_cli:usage ([{\"cmd arg1 arg2\", \"cmd demo\"}]). 注册命令行示例代码 - emqx_plugin_template_app.erl： ok = emqx_ctl:register_command(cmd, {emqx_cli_demo, cmd}, []), 插件加载后，使用./bin/emqx_ctl 验证新增的命令行： ./bin/emqx_ctl cmd arg1 arg2 插件配置文件 插件自带配置文件放置在 etc/${plugin_name}.conf|config。 EMQ X 支持两种插件配置格式： Erlang 原生配置文件格式 - ${plugin_name}.config： [ {plugin_name, [ {key, value} ]} ]. sysctl 的 k = v 通用格式 - ${plugin_name}.conf： plugin_name.key = value 注：k = v 格式配置需要插件开发者创建 priv/plugin_name.schema 映射文件。 编译和发布插件 clone emqx-rel 项目： git clone https://github.com/emqx/emqx-rel.git rebar.config 添加依赖： {deps, [ {plugin_name, {git, \"url_of_plugin\", {tag, \"tag_of_plugin\"}}} , .... .... ] } rebar.config 中 relx 段落添加： {relx, [... , ... , {release, {emqx, git_describe}, [ {plugin_name, load}, ] } ] } .emqxee { display: none; }"},"advanced/auth.html":{"url":"advanced/auth.html","title":"认证简介","summary":null,"keywords":"","body":"认证 认证方式认证结果匿名认证密码加盐规则与哈希方法如何生成认证信息EMQ X 身份认证流程认证链TLS 认证 PSK 认证 认证 身份认证是大多数应用的重要组成部分，MQTT 协议支持用户名密码认证，启用身份认证能有效阻止非法客户端的连接。 EMQ X 中的认证指的是当一个客户端连接到 EMQ X 的时候，通过服务器端的配置来控制客户端连接服务器的权限。 EMQ X 的认证支持包括两个层面： MQTT 协议本身在 CONNECT 报文中指定用户名和密码，EMQ X 以插件形式支持基于 Username、ClientID、HTTP、JWT、LDAP 及各类数据库如 MongoDB、MySQL、PostgreSQL、Redis 等多种形式的认证。 在传输层上，TLS 可以保证使用客户端证书的客户端到服务器的身份验证，并确保服务器向客户端验证服务器证书。也支持基于 PSK 的 TLS/DTLS 认证。 本章节介绍了 EMQ X 支持的认证方式以及对应插件的配置方法。 认证方式 EMQ X 支持使用内置数据源（文件、内置数据库）、JWT、外部主流数据库和自定义 HTTP API 作为身份认证数据源。 连接数据源、进行认证逻辑通过插件实现的，每个插件对应一种认证方式，使用前需要启用相应的插件。 客户端连接时插件通过检查其 username/clientid 和 password 是否与指定数据源的信息一致来实现对客户端的身份认证。 EMQ X 支持的认证方式： 内置数据源 Username 认证 Cliend ID 认证 Mnesia 认证 使用配置文件与 EMQ X 内置数据库提供认证数据源，通过 HTTP API 进行管理，足够简单轻量。 外部数据库 LDAP 认证 MySQL 认证 PostgreSQL 认证 Redis 认证 MongoDB 认证 外部数据库可以存储大量数据，同时方便与外部设备管理系统集成。 其他 HTTP 认证 JWT 认证 JWT 认证可以批量签发认证信息，HTTP 认证能够实现复杂的认证鉴权逻辑。 更改插件配置后需要重启插件才能生效，部分认证鉴权插件包含 ACL 功能。 认证结果 任何一种认证方式最终都会返回一个结果： 认证成功：经过比对客户端认证成功 认证失败：经过比对客户端认证失败，数据源中密码与当前密码不一致 忽略认证（ignore）：当前认证方式中未查找到认证数据，无法显式判断结果是成功还是失败，交由认证链下一认证方式或匿名认证来判断 匿名认证 EMQ X 默认配置中启用了匿名认证，任何客户端都能接入 EMQ X。没有启用认证插件或认证插件没有显式允许/拒绝（ignore）连接请求时，EMQ X 将根据匿名认证启用情况决定是否允许客户端连接。 配置匿名认证开关： # etc/emqx.conf ## Value: true | false allow_anonymous = true 生产环境中请禁用匿名认证。 密码加盐规则与哈希方法 EMQ X 多数认证插件中可以启用哈希方法，数据源中仅保存密码密文，保证数据安全。 启用哈希方法时，用户可以为每个客户端都指定一个 salt（盐）并配置加盐规则，数据库中存储的密码是按照加盐规则与哈希方法处理后的密文。 以 MySQL 认证为例： 加盐规则与哈希方法配置： # etc/plugins/emqx_auth_mysql.conf ## 不加盐，仅做哈希处理 auth.mysql.password_hash = sha256 ## salt 前缀：使用 sha256 加密 salt + 密码 拼接的字符串 auth.mysql.password_hash = salt,sha256 ## salt 后缀：使用 sha256 加密 密码 + salt 拼接的字符串 auth.mysql.password_hash = sha256,salt ## pbkdf2 with macfun iterations dklen ## macfun: md4, md5, ripemd160, sha, sha224, sha256, sha384, sha512 ## auth.mysql.password_hash = pbkdf2,sha256,1000,20 如何生成认证信息 为每个客户端分用户名、Client ID、密码以及 salt（盐）等信息 使用与 MySQL 认证相同加盐规则与哈希方法处理客户端信息得到密文 将客户端信息写入数据库，客户端的密码应当为密文信息 EMQ X 身份认证流程 根据配置的认证 SQL 结合客户端传入的信息，查询出密码（密文）和 salt（盐）等认证数据，没有查询结果时，认证将终止并返回 ignore 结果 根据配置的加盐规则与哈希方法计算得到密文，没有启用哈希方法则跳过此步 将数据库中存储的密文与当前客户端计算的到的密文进行比对，比对成功则认证通过，否则认证失败 PostgreSQL 认证功能逻辑图： 写入数据的加盐规则、哈希方法与对应插件的配置一致时认证才能正常进行。更改哈希方法会造成现有认证数据失效。 认证链 当同时启用多个认证方式时，EMQ X 将按照插件开启先后顺序进行链式认证： 一旦认证成功，终止认证链并允许客户端接入 一旦认证失败，终止认证链并禁止客户端接入 直到最后一个认证方式仍未通过，根据匿名认证配置判定 匿名认证开启时，允许客户端接入 匿名认证关闭时，禁止客户端接入 同时只启用一个认证插件可以提高客户端身份认证效率。 TLS 认证 MQTT TLS 的默认端口是 8883： listener.ssl.external = 8883 配置证书和 CA： listener.ssl.external.keyfile = etc/certs/key.pem listener.ssl.external.certfile = etc/certs/cert.pem listener.ssl.external.cacertfile = etc/certs/cacert.pem 注意，默认的 etc/certs 目录下面的 key.pem、cert.pem 和 cacert.pem 是 EMQ X 生成的自签名证书，所以在使用支持 TLS 的客户端测试的时候，需要将上面的 CA 证书 etc/certs/cacert.pem 配置到客户端。 服务端支持的 cipher 列表需要显式指定，默认的列表与 Mozilla 的服务端 cipher 列表一致： listener.ssl.external.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA PSK 认证 如果希望使用 PSK 认证，需要将 TLS 认证 中的 listener.ssl.external.ciphers 注释掉，然后配置 listener.ssl.external.psk_ciphers： #listener.ssl.external.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,... listener.ssl.external.psk_ciphers = PSK-AES128-CBC-SHA,PSK-AES256-CBC-SHA,PSK-3DES-EDE-CBC-SHA,PSK-RC4-SHA 然后启用 emqx_psk_file 插件： $ emqx_ctl plugins load emqx_psk_file PSK 的配置文件为 etc/psk.txt，使用冒号: 分隔 PSK ID 和 PSK： client1:1234 client2:abcd .emqxee { display: none; }"},"advanced/auth-username.html":{"url":"advanced/auth-username.html","title":"Username 认证（即将废弃）","summary":null,"keywords":"","body":"Username 认证哈希方法预设认证数据使用 HTTP API 管理认证数据Username 认证 Username 认证使用配置文件预设客户端用户名与密码，支持通过 HTTP API 管理认证数据。 Username 认证不依赖外部数据源，使用上足够简单轻量。 插件： emqx_auth_username 哈希方法 Username 认证默认使用 sha256 进行密码哈希加密，可在 etc/plugins/emqx_auth_username.conf 中更改： # etc/plugins/emqx_auth_username.conf ## Value: plain | md5 | sha | sha256 auth.user.password_hash = sha256 配置哈希方法后，新增的预设认证数据与通过 HTTP API 添加的认证数据将以哈希密文存储在 EMQ X 内置数据库中。 预设认证数据 可以通过配置文件预设认证数据，编辑配置文件：etc/plugins/emqx_auth_username.conf # etc/plugins/emqx_auth_username.conf ## 第一组认证数据 auth.user.1.username = admin auth.user.1.password = public ## 第二组认证数据 auth.user.2.username = wivwiv auth.user.2.password = public 插件启动时将读取预设认证数据并加载到 EMQ X 内置数据库中，节点上的认证数据会在此阶段同步至集群中。 预设认证数据在配置文件中使用了明文密码，出于安全性与可维护性考虑应当避免使用该功能。 预设认证数据无法通过 API 修改、删除，请慎用。 使用 HTTP API 管理认证数据 添加认证数据 API 定义： # Request POST api/v4/auth_username { \"username\": \"emqx_u\", \"password\": \"emqx_p\" } # Response { \"code\": 0 } 使用 POST 请求添加 username 为 emqx_u password 为 emqx_p 的认证信息，返回信息中 code = 0 即为成功。 查看已经添加的认证数据 API 定义： # Request GET api/v4/auth_username # Response { \"code\": 0, \"data\": [\"emqx_u\"] } 更改指定用户名的密码 指定用户名，传递新密码进行更改，再次连接时需要使用新密码进行连接： API 定义： # Request PUT api/v4/auth_username/${username} { \"password\": \"emqx_new_p\" } # Response { \"code\": 0 } 查看指定用户名信息 指定用户名，查看相关用户名、密码信息，注意此处返回的密码是使用配置文件指定哈希方式加密后的密码： API 定义： # Request GET api/v4/auth_username/${username} # Response { \"code\": 0, \"data\": { \"username\": \"emqx_u\", \"password\": \"091dc8753347e7dc5d348508fe6323735eecdb84fa800548870158117af8a0c0\" } } 删除认证数据 删除指定认证数据： API 定义： # Request DELETE api/v4/auth_username/${username} # Response { \"code\": 0 } .emqxee { display: none; }"},"advanced/auth-clientid.html":{"url":"advanced/auth-clientid.html","title":"Cliend ID 认证（即将废弃）","summary":null,"keywords":"","body":"Client ID 认证哈希方法预设认证数据使用 HTTP API 管理认证数据Client ID 认证 Client ID 认证使用配置文件预设客户端Client ID 与密码，支持通过 HTTP API 管理认证数据。 Client ID 认证不依赖外部数据源，使用上足够简单轻量。 插件： emqx_auth_clientid 哈希方法 Client ID 认证默认使用 sha256 进行密码哈希加密，可在 etc/plugins/emqx_auth_clientid.conf 中更改： # etc/plugins/emqx_auth_clientid.conf ## Value: plain | md5 | sha | sha256 auth.client.password_hash = sha256 配置哈希方法后，新增的预设认证数据与通过 HTTP API 添加的认证数据将以哈希密文存储在 EMQ X 内置数据库中。 预设认证数据 可以通过配置文件预设认证数据，编辑配置文件：etc/plugins/emqx_auth_clientid.conf # etc/plugins/emqx_auth_clientid.conf ## 第一组认证数据 auth.client.1.clientid = admin_client auth.client.1.password = public ## 第二组认证数据 auth.clientid.2.clientid = wivwiv_client auth.clientid.2.password = public 插件启动时将读取预设认证数据并加载到 EMQ X 内置数据库中，节点上的认证数据会在此阶段同步至集群中。 预设认证数据在配置文件中使用了明文密码，出于安全性与可维护性考虑应当避免使用该功能。 预设认证数据无法通过 API 修改、删除，请慎用。 使用 HTTP API 管理认证数据 添加认证数据 API 定义： # Request POST api/v4/auth_clientid { \"clientid\": \"emqx_c\", \"password\": \"emqx_p\" } # Response { \"code\": 0 } 使用 POST 请求添加 clientid 为 emqx_c password 为 emqx_p 的认证信息，返回信息中 code = 0 即为成功。 查看已经添加的认证数据 API 定义： # Request GET api/v4/auth_clientid # Response { \"code\": 0, \"data\": [\"emqx_c\"] } 更改指定 Client ID 的密码 指定 Client ID，传递新密码进行更改，再次连接时需要使用新密码进行连接： API 定义： # Request PUT api/v4/auth_clientid/${clientid} { \"password\": \"emqx_new_p\" } # Response { \"code\": 0 } 查看指定 Client ID 信息 指定 Client ID，查看相关 Client ID、密码信息，注意此处返回的密码是使用配置文件指定哈希方式加密后的密码： API 定义： # Request GET api/v4/auth_clientid/${clientid} # Response { \"code\": 0, \"data\": { \"clientid\": \"emqx_c\", \"password\": \"091dc8753347e7dc5d348508fe6323735eecdb84fa800548870158117af8a0c0\" } } 删除认证数据 删除指定 Client ID： API 定义： # Request DELETE api/v4/auth_clientid/${clientid} # Response { \"code\": 0 } .emqxee { display: none; }"},"advanced/auth-mnesia.html":{"url":"advanced/auth-mnesia.html","title":"Mnesia 认证","summary":null,"keywords":"","body":"Mnesia 认证认证规则哈希方法预设认证数据使用 HTTP API 管理认证数据Mnesia 认证 Mnesia 认证使用 EMQ X 内置 Mnesia 数据库存储客户端 Client ID/Username 与密码，支持通过 HTTP API 管理认证数据。 Mnesia 认证不依赖外部数据源，使用上足够简单轻量。 插件： emqx_auth_mnesia 认证规则 Mnesia 认证默认基于 CONNECT 报文中的 Username 和密码进行认证, 可在 etc/plugins/emqx_auth_mnesia.conf 中更改为使用 CONNECT 报文的的 Client ID 与密码认证： ## Auth as username or auth as clientid. ## ## Value: username | clientid auth.mnesia.as = username 哈希方法 Mnesia 认证默认使用 sha256 进行密码哈希加密，可在 etc/plugins/emqx_auth_mnesia.conf 中更改： # etc/plugins/emqx_auth_mnesia.conf ## Value: plain | md5 | sha | sha256 auth.mnesia.password_hash = sha256 配置哈希方法后，新增的预设认证数据与通过 HTTP API 添加的认证数据将以哈希密文存储在 EMQ X 内置数据库中。 预设认证数据 可以通过配置文件预设认证数据，编辑配置文件：etc/plugins/emqx_auth_mnesia.conf # etc/plugins/emqx_auth_mnesia.conf ## 第一组认证数据 auth.mnesia.1.login = admin auth.mnesia.1.password = public auth.mnesia.1.is_superuser = true ## 第二组认证数据 auth.mnesia.2.login = client auth.mnesia.2.password = public auth.mnesia.2.is_superuser = false 认证数据中的 login 会根据 auth.mnesia.as 的值去读取客户端的 Username 或 Client ID. 插件启动时将读取预设认证数据并加载到 EMQ X 内置数据库中，节点上的认证数据会在此阶段同步至集群中。 预设认证数据在配置文件中使用了明文密码，出于安全性与可维护性考虑应当避免使用该功能。 预设认证数据无法通过 API 修改、删除，请慎用。 使用 HTTP API 管理认证数据 添加认证数据 API 定义： # Request POST api/v4/auth_user { \"login\": \"emqx_c\", \"password\": \"emqx_p\", \"is_superuser\": false } # Response { \"data\": { \"emqx_c\": \"ok\" }, \"code\": 0 } 使用 POST 请求添加 login 为 emqx_c，password 为 emqx_p，非超级用户的认证信息，返回信息中 code = 0 即为成功。 批量添加认证数据 API 定义： # Request POST api/v4/auth_user [ { \"login\": \"emqx_c_1\", \"password\": \"emqx_p\", \"is_superuser\": false }, { \"login\": \"emqx_c_2\", \"password\": \"emqx_p\", \"is_superuser\": false } ] # Response { \"data\": { \"emqx_c_2\": \"ok\", \"emqx_c_1\": \"ok\" }, \"code\": 0 } 查看已经添加的认证数据 API 定义： # Request GET api/v4/auth_user # Response { \"meta\": { \"page\": 1, \"limit\": 10, \"count\": 1 }, \"data\": [ { \"password\": \"ceb5e917f7930ae8f0dc3ceb496a428f7e644736eebca36a2b8f6bbac756171a\", \"login\": \"emqx_c\", \"is_superuser\": false } ], \"code\": 0 } 更改已添加的认证数据 API 定义： # Request PUT api/v4/auth_user/${login} { \"password\": \"emqx_new_p\", \"is_superuser\": false } # Response { \"code\": 0 } 查看指定的认证数据 注意此处返回的密码是使用配置文件指定哈希方式加密后的密码： API 定义： # Request GET api/v4/auth_user/${login} # Response { \"data\": { \"password\": \"3b20ff0218af39d01252844ccaac8ce0160f969ad00c601e23f6e57cd26fad4e\", \"login\": \"emqx_c\", \"is_superuser\": false }, \"code\": 0 } 删除认证数据 删除指定认证数据： API 定义： # Request DELETE api/v4/auth_user/${login} # Response { \"code\": 0 } .emqxee { display: none; }"},"advanced/auth-http.html":{"url":"advanced/auth-http.html","title":"HTTP 认证","summary":null,"keywords":"","body":"HTTP 认证认证原理HTTP 请求信息加盐规则与哈希方法认证请求HTTP 认证 HTTP 认证使用外部自建 HTTP 应用认证数据源，根据 HTTP API 返回的数据判定认证结果，能够实现复杂的认证鉴权逻辑。 插件： emqx_auth_http emqx_auth_http 插件同时包含 ACL 功能，可通过注释禁用。 认证原理 EMQ X 在设备连接事件中使用当前客户端相关信息作为参数，向用户自定义的认证服务发起请求查询权限，通过返回的 HTTP 响应状态码 (HTTP statusCode) 来处理认证请求。 认证失败：API 返回 4xx 状态码 认证成功：API 返回 200 状态码 忽略认证：API 返回 200 状态码且消息体 ignore HTTP 请求信息 HTTP API 基础请求信息，配置证书、请求头与重试规则。 # etc/plugins/emqx_auth_http.conf ## 启用 HTTPS 所需证书信息 ## auth.http.ssl.cacertfile = etc/certs/ca.pem ## auth.http.ssl.certfile = etc/certs/client-cert.pem ## auth.http.ssl.keyfile = etc/certs/client-key.pem ## 请求头设置 ## auth.http.header.Accept = */* ## 重试设置 auth.http.request.retry_times = 3 auth.http.request.retry_interval = 1s auth.http.request.retry_backoff = 2.0 加盐规则与哈希方法 HTTP 在请求中传递明文密码，加盐规则与哈希方法取决于 HTTP 应用。 认证请求 进行身份认证时，EMQ X 将使用当前客户端信息填充并发起用户配置的认证查询请求，查询出该客户端在 HTTP 服务器端的认证数据。 # etc/plugins/emqx_auth_http.conf ## 请求地址 auth.http.auth_req = http://127.0.0.1:8991/mqtt/auth ## HTTP 请求方法 ## Value: post | get | put auth.http.auth_req.method = post ## 请求参数 auth.http.auth_req.params = clientid=%c,username=%u,password=%P HTTP 请求方法为 GET 时，请求参数将以 URL 查询字符串的形式传递；POST、PUT 请求则将请求参数以普通表单形式提交（content-type 为 x-www-form-urlencoded）。 你可以在认证请求中使用以下占位符，请求时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %a：客户端 IP 地址 %r：客户端接入协议 %P：明文密码 %p：客户端端口 %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 推荐使用 POST 与 PUT 方法，使用 GET 方法时明文密码可能会随 URL 被记录到传输过程中的服务器日志中。 .emqxee { display: none; }"},"advanced/auth-jwt.html":{"url":"advanced/auth-jwt.html","title":"JWT 认证","summary":null,"keywords":"","body":"JWT 认证认证原理配置项auth.jwt.fromauth.jwt.verify_claimsJWT 认证 JWT 认证基于 Token 的鉴权机制，不依赖服务端保留客户端的认证信息或者会话信息，在持有密钥的情况下可以批量签发认证信息，是最简便的认证方式。 插件： emqx_auth_jwt 认证原理 客户端使用 Token 作为用户名或密码（取决于插件配置），发起连接时 EMQ X 使用配置中的密钥、证书进行解密，如果能成功解密则认证成功，否则认证失败。 默认配置下启用 JWT 认证后，你可以通过任意用户名+以下密码进行连接： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImF1dGhvciI6IndpdndpdiIsInNpdGUiOiJodHRwczovL3dpdndpdi5jb20ifSwiZXhwIjoxNTgyMjU1MzYwNjQyMDAwMCwiaWF0IjoxNTgyMjU1MzYwfQ.FdyAx2fYahm6h3g47m88ttyINzptzKy_speimyUcma4 配置项 要启用 JWT 认证，需要在 etc/plugins/emqx_auth_jwt.conf 中配置以下内容： # etc/plugins/emqx_auth_jwt.conf ## 密钥 auth.jwt.secret = emqxsecret ## 客户端携带 Token 的方式 ## Value: username | password auth.jwt.from = password ## 高级选项 ## 公钥文件，证书作为签发密钥时使用 ## auth.jwt.pubkey = etc/certs/jwt_public_key.pem ## Value: on | off auth.jwt.verify_claims = off ## auth.jwt.verify_claims.$name = expected ## Variables: ## - %u: username ## - %c: clientid # auth.jwt.verify_claims.username = %u auth.jwt.from 客户端携带 JWT 的位置，用于配置客户端 JWT 字符串携带位置，可选 username 与 password。 auth.jwt.verify_claims 如果你启用了 auth.jwt.verify_claims 选项，认证插件在验证 JWT 有效性之后还会进一步验证 Payload 中的数据有效性。 auth.jwt.verify_claims = on JWT 的 Payload 应当是 JSON 结构的数据，auth.jwt.verify_claims.$name 中 name 即为需要验证的 Payload 数据 key 值，假设你的 Payload 为： { \"username\": \"emqx_client_username\" } 你可以使用如下配置，当客户端携带此 Token 时，将验证客户端 username 是否等于 emqx_client_username： ## Variables: ## - %u: username ## - %c: clientid auth.jwt.verify_claims.username = %u 支持使用固定值或当前客户端信息进行验证： %u：当前客户端 username %c：当前客户端 client id JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限，使用 JWT 时建议启用 TLS 加密传输。 JWT 使用过程中无法在过期前废止某个 Token，请妥善设置有效时长并保管好密钥等加密信息。 .emqxee { display: none; }"},"advanced/auth-ldap.html":{"url":"advanced/auth-ldap.html","title":"LDAP 认证","summary":null,"keywords":"","body":"LDAP 认证LDAP 配置LDAP SchemaLDAP 认证 LDAP 认证使用外部 LDAP 服务器作为认证数据源，可以存储大量数据，同时方便与外部设备管理系统集成。 插件： emqx_auth_ldap emqx_auth_ldap 插件同时包含 ACL 功能，可通过注释禁用。 目前版本仅支持 OpenLDAP，不支持 Microsoft Active Directory。 LDAP 配置 要启用 LDAP 认证，需要在 etc/plugins/emqx_auth_ldap.conf 中配置以下内容： # etc/plugins/emqx_auth_ldap.conf auth.ldap.servers = 127.0.0.1 auth.ldap.port = 389 auth.ldap.pool = 8 ## ldap 的绑定专有名称(DN) auth.ldap.bind_dn = cn=root,dc=emqx,dc=io ## ldap 的绑定密码 auth.ldap.bind_password = public ## ldap 的查询超时时间 auth.ldap.timeout = 30s ## ldap 的设备专有名 auth.ldap.device_dn = ou=device,dc=emqx,dc=io ## ldap 的匹配对象类 auth.ldap.match_objectclass = mqttUser ## ldap 的用户名属性类型 auth.ldap.username.attributetype = uid ## ldap 的密码属性类型 auth.ldap.password.attributetype = userPassword ## TLS 配置项 ## auth.ldap.ssl.certfile = etc/certs/cert.pem ## auth.ldap.ssl.keyfile = etc/certs/key.pem ## auth.ldap.ssl.cacertfile = etc/certs/cacert.pem ## auth.ldap.ssl.verify = verify_peer ## auth.ldap.ssl.fail_if_no_peer_cert = true LDAP Schema 需要在 LDAP schema 目录配置数据模型，默认配置下数据模型如下： /etc/openldap/schema/emqx.schema attributetype ( 1.3.6.1.4.1.11.2.53.2.2.3.1.2.3.1.3 NAME 'isEnabled' EQUALITY booleanMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.7 SINGLE-VALUE USAGE userApplications ) attributetype ( 1.3.6.1.4.1.11.2.53.2.2.3.1.2.3.4.1 NAME ( 'mqttPublishTopic' 'mpt' ) EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications ) attributetype ( 1.3.6.1.4.1.11.2.53.2.2.3.1.2.3.4.2 NAME ( 'mqttSubscriptionTopic' 'mst' ) EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications ) attributetype ( 1.3.6.1.4.1.11.2.53.2.2.3.1.2.3.4.3 NAME ( 'mqttPubSubTopic' 'mpst' ) EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 USAGE userApplications ) objectclass ( 1.3.6.1.4.1.11.2.53.2.2.3.1.2.3.4 NAME 'mqttUser' AUXILIARY MAY ( mqttPublishTopic $ mqttSubscriptionTopic $ mqttPubSubTopic) ) objectclass ( 1.3.6.1.4.1.11.2.53.2.2.3.1.2.3.2 NAME 'mqttDevice' SUP top STRUCTURAL MUST ( uid ) MAY ( isEnabled ) ) objectclass ( 1.3.6.1.4.1.11.2.53.2.2.3.1.2.3.3 NAME 'mqttSecurity' SUP top AUXILIARY MAY ( userPassword $ userPKCS12 $ pwdAttribute $ pwdLockout ) ) 编辑 ldap 的配置文件 slapd.conf 引用 Schema： /etc/openldap/slapd.conf include /etc/openldap/schema/core.schema include /etc/openldap/schema/cosine.schema include /etc/openldap/schema/inetorgperson.schema include /etc/openldap/schema/ppolicy.schema include /etc/openldap/schema/emqx.schema database bdb suffix \"dc=emqx,dc=io\" rootdn \"cn=root,dc=emqx,dc=io\" rootpw {SSHA}eoF7NhNrejVYYyGHqnt+MdKNBh4r1w3W directory /etc/openldap/data .emqxee { display: none; }"},"advanced/auth-mysql.html":{"url":"advanced/auth-mysql.html","title":"MySQL 认证","summary":null,"keywords":"","body":"MySQL 认证MySQL 连接信息默认表结构加盐规则与哈希方法认证 SQL（auth_query）特殊说明MySQL 认证 MySQL 认证使用外部 MySQL 数据库作为认证数据源，可以存储大量数据，同时方便与外部设备管理系统集成。 插件： emqx_auth_mysql emqx_auth_mysql 插件同时包含 ACL 功能，可通过注释禁用。 要启用 MySQL 认证，需要在 etc/plugins/emqx_auth_mysql.conf 中配置以下内容： MySQL 连接信息 MySQL 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_mysql.conf ## 服务器地址 auth.mysql.server = 127.0.0.1:3306 ## 连接池大小 auth.mysql.pool = 8 auth.mysql.username = emqx auth.mysql.password = public auth.mysql.database = mqtt auth.mysql.query_timeout = 5s 默认表结构 MySQL 认证默认配置下需要确保数据库中有下表： CREATE TABLE `mqtt_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `salt` varchar(35) DEFAULT NULL, `is_superuser` tinyint(1) DEFAULT 0, `created` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `mqtt_username` (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 默认配置下示例数据如下： INSERT INTO `mqtt_user` ( `username`, `password`, `salt`) VALUES ('emqx', 'efa1f375d76194fa51a3556a97e641e61685f914d446979da50a551a4333ffd7', NULL); 启用 MySQL 认证后，你可以通过用户名： emqx，密码：public 连接。 这是默认配置使用的表结构，熟悉该插件的使用后你可以使用任何满足条件的数据表进行认证。 加盐规则与哈希方法 MySQL 认证支持配置加盐规则与哈希方法： # etc/plugins/emqx_auth_mysql.conf auth.mysql.password_hash = sha256 认证 SQL（auth_query） 进行身份认证时，EMQ X 将使用当前客户端信息填充并执行用户配置的认证 SQL，查询出该客户端在数据库中的认证数据。 # etc/plugins/emqx_auth_mysql.conf auth.mysql.auth_query = select password from mqtt_user where username = '%u' limit 1 你可以在认证 SQL 中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整认证 SQL，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下认证 SQL 需要满足以下条件： 查询结果中必须包含 password 字段，EMQ X 使用该字段与客户端密码比对 如果启用了加盐配置，查询结果中必须包含 salt 字段，EMQ X 使用该字段作为 salt（盐）值 查询结果只能有一条，多条结果时只取第一条作为有效数据 可以在 SQL 中使用 AS 语法为字段重命名指定 password，或者将 salt 值设为固定值。 特殊说明 MySQL 8.0 及以后版本使用了 caching_sha2_password 作为默认身份验证插件，受限于客户端驱动你必须将其更改为 mysql_native_password 插件： ALTER USER 'your_username'@'your_host' IDENTIFIED WITH mysql_native_password BY 'your_password'; .emqxee { display: none; }"},"advanced/auth-postgresql.html":{"url":"advanced/auth-postgresql.html","title":"PostgreSQL 认证","summary":null,"keywords":"","body":"PostgreSQL 认证PostgreSQL 连接信息默认表结构加盐规则与哈希方法认证 SQL（auth_query）PostgreSQL 认证 PostgreSQL 认证使用外部 PostgreSQL 数据库作为认证数据源，可以存储大量数据，同时方便与外部设备管理系统集成。 插件： emqx_auth_pgsql emqx_auth_pgsql 插件同时包含 ACL 功能，可通过注释禁用。 要启用 PostgreSQL 认证，需要在 etc/plugins/emqx_auth_pgsql.conf 中配置以下内容： PostgreSQL 连接信息 PostgreSQL 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_pgsql.conf ## 服务器地址 auth.pgsql.server = 127.0.0.1:5432 ## 连接池大小 auth.pgsql.pool = 8 auth.pgsql.username = root auth.pgsql.password = public auth.pgsql.database = mqtt auth.pgsql.encoding = utf8 ## TLS 配置 ## auth.pgsql.ssl = false ## auth.pgsql.ssl_opts.keyfile = ## auth.pgsql.ssl_opts.certfile = 默认表结构 PostgreSQL 认证默认配置下需要确保数据库中有下表： CREATE TABLE mqtt_user ( id SERIAL primary key, is_superuser boolean, username character varying(100), password character varying(100), salt character varying(40) ) 默认配置下示例数据如下： INSERT INTO mqtt_user (username, password, salt, is_superuser) VALUES ('emqx', 'efa1f375d76194fa51a3556a97e641e61685f914d446979da50a551a4333ffd7', NULL, false); 启用 PostgreSQL 认证后，你可以通过用户名： emqx，密码：public 连接。 这是默认配置使用的表结构，熟悉该插件的使用后你可以使用任何满足条件的数据表进行认证。 加盐规则与哈希方法 PostgreSQL 认证支持配置加盐规则与哈希方法： # etc/plugins/emqx_auth_pgsql.conf auth.pgsql.password_hash = sha256 认证 SQL（auth_query） 进行身份认证时，EMQ X 将使用当前客户端信息填充并执行用户配置的认证 SQL，查询出该客户端在数据库中的认证数据。 # etc/plugins/emqx_auth_pgsql.conf auth.pgsql.auth_query = select password from mqtt_user where username = '%u' limit 1 你可以在认证 SQL 中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整认证 SQL，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下认证 SQL 需要满足以下条件： 查询结果中必须包含 password 字段，EMQ X 使用该字段与客户端密码比对 如果启用了加盐配置，查询结果中必须包含 salt 字段，EMQ X 使用该字段作为 salt（盐）值 查询结果只能有一条，多条结果时只取第一条作为有效数据 可以在 SQL 中使用 AS 语法为字段重命名指定 password，或者将 salt 值设为固定值。 .emqxee { display: none; }"},"advanced/auth-redis.html":{"url":"advanced/auth-redis.html","title":"Redis 认证","summary":null,"keywords":"","body":"Redis 认证Redis 连接信息默认数据结构加盐规则与哈希方法认证查询命令（auth query cmd）Redis 认证 Redis 认证使用外部 Redis 数据库作为认证数据源，可以存储大量数据，同时方便与外部设备管理系统集成。 插件： emqx_auth_redis emqx_auth_redis 插件同时包含 ACL 功能，可通过注释禁用。 要启用 Redis 认证，需要在 etc/plugins/emqx_auth_redis.conf 中配置以下内容： Redis 连接信息 Redis 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_redis.conf ## 服务器地址 auth.redis.server = 127.0.0.1:6379 ## 连接池大小 auth.redis.pool = 8 auth.redis.database = 0 auth.redis.password = 默认数据结构 Redis 认证默认配置下使用哈希表存储认证数据，使用 mqtt_user: 作为 Redis 键前缀，数据结构如下： redis> hgetall mqtt_user:emqx password public salt wivwiv 默认配置下示例数据如下： HMSET mqtt_user:emqx password public salt wivwiv 启用 Redis 认证后，你可以通过用户名： emqx，密码：public 连接。 这是默认配置使用的数据结构，熟悉该插件的使用后你可以使用任何满足条件的数据结构进行认证。 加盐规则与哈希方法 Redis 认证支持配置加盐规则与哈希方法，默认存储明文密码不做处理： # etc/plugins/emqx_auth_redis.conf auth.redis.password_hash = plain 认证查询命令（auth query cmd） 进行身份认证时，EMQ X 将使用当前客户端信息填充并执行用户配置的认证查询命令，查询出该客户端在 Redis 中的认证数据。 # etc/plugins/emqx_auth_redis.conf auth.redis.auth_cmd = HMGET mqtt_user:%u password 你可以在命令中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整认证查询命令，使用任意 Redis 支持的命令，但是任何情况下认证查询命令需要满足以下条件： 查询结果中第一个数据必须为 password，EMQ X 使用该字段与客户端密码比对 如果启用了加盐配置，查询结果中第二个数据必须是 salt 字段，EMQ X 使用该字段作为 salt（盐）值 .emqxee { display: none; }"},"advanced/auth-mongodb.html":{"url":"advanced/auth-mongodb.html","title":"MongoDB 认证","summary":null,"keywords":"","body":"MongoDB 认证MongoDB 连接信息默认数据结构加盐规则与哈希方法认证查询（auth_selector）MongoDB 认证 MongoDB 认证使用外部 MongoDB 数据库作为认证数据源，可以存储大量数据，同时方便与外部设备管理系统集成。 插件： emqx_auth_mongo emqx_auth_mongo 插件同时包含 ACL 功能，可通过注释禁用。 要启用 MongoDB 认证，需要在 etc/plugins/emqx_auth_mongo.conf 中配置以下内容： MongoDB 连接信息 MongoDB 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_mongo.conf ## MongoDB 架构类型 ## ## Value: single | unknown | sharded | rs auth.mongo.type = single ## rs 模式需要设置 rs name ## auth.mongo.rs_set_name = ## 服务器列表，集群模式下使用逗号分隔每个服务器 ## Examples: 127.0.0.1:27017,127.0.0.2:27017... auth.mongo.server = 127.0.0.1:27017 auth.mongo.pool = 8 auth.mongo.login = auth.mongo.password = ## auth.mongo.auth_source = admin auth.mongo.database = mqtt auth.mongo.query_timeout = 5s ## SSL 选项 # auth.mongo.ssl = false ## auth.mongo.ssl_opts.keyfile = ## auth.mongo.ssl_opts.certfile = ## auth.mongo.ssl_opts.cacertfile = ## MongoDB write mode. ## ## Value: unsafe | safe ## auth.mongo.w_mode = ## Mongo read mode. ## ## Value: master | slave_ok ## auth.mongo.r_mode = ## MongoDB 拓扑配置，一般情况下用不到，详见 MongoDB 官网文档 auth.mongo.topology.pool_size = 1 auth.mongo.topology.max_overflow = 0 ## auth.mongo.topology.overflow_ttl = 1000 ## auth.mongo.topology.overflow_check_period = 1000 ## auth.mongo.topology.local_threshold_ms = 1000 ## auth.mongo.topology.connect_timeout_ms = 20000 ## auth.mongo.topology.socket_timeout_ms = 100 ## auth.mongo.topology.server_selection_timeout_ms = 30000 ## auth.mongo.topology.wait_queue_timeout_ms = 1000 ## auth.mongo.topology.heartbeat_frequency_ms = 10000 ## auth.mongo.topology.min_heartbeat_frequency_ms = 1000 默认数据结构 MongoDB 认证默认配置下需要确保数据库中有如下集合： { username: \"user\", password: \"password hash\", salt: \"password salt\", is_superuser: false, created: \"2020-02-20 12:12:14\" } 默认配置下示例数据如下： use mqtt db.mqtt_user.insert({ \"username\": \"emqx\", \"password\": \"efa1f375d76194fa51a3556a97e641e61685f914d446979da50a551a4333ffd7\", \"is_superuser\": false, \"salt\": \"\" }) 启用 MongoDB 认证后，你可以通过用户名： emqx，密码：public 连接。 这是默认配置使用的集合结构，熟悉该插件的使用后你可以使用任何满足条件的集合进行认证。 加盐规则与哈希方法 MongoDB 认证支持配置加盐规则与哈希方法： # etc/plugins/emqx_auth_mongo.conf auth.mongo.password_hash = sha256 认证查询（auth_selector） 进行身份认证时，EMQ X 将使用当前客户端信息填充并执行用户配置的认证 SQL，查询出该客户端在数据库中的认证数据。 MongoDB 支持配置集合名称、密码字段、selector 命令 # etc/plugins/emqx_auth_mongo.conf auth.mongo.auth_query.collection = mqtt_user ## 如果启用了加盐处理，此处需配置为 password,salt ## Value: password | password,salt auth.mongo.auth_query.password_field = password auth.mongo.auth_query.selector = username=%u 你可以在认证查询（selector）中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整认证查询，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下认证查询需要满足以下条件： 查询结果中必须包含 password 字段，EMQ X 使用该字段与客户端密码比对 如果启用了加盐配置，查询结果中必须包含 salt 字段，EMQ X 使用该字段作为 salt（盐）值 MongoDB 使用 findOne 查询命令，确保你期望的查询结果能够出现在第一条数据中 .emqxee { display: none; }"},"advanced/acl.html":{"url":"advanced/acl.html","title":"发布订阅 ACL 简介","summary":null,"keywords":"","body":"发布订阅 ACLACL 插件规则详解授权结果全局配置超级用户（superuser）ACL 缓存清除缓存ACL 鉴权链发布订阅 ACL 发布订阅 ACL 指对 发布 (PUBLISH)/订阅 (SUBSCRIBE) 操作的 权限控制。例如拒绝用户名为 Anna 向 open/elsa/door 发布消息。 EMQ X 支持通过客户端发布订阅 ACL 进行客户端权限的管理，本章节介绍了 EMQ X 支持的发布订阅 ACL 以及对应插件的配置方法。 ACL 插件 EMQ X 支持使用配置文件、外部主流数据库和自定义 HTTP API 作为 ACL 数据源。 连接数据源、进行访问控制功能是通过插件实现的，使用前需要启用相应的插件。 客户端订阅主题、发布消息时插件通过检查目标主题（Topic）是否在指定数据源允许/禁止列表内来实现对客户端的发布、订阅权限管理。 配置文件/内置数据源 内置 ACL Mnesia ACL 使用配置文件提供认证数据源，适用于变动较小的 ACL 管理。 外部数据库 MySQL ACL PostgreSQL ACL Redis ACL MongoDB ACL 外部数据库可以存储大量数据、动态管理 ACL，方便与外部设备管理系统集成。 其他 HTTP ACL HTTP ACL 能够实现复杂的 ACL 管理。 ACL 功能包含在认证鉴权插件中，更改插件配置后需要重启插件才能生效， 规则详解 ACL 是允许与拒绝条件的集合，EMQ X 中使用以下元素描述 ACL 规则： ## Allow-Deny Who Pub-Sub Topic \"允许(Allow) / 拒绝(Deny)\" \"谁(Who)\" \"订阅(Subscribe) / 发布(Publish)\" \"主题列表(Topics)\" 同时具有多条 ACL 规则时，EMQ X 将按照规则排序进行合并，以 ACL 文件 中的默认 ACL 为例，ACL 文件中配置了默认的 ACL 规则，规则从下至上加载： 第一条规则允许客户端发布订阅所有主题 第二条规则禁止全部客户端订阅 $SYS/# 与 # 主题 第三条规则允许 ip 地址为 127.0.0.1 的客户端发布/订阅 $SYS/# 与 # 主题，为第二条开了特例 第四条规则允许用户名为 dashboard 的客户端订阅 $SYS/# 主题，为第二条开了特例 {allow, {user, \"dashboard\"}, subscribe, [\"$SYS/#\"]}. {allow, {ipaddr, \"127.0.0.1\"}, pubsub, [\"$SYS/#\", \"#\"]}. {deny, all, subscribe, [\"$SYS/#\", {eq, \"#\"}]}. {allow, all}. 授权结果 任何一次 ACL 授权最终都会返回一个结果： 允许：经过检查允许客户端进行操作 禁止：经过检查禁止客户端操作 忽略（ignore）：未查找到 ACL 权限信息，无法显式判断结果是允许还是禁止，交由下一 ACL 插件或默认 ACL 规则来判断 全局配置 默认配置中 ACL 是开放授权的，即授权结果为忽略（ignore）时允许客户端通过授权。 通过 etc/emqx.conf 中的 ACL 配置可以更改该属性： # etc/emqx.conf ## ACL 未匹配时默认授权 ## Value: allow | deny acl_nomatch = allow 配置默认 ACL 文件，使用文件定义默认 ACL 规则： # etc/emqx.conf acl_file = etc/acl.conf 配置 ACL 授权结果为禁止的响应动作，为 ignore 时将断开设备： # etc/emqx.conf ## Value: ignore | disconnect acl_deny_action = ignore 在 MQTT v3.1 和 v3.1.1 协议中，发布操作被拒绝后服务器无任何报文错误返回，这是协议设计的一个缺陷。但在 MQTT v5.0 协议上已经支持应答一个相应的错误报文。 超级用户（superuser） 客户端可拥有“超级用户”身份，超级用户拥有最高权限不受 ACL 限制。 认证鉴权插件启用超级用户功能后，发布订阅时 EMQ X 将优先检查客户端超级用户身份 客户端为超级用户时，通过授权并跳过后续 ACL 检查 ACL 缓存 ACL 缓存允许客户端在命中某条 ACL 规则后，便将其缓存至内存中，以便下次直接使用，客户端发布、订阅频率较高的情况下开启 ACL 缓存可以提高 ACL 检查性能。 在 etc/emqx.conf 可以配置 ACL 缓存大小与缓存时间： # etc/emqx.conf ## 是否启用 enable_acl_cache = on ## 单个客户端最大缓存规则数量 acl_cache_max_size = 32 ## 缓存失效时间，超时后缓存将被清除 acl_cache_ttl = 1m 清除缓存 在更新 ACL 规则后，某些客户端由于已经存在缓存，则无法立即生效。若要立即生效，则需手动清除所有的 ACL 缓存： 参见 HTTP API - 清除 ACL 缓存 ACL 鉴权链 当同时启用多个 ACL 插件时，EMQ X 将按照插件开启先后顺序进行链式鉴权： 一通过授权，终止链并允许客户端通过验证 一旦授权失败，终止链并禁止客户端通过验证 直到最后一个 ACL 插件仍未通过，根据默认授权配置判定 默认授权为允许时，允许客户端通过验证 默认授权为禁止时，禁止客户端通过验证 同时只启用一个 ACL 插件可以提高客户端 ACL 检查性能。 .emqxee { display: none; }"},"advanced/acl-file.html":{"url":"advanced/acl-file.html","title":"内置 ACL","summary":null,"keywords":"","body":"内置 ACL定义 ACLacl.conf 编写规则内置 ACL 内置 ACL 通过文件设置规则，使用上足够简单轻量，适用于规则数量可预测、无变动需求或变动较小的项目。 ACL 规则文件： etc/acl.conf 内置 ACL 优先级最低，可以被 ACL 插件覆盖，如需禁用全部注释即可。规则文件更改后需重启 EMQ X 以应用生效。 定义 ACL 内置 ACL 是优先级最低规则表，在所有的 ACL 检查完成后，如果仍然未命中则检查默认的 ACL 规则。 该规则文件以 Erlang 语法的格式进行描述： %% 允许 \"dashboard\" 用户 订阅 \"$SYS/#\" 主题 {allow, {user, \"dashboard\"}, subscribe, [\"$SYS/#\"]}. %% 允许 IP 地址为 \"127.0.0.1\" 的用户 发布/订阅 \"#SYS/#\"，\"#\" 主题 {allow, {ipaddr, \"127.0.0.1\"}, pubsub, [\"$SYS/#\", \"#\"]}. %% 拒绝 \"所有用户\" 订阅 \"$SYS/#\" \"#\" 主题 {deny, all, subscribe, [\"$SYS/#\", {eq, \"#\"}]}. %% 允许其它任意的发布订阅操作 {allow, all}. 第一条规则允许客户端发布订阅所有主题 第二条规则禁止全部客户端订阅 $SYS/# 与 # 主题 第三条规则允许 ip 地址为 127.0.0.1 的客户端发布/订阅 $SYS/# 与 # 主题，为第二条开了特例 第四条规则允许用户名为 dashboard 的客户端订阅 $SYS/# 主题，为第二条开了特例 可知，默认的 ACL 主要是为了限制客户端对系统主题 $SYS/# 和全通配主题 # 的权限。 acl.conf 编写规则 acl.conf 文件中的规则按书写顺序从上往下匹配。 acl.conf 的语法规则包含在顶部的注释中，熟悉 Erlang 语法的可直接阅读文件顶部的注释。或参考以下的释义： 以 %% 表示行注释。 每条规则由四元组组成，以 . 结束。 元组第一位：表示规则命中成功后，执行权限控制操作，可取值为： allow：表示 允许 deny： 表示 拒绝 元组第二位：表示规则所生效的用户，可使用的格式为： {user, \"dashboard\"}：表明规则仅对 用户名 (Username) 为 \"dashboard\" 的用户生效 {clientid, \"dashboard\"}：表明规则仅对 客户端标识 (ClientId) 为 \"dashboard\" 的用户生效 {ipaddr, \"127.0.0.1\"}：表明规则仅对 源地址 为 \"127.0.0.1\" 的用户生效 all：表明规则对所有的用户都生效 元组第三位：表示规则所控制的操作，可取值为： publish：表明规则应用在 PUBLISH 操作上 subscribe：表明规则应用在 SUBSCRIBE 操作上 pubsub：表明规则对 PUBLISH 和 SUBSCRIBE 操作都有效 元组第四位：表示规则所限制的主题列表，内容以数组的格式给出，例如： \"$SYS/#\"：为一个 主题过滤器 (Topic Filter)；表示规则可命中与 $SYS/# 匹配的主题；如：可命中 \"$SYS/#\"，也可命中 \"$SYS/a/b/c\" {eq, \"#\"}：表示字符的全等，规则仅可命中主题为 # 的字串，不能命中 /a/b/c 等 除此之外还存在两条特殊的规则： {allow, all}：允许所有操作 {deny, all}：拒绝所有操作 在 acl.conf 修改完成后，并不会自动加载至 EMQ X 系统。需要手动执行： ./bin/emqx_ctl acl reload acl.conf 中应只包含一些简单而通用的规则，使其成为系统基础的 ACL 原则。如果需要支持复杂、大量的 ACL 内容，你应该在认证插件中去实现它。 .emqxee { display: none; }"},"advanced/acl-mnesia.html":{"url":"advanced/acl-mnesia.html","title":"Mnesia ACL","summary":null,"keywords":"","body":"Mnesia ACLACL规则ACL 规则结构体使用 HTTP API 管理 ACL 规则Request请注意 ${topic} 需要使用 UrlEncode 编码ResponseMnesia ACL Mnesia ACL 使用 EMQ X 内置的 Mnesia 数据库存储 ACL 规则，可以存储数据、动态管理 ACL，方便与外部设备管理系统集成 插件： emqx_auth_mnesia ACL规则 Mnesia ACL 默认基于 MQTT 报文中的 Username 和密码进行权限认证, 可在 etc/plugins/emqx_auth_mnesia.conf 中更改为使用 MQTT 报文的的 Client ID 与密码认证： ## Auth and ACL base on username or clientid. ## ## Value: username | clientid auth.mnesia.as = username ACL 规则结构体 { \"login\":\"emqx\", \"topic\":\"testtopic/1\", \"action\":\"pub\", \"allow\": true } 规则字段说明： login：根据 auth.mnesia.as 的值匹配客户端的 Username 或 Client ID. topic：控制的主题，可以使用通配符，并且可以在主题中加入占位符来匹配客户端信息，例如 t/%c 则在匹配时主题将会替换为当前客户端的 Client ID %u：用户名 %c：Client ID action：操作行为，可选值：pub | sub | pubsub allow：是否允许 Mnesia ACL 默认不设规则，你可以使用 HTTP API 管理 ACL 规则。 使用 HTTP API 管理 ACL 规则 添加 ACL 规则 API 定义： # Request POST api/v4/emqx_acl { \"login\":\"emqx\", \"topic\":\"Topic/A\", \"action\":\"pub\", \"allow\": true } # Response { \"data\": { \"emqx\": \"ok\" }, \"code\": 0 } 批量添加 ACL 规则 API 定义： # Request POST api/v4/emqx_acl [ { \"login\":\"emqx_1\", \"topic\":\"Topic/A\", \"action\":\"pub\", \"allow\": true }, { \"login\":\"emqx_2\", \"topic\":\"Topic/A\", \"action\":\"pub\", \"allow\": true } ] # Response { \"data\": { \"emqx_2\": \"ok\", \"emqx_1\": \"ok\" }, \"code\": 0 } 查看已经添加的 ACL 规则 API 定义： # Request GET api/v4/emqx_acl # Response { \"meta\": { \"page\": 1, \"limit\": 10, \"count\": 1 }, \"data\": [ { \"topic\": \"Topic/A\", \"login\": \"emqx\", \"action\": \"pub\" } ], \"code\": 0 } 查看指定 ACL 规则 API 定义： # Request GET api/v4/emqx_acl/${login} # Response { \"data\": { \"topic\": \"Topic/A\", \"login\": \"emqx\", \"allow\": true, \"action\": \"pub\" }, \"code\": 0 } 删除 ACL 规则 删除指定 ACL 规则： API 定义： ```bash Request 请注意 ${topic} 需要使用 UrlEncode 编码 DELETE api/v4/emqx_acl/${login}/${topic} Response { \"code\": 0 } ``` .emqxee { display: none; }"},"advanced/acl-http.html":{"url":"advanced/acl-http.html","title":"HTTP ACL","summary":null,"keywords":"","body":"HTTP ACLACL 授权原理HTTP 请求信息superuser 请求ACL 授权查询请求请求说明HTTP ACL HTTP 认证使用外部自建 HTTP 应用认证授权数据源，根据 HTTP API 返回的数据判定授权结果，能够实现复杂的 ACL 校验逻辑。 插件： emqx_auth_http emqx_auth_http 插件同时包含认证功能，可通过注释禁用。 要启用 HTTP ACL，需要在 etc/plugins/emqx_auth_http.conf 中配置以下内容： ACL 授权原理 EMQ X 在设备发布、订阅事件中使用当前客户端相关信息作为参数，向用户自定义的认证服务发起请求权限，通过返回的 HTTP 响应状态码 (HTTP statusCode) 来处理 ACL 授权请求。 无权限：API 返回 4xx 状态码 授权成功：API 返回 200 状态码 忽略授权：API 返回 200 状态码且消息体 ignore HTTP 请求信息 HTTP API 基础请求信息，配置证书、请求头与重试规则。 # etc/plugins/emqx_auth_http.conf ## 启用 HTTPS 所需证书信息 ## auth.http.ssl.cacertfile = etc/certs/ca.pem ## auth.http.ssl.certfile = etc/certs/client-cert.pem ## auth.http.ssl.keyfile = etc/certs/client-key.pem ## 请求头设置 ## auth.http.header.Accept = */* ## 重试设置 auth.http.request.retry_times = 3 auth.http.request.retry_interval = 1s auth.http.request.retry_backoff = 2.0 进行发布、订阅认证时，EMQ X 将使用当前客户端信息填充并发起用户配置的 ACL 授权查询请求，查询出该客户端在 HTTP 服务器端的授权数据。 superuser 请求 首先查询客户端是否为超级用户，客户端为超级用户时将跳过 ACL 查询。 # etc/plugins/emqx_auth_http.conf ## 请求地址 auth.http.super_req = http://127.0.0.1:8991/mqtt/superuser ## HTTP 请求方法 ## Value: post | get | put auth.http.super_req.method = post ## 请求参数 auth.http.super_req.params = clientid=%c,username=%u ACL 授权查询请求 # etc/plugins/emqx_auth_http.conf ## 请求地址 auth.http.acl_req = http://127.0.0.1:8991/mqtt/acl ## HTTP 请求方法 ## Value: post | get | put auth.http.acl_req.method = get ## 请求参数 auth.http.acl_req.params = access=%A,username=%u,clientid=%c,ipaddr=%a,topic=%t,mountpoint=%m 请求说明 HTTP 请求方法为 GET 时，请求参数将以 URL 查询字符串的形式传递；POST、PUT 请求则将请求参数以普通表单形式提交（content-type 为 x-www-form-urlencoded）。 你可以在认证请求中使用以下占位符，请求时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %a：客户端 IP 地址 %r：客户端接入协议 %P：明文密码 %p：客户端端口 %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 推荐使用 POST 与 PUT 方法，使用 GET 方法时明文密码可能会随 URL 被记录到传输过程中的服务器日志中。 .emqxee { display: none; }"},"advanced/acl-mysql.html":{"url":"advanced/acl-mysql.html","title":"MySQL ACL","summary":null,"keywords":"","body":"MySQL ACLMySQL 连接信息默认表结构认证/超级用户表ACL 规则表超级用户 SQL（super_query）ACL SQL（acl_query）特殊说明MySQL ACL MySQL ACL 使用外部 MySQL 数据库存储 ACL 规则，可以存储大量数据、动态管理 ACL，方便与外部设备管理系统集成 插件： emqx_auth_mysql emqx_auth_mysql 插件同时包含认证功能，可通过注释禁用。 MySQL 连接信息 MySQL 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_mysql.conf ## 服务器地址 auth.mysql.server = 127.0.0.1:3306 ## 连接池大小 auth.mysql.pool = 8 auth.mysql.username = emqx auth.mysql.password = public auth.mysql.database = mqtt auth.mysql.query_timeout = 5s 默认表结构 MySQL 认证插件默认配置下需要确保数据库中有以下两张数据表，用于存储认证规则信息： 认证/超级用户表 CREATE TABLE `mqtt_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `salt` varchar(35) DEFAULT NULL, `is_superuser` (1) DEFAULT 0, `created` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `mqtt_username` (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 示例数据： -- 客户端信息 INSERT INTO `mqtt_user` ( `username`, `password`, `salt`, `is_superuser`) VALUES ('emqx', 'efa1f375d76194fa51a3556a97e641e61685f914d446979da50a551a4333ffd7', NULL, 0); ACL 规则表 CREATE TABLE `mqtt_acl` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `allow` int(1) DEFAULT 1 COMMENT '0: deny, 1: allow', `ipaddr` varchar(60) DEFAULT NULL COMMENT 'IpAddress', `username` varchar(100) DEFAULT NULL COMMENT 'Username', `clientid` varchar(100) DEFAULT NULL COMMENT 'ClientId', `access` int(2) NOT NULL COMMENT '1: subscribe, 2: publish, 3: pubsub', `topic` varchar(100) NOT NULL DEFAULT '' COMMENT 'Topic Filter', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 规则表字段说明： allow：禁止（0），允许（1） ipaddr：设置 IP 地址 username：连接客户端的用户名，此处的值如果设置为 $all 表示该规则适用于所有的用户 clientid：连接客户端的 Client ID access：允许的操作：订阅（1），发布（2），订阅发布都可以（3） topic：控制的主题，可以使用通配符，并且可以在主题中加入占位符来匹配客户端信息，例如 t/%c 则在匹配时主题将会替换为当前客户端的 Client ID %u：用户名 %c：Client ID 默认配置下示例数据： -- 所有用户不可以订阅系统主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (0, NULL, '$all', NULL, 1, '$SYS/#'); -- 允许 10.59.1.100 上的客户端订阅系统主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (1, '10.59.1.100', NULL, NULL, 1, '$SYS/#'); -- 禁止客户端订阅 /smarthome/+/temperature 主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (0, NULL, NULL, NULL, 1, '/smarthome/+/temperature'); -- 允许客户端订阅包含自身 Client ID 的 /smarthome/${clientid}/temperature 主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (1, NULL, NULL, NULL, 1, '/smarthome/%c/temperature'); 启用 MySQL ACL 后并以用户名 emqx 成功连接后，客户端应当数据具有相应的主题权限。 这是默认配置使用的表结构，熟悉该插件的使用后你可以使用任何满足条件的数据表进行 ACL 规则存储。 超级用户 SQL（super_query） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户 SQL，查询客户端是否为超级用户。客户端为超级用户时将跳过 ACL SQL。 # etc/plugins/emqx_auth_mysql.conf auth.mysql.super_query = select is_superuser from mqtt_user where username = '%u' limit 1 你可以在 SQL 中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整超级用户 SQL，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下超级用户 SQL 需要满足以下条件： 查询结果中必须包含 is_superuser 字段，is_superuser 应该显式的为 true 查询结果只能有一条，多条结果时只取第一条作为有效数据 如果不需要超级用户功能，注释并禁用该选项能有效提高效率 ACL SQL（acl_query） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户 SQL，如果没有启用超级用户 SQL 或客户端不是超级用户，则使用 ACL SQL 查询出该客户端在数据库中的 ACL 规则。 # etc/plugins/emqx_auth_mysql.conf auth.mysql.acl_query = select allow, ipaddr, username, clientid, access, topic from mqtt_acl where ipaddr = '%a' or username = '%u' or username = '$all' or clientid = '%c' 你可以在 ACL SQL 中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整 ACL SQL，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下 ACL SQL 需要满足以下条件： 查询结果中必须包含 allow、access、topic、clientid、username、ipaddr 字段，如果字段不想参与比对则使用 $all 字符串或者数据库 NULL 值 查询结果可以有多条，多条结果时按照从上到下的顺序进行匹配 可以在 SQL 中调整查询条件、指定排序方式实现更高效率的查询。 特殊说明 MySQL 8.0 及以后版本使用了 caching_sha2_password 作为默认身份验证插件，受限于客户端驱动你必须将其更改为 mysql_native_password 插件： ALTER USER 'your_username'@'your_host' IDENTIFIED WITH mysql_native_password BY 'your_password'; .emqxee { display: none; }"},"advanced/acl-postgres.html":{"url":"advanced/acl-postgres.html","title":"PostgreSQL ACL","summary":null,"keywords":"","body":"PostgreSQL ACLPostgreSQL 连接信息默认表结构认证/超级用户表ACL 规则表超级用户 SQL（super_query）ACL SQL（acl_query）PostgreSQL ACL PostgreSQL ACL 使用外部 PostgreSQL 数据库存储 ACL 规则，可以存储大量数据、动态管理 ACL，方便与外部设备管理系统集成。 插件： emqx_auth_pgsql emqx_auth_pgsql 插件同时包含认证功能，可通过注释禁用。 PostgreSQL 连接信息 PostgreSQL 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_pgsql.conf ## 服务器地址 auth.pgsql.server = 127.0.0.1:5432 ## 连接池大小 auth.pgsql.pool = 8 auth.pgsql.username = root auth.pgsql.password = public auth.pgsql.database = mqtt auth.pgsql.encoding = utf8 ## TLS 配置 ## auth.pgsql.ssl = false ## auth.pgsql.ssl_opts.keyfile = ## auth.pgsql.ssl_opts.certfile = 默认表结构 PostgreSQL 认证插件默认配置下需要确保数据库中有以下两张数据表，用于存储认证规则信息： 认证/超级用户表 CREATE TABLE mqtt_user ( id SERIAL primary key, is_superuser boolean, username character varying(100), password character varying(100), salt character varying(40) ) 示例数据： -- 客户端信息 INSERT INTO mqtt_user (username, password, salt, is_superuser) VALUES ('emqx', 'efa1f375d76194fa51a3556a97e641e61685f914d446979da50a551a4333ffd7', NULL, false); ACL 规则表 CREATE TABLE mqtt_acl ( id SERIAL primary key, allow integer, ipaddr character varying(60), username character varying(100), clientid character varying(100), access integer, topic character varying(100) ) 规则表字段说明： allow：禁止（0），允许（1） ipaddr：设置 IP 地址 username：连接客户端的用户名，此处的值如果设置为 $all 表示该规则适用于所有的用户 clientid：连接客户端的 Client ID access：允许的操作：订阅（1），发布（2），订阅发布都可以（3） topic：控制的主题，可以使用通配符，并且可以在主题中加入占位符来匹配客户端信息，例如 t/%c 则在匹配时主题将会替换为当前客户端的 Client ID %u：用户名 %c：Client ID 默认配置下示例数据： -- 所有用户不可以订阅系统主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (0, NULL, '$all', NULL, 1, '$SYS/#'); -- 允许 10.59.1.100 上的客户端订阅系统主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (1, '10.59.1.100', NULL, NULL, 1, '$SYS/#'); -- 禁止客户端订阅 /smarthome/+/temperature 主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (0, NULL, NULL, NULL, 1, '/smarthome/+/temperature'); -- 允许客户端订阅包含自身 Client ID 的 /smarthome/${clientid}/temperature 主题 INSERT INTO mqtt_acl (allow, ipaddr, username, clientid, access, topic) VALUES (1, NULL, NULL, NULL, 1, '/smarthome/%c/temperature'); 启用 PostgreSQL ACL 后并以用户名 emqx 成功连接后，客户端应当数据具有相应的主题权限。 这是默认配置使用的表结构，熟悉该插件的使用后你可以使用任何满足条件的数据表进行 ACL 规则存储。 超级用户 SQL（super_query） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户 SQL，查询客户端是否为超级用户。客户端为超级用户时将跳过 ACL SQL。 # etc/plugins/emqx_auth_pgsql.conf auth.pgsql.super_query = select is_superuser from mqtt_user where username = '%u' limit 1 你可以在 SQL 中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整超级用户 SQL，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下超级用户 SQL 需要满足以下条件： 查询结果中必须包含 is_superuser 字段，is_superuser 应该显式的为 true 查询结果只能有一条，多条结果时只取第一条作为有效数据 如果不需要超级用户功能，注释并禁用该选项能有效提高效率 ACL SQL（acl_query） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户 SQL，如果没有启用超级用户 SQL 或客户端不是超级用户，则使用 ACL SQL 查询出该客户端在数据库中的 ACL 规则。 # etc/plugins/emqx_auth_pgsql.conf auth.pgsql.acl_query = select allow, ipaddr, username, clientid, access, topic from mqtt_acl where ipaddr = '%a' or username = '%u' or username = '$all' or clientid = '%c' 你可以在 ACL SQL 中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %a：客户端地址 %u：用户名 %c：Client ID 你可以根据业务需要调整 ACL SQL，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下 ACL SQL 需要满足以下条件： 查询结果中必须包含 allow、access、topic、clientid、username、ipaddr 字段，如果字段不想参与比对则使用 $all 字符串或者数据库 NULL 值 查询结果可以有多条，多条结果时按照从上到下的顺序进行匹配 可以在 SQL 中调整查询条件、指定排序方式实现更高效率的查询。 .emqxee { display: none; }"},"advanced/acl-redis.html":{"url":"advanced/acl-redis.html","title":"Redis ACL","summary":null,"keywords":"","body":"Redis ACLRedis 连接信息默认数据结构认证/超级用户ACL 规则数据超级用户查询命令（super cmd）ACL 查询命令（acl cmd）Redis ACL Redis ACL 使用外部 Redis 数据库存储 ACL 规则，可以存储大量数据、动态管理 ACL，方便与外部设备管理系统集成 插件： emqx_auth_redis emqx_auth_redis 插件同时包含认证功能，可通过注释禁用。 Redis 连接信息 Redis 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_redis.conf ## 服务器地址 auth.redis.server = 127.0.0.1:6379 ## 连接池大小 auth.redis.pool = 8 auth.redis.database = 0 auth.redis.password = 默认数据结构 Redis 认证插件默认配置下使用哈希表存储认证数据，使用 mqtt_user: 作为 Redis 键前缀，数据结构如下： 认证/超级用户 redis> hgetall mqtt_user:emqx password public salt wivwiv 默认配置下示例数据如下： HMSET mqtt_user:emqx password public salt wivwiv ACL 规则数据 ## 格式 HSET mqtt_acl:[username clientid] [topic] [access] ## 结构 redis> hgetall mqtt_acl:emqx testtopic/1 1 Redis ACL 一条规则中定义了发布、订阅或发布/订阅的信息，在规则中的都是允许列表。 规则字段说明： ipaddr：设置 IP 地址 username：连接客户端的用户名，此处的值如果设置为 $all 表示该规则适用于所有的用户 clientid：连接客户端的 Client ID access：允许的操作：订阅（1），发布（2），订阅发布都可以（3） topic：控制的主题，可以使用通配符，并且可以在主题中加入占位符来匹配客户端信息，例如 t/%c 则在匹配时主题将会替换为当前客户端的 Client ID %u：用户名 %c：Client ID 默认配置下示例数据： HSET mqtt_acl:emqx # 1 HSET mqtt_acl:testtopic/2 2 启用 Redis ACL 后并以用户名 emqx 成功连接后，客户端应当数据具有相应的主题权限。 超级用户查询命令（super cmd） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户查询命令，查询客户端是否为超级用户。客户端为超级用户时将跳过 ACL 查询命令。 # etc/plugins/emqx_auth_redis.conf auth.redis.super_cmd = HGET mqtt_user:%u is_superuser 你可以在命令中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID %C：TLS 证书公用名（证书的域名或子域名），仅当 TLS 连接时有效 %d：TLS 证书 subject，仅当 TLS 连接时有效 你可以根据业务需要调整超级用户查询命令，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下超级用户查询命令需要满足以下条件： 查询结果中第一个数据必须为 is_superuser 数据 如果不需要超级用户功能，注释并禁用该选项能有效提高效率 ACL 查询命令（acl cmd） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户 SQL，如果没有启用超级用户 SQL 或客户端不是超级用户，则使用 ACL 查询命令查询出该客户端在数据库中的 ACL 规则。 # etc/plugins/emqx_auth_redis.conf auth.redis.acl_cmd = HGETALL mqtt_acl:%u 你可以在 ACL 查询命令中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID 你可以根据业务需要调整 ACL 查询命令，但是任何情况下 ACL 查询命令需要满足以下条件： 哈希中使用 topic 作为键，access 作为值 Redis ACL 规则需严格使用上述数据结构。 Redis ACL 中添加的所有规则都是 允许 规则，可以搭配 etc/emqx.conf 中 acl_nomatch = deny 使用。 .emqxee { display: none; }"},"advanced/acl-mongodb.html":{"url":"advanced/acl-mongodb.html","title":"MongoDB ACL","summary":null,"keywords":"","body":"MongoDB ACLMongoDB 连接信息默认数据结构认证/超级集合ACL 规则集合超级用户查询（super_query）ACL 查询（acl_query）MongoDB ACL MongoDB ACL 使用外部 MongoDB 数据库存储 ACL 规则，可以存储大量数据、动态管理 ACL，方便与外部设备管理系统集成 插件： emqx_auth_mongo emqx_auth_mongo 插件同时包含认证功能，可通过注释禁用。 MongoDB 连接信息 MongoDB 基础连接信息，需要保证集群内所有节点均能访问。 # etc/plugins/emqx_auth_mongo.conf ## MongoDB 架构类型 ## ## Value: single | unknown | sharded | rs auth.mongo.type = single ## rs 模式需要设置 rs name ## auth.mongo.rs_set_name = ## 服务器列表，集群模式下使用逗号分隔每个服务器 ## Examples: 127.0.0.1:27017,127.0.0.2:27017... auth.mongo.server = 127.0.0.1:27017 auth.mongo.pool = 8 auth.mongo.login = auth.mongo.password = ## auth.mongo.auth_source = admin auth.mongo.database = mqtt auth.mongo.query_timeout = 5s ## SSL 选项 # auth.mongo.ssl = false ## auth.mongo.ssl_opts.keyfile = ## auth.mongo.ssl_opts.certfile = ## auth.mongo.ssl_opts.cacertfile = ## MongoDB write mode. ## ## Value: unsafe | safe ## auth.mongo.w_mode = ## Mongo read mode. ## ## Value: master | slave_ok ## auth.mongo.r_mode = ## MongoDB 拓扑配置，一般情况下用不到，详见 MongoDB 官网文档 auth.mongo.topology.pool_size = 1 auth.mongo.topology.max_overflow = 0 ## auth.mongo.topology.overflow_ttl = 1000 ## auth.mongo.topology.overflow_check_period = 1000 ## auth.mongo.topology.local_threshold_ms = 1000 ## auth.mongo.topology.connect_timeout_ms = 20000 ## auth.mongo.topology.socket_timeout_ms = 100 ## auth.mongo.topology.server_selection_timeout_ms = 30000 ## auth.mongo.topology.wait_queue_timeout_ms = 1000 ## auth.mongo.topology.heartbeat_frequency_ms = 10000 ## auth.mongo.topology.min_heartbeat_frequency_ms = 1000 默认数据结构 MongoDB 认证默认配置下需要确保数据库中有如下集合： 认证/超级集合 { username: \"user\", password: \"password hash\", salt: \"password salt\", is_superuser: false, created: \"2020-02-20 12:12:14\" } 示例数据： use mqtt db.mqtt_user.insert({ \"username\": \"emqx\", \"password\": \"efa1f375d76194fa51a3556a97e641e61685f914d446979da50a551a4333ffd7\", \"is_superuser\": false, \"salt\": \"\" }) ACL 规则集合 { username: \"username\", clientid: \"clientid\", publish: [\"topic1\", \"topic2\", ...], subscribe: [\"subtop1\", \"subtop2\", ...], pubsub: [\"topic/#\", \"topic1\", ...] } MongoDB ACL 一条规则中定义了发布、订阅和发布/订阅的信息，在规则中的都是允许列表。 规则字段说明： username：连接客户端的用户名 clientid：连接客户端的 Client ID publish：允许发布的主题数值，支持通配符 subscribe：允许订阅的主题数值，支持通配符 pubsub：允许发布订阅的主题数值，支持通配符 主题可以使用通配符，并且可以在主题中加入占位符来匹配客户端信息，例如 t/%c 则在匹配时主题将会替换为当前客户端的 Client ID %u：用户名 %c：Client ID 默认配置下示例数据： use mqtt ## 所有用户不可以订阅、发布系统主题 ## 允许客户端订阅包含自身 Client ID 的 /smarthome/${clientid}/temperature 主题 db.mqtt_acl.insert({ username: \"$all\", clientid: \"$all\", publish: [\"#\"], subscribe: [\"/smarthome/%c/temperature\"] }) 启用 MongoDB ACL 后并以用户名 emqx 成功连接后，客户端应当数据具有相应的主题权限。 超级用户查询（super_query） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户查询，查询客户端是否为超级用户。客户端为超级用户时将跳过 ACL 查询。 # etc/plugins/emqx_auth_mongo.conf ## 启用超级用户 auth.mongo.super_query = on ## 超级查询使用集合 auth.mongo.super_query.collection = mqtt_user ## 超级用户使用字段 auth.mongo.super_query.super_field = is_superuser ## 超级用户查询选择器，多个条件使用逗号分隔 #auth.mongo.super_query.selector = username=%u, clientid=$all auth.mongo.super_query.selector = username=%u 同一个选择器的多个条件时实际查询中使用 MongoDB and 查询： db.mqtt_user.find({ \"username\": \"wivwiv\" \"clientid\": \"$all\" }) 你可以在查询条件中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID 你可以根据业务需要调整超级用户查询，如添加多个查询条件、使用数据库预处理函数，以实现更多业务相关的功能。但是任何情况下超级用户查询需要满足以下条件： 查询结果中必须包含 is_superuser 字段，is_superuser 应该显式的为 true 如果不需要超级用户功能，注释并禁用该选项能有效提高效率 ACL 查询（acl_query） 进行 ACL 鉴权时，EMQ X 将使用当前客户端信息填充并执行用户配置的超级用户查询，如果没有启用超级用户查询或客户端不是超级用户，则使用 ACL 查询 查询出该客户端在数据库中的 ACL 规则。 # etc/plugins/emqx_auth_mongo.conf auth.mongo.acl_query = on auth.mongo.acl_query.collection = mqtt_acl ## 查询选择器，多个条件时使用逗号分隔 ## auth.mongo.acl_query.selector = username=%u,clientid=%c auth.mongo.acl_query.selector = username=%u ## 使用多个查询选择器 ## auth.mongo.acl_query.selector.1 = username=$all ## auth.mongo.acl_query.selector.2 = username=%u 同一个选择器的多个条件时实际查询中使用 MongoDB and 查询： db.mqtt_acl.find({ \"username\": \"emqx\" \"clientid\": \"$all\" }) 多个选择器时实际查询中使用 MongoDB or 查询： db.mqtt_acl.find({ \"$or\": [ { \"username\": \"$all\" }, { \"username\": \"emqx\" } ] }) 你可以在 ACL 查询中使用以下占位符，执行时 EMQ X 将自动填充为客户端信息： %u：用户名 %c：Client ID MongoDB ACL 规则需严格使用上述数据结构。 MongoDB ACL 中添加的所有规则都是 允许 规则，可以搭配 etc/emqx.conf 中 acl_nomatch = deny 使用。 .emqxee { display: none; }"},"advanced/http-api.html":{"url":"advanced/http-api.html","title":"HTTP API","keywords":"","body":"HTTP API 接口安全 响应码 HTTP 状态码 (status codes)返回码 (result codes)API Endpoints /api/v4 Broker 基本信息 节点 客户端 订阅信息 路由 消息发布 主题订阅 消息批量发布 主题批量订阅 插件 监听器 内置模块 统计指标 统计指标 状态 告警 黑名单 数据导入导出 规则 动作 资源类型 资源 HTTP API EMQ X 提供了 HTTP API 以实现与外部系统的集成，例如查询客户端信息、发布消息和创建规则等。 EMQ X 的 HTTP API 服务默认监听 8081 端口，可通过 etc/plugins/emqx_management.conf 配置文件修改监听端口，或启用 HTTPS 监听。EMQ X 4.0.0 以后的所有 API 调用均以 api/v4 开头。 接口安全 EMQ X 的 HTTP API 使用 Basic 认证 方式，id 和 password 须分别填写 AppID 和 AppSecret。 默认的 AppID 和 AppSecret 是：amdin/public。你可以在 Dashboard 的左侧菜单栏里，选择 \"管理\" -> \"应用\" 来修改和添加 AppID/AppSecret。 响应码 HTTP 状态码 (status codes) EMQ X 接口在调用成功时总是返回 200 OK，响应内容则以 JSON 格式返回。 可能的状态码如下： Status Code Description 200 成功，返回的 JSON 数据将提供更多信息 400 客户端请求无效，例如请求体或参数错误 401 客户端未通过服务端认证，使用无效的身份验证凭据可能会发生 404 找不到请求的路径或者请求的对象不存在 500 服务端处理请求时发生内部错误 返回码 (result codes) EMQ X 接口的响应消息体为 JSON 格式，其中总是包含返回码 code。 可能的返回码如下： Return Code Description 0 成功 101 RPC 错误 102 未知错误 103 用户名或密码错误 104 空用户名或密码 105 用户不存在 106 管理员账户不可删除 107 关键请求参数缺失 108 请求参数错误 109 请求参数不是合法 JSON 格式 110 插件已开启 111 插件已关闭 112 客户端不在线 113 用户已存在 114 旧密码错误 115 不合法的主题 API Endpoints /api/v4 GET /api/v4 返回 EMQ X 支持的所有 Endpoints。 Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array Endpoints 列表 - data[0].path String Endpoint - data[0].name String Endpoint 名 - data[0].method String HTTP Method - data[0].descr String 描述 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4\" {\"data\":[{\"path\":\"/auth_clientid\",\"name\":\"list_clientid\",\"method\":\"GET\",\"descr\":\"List available clientid in the cluster\"}, ...],\"code\":0} Broker 基本信息 GET /api/v4/brokers/{node} 返回集群下所有节点的基本信息。 Path Parameters: Name Type Required Description node String False 节点名字，如 \"emqx@127.0.0.1。不指定时返回所有节点的信息 Success Response Body (JSON): Name Type Description code Integer 0 data Object/Array of Objects node 参数存在时返回指定节点信息，不存在时返回所有节点的信息 data.datetime String 当前时间，格式为 \"YYYY-MM-DD HH:mm:ss\" data.node String 节点名称 data.node_status String 节点状态 data.otp_release String EMQ X 使用的 Erlang/OTP 版本 data.sysdescr String 软件描述 data.uptime String EMQ X 运行时间，格式为 \"H hours, m minutes, s seconds\" data.version String EMQ X 版本 Examples: 获取所有节点的基本信息： $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/brokers\" {\"data\":[{\"version\":\"develop\",\"uptime\":\"4 hours, 21 minutes, 19 seconds\",\"sysdescr\":\"EMQ X Broker\",\"otp_release\":\"R21/10.3.5\",\"node_status\":\"Running\",\"node\":\"emqx@127.0.0.1\",\"datetime\":\"2020-02-19 15:27:24\"}],\"code\":0} 获取节点 emqx@127.0.0.1 的基本信息： $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/brokers/emqx@127.0.0.1\" {\"data\":{\"version\":\"develop\",\"uptime\":\"1 minutes, 51 seconds\",\"sysdescr\":\"EMQ X Broker\",\"otp_release\":\"R21/10.3.5\",\"node_status\":\"Running\",\"node\":\"emqx@127.0.0.1\",\"datetime\":\"2020-02-20 14:11:31\"},\"code\":0} 节点 GET /api/v4/nodes/{node} 返回节点的状态。 Path Parameters: Name Type Required Description node String False 节点名字，如 \"emqx@127.0.0.1。不指定时返回所有节点的信息 Success Response Body (JSON): Name Type Description code Integer 0 data Object/Array of Objects node 参数存在时返回指定节点信息，不存在时以 Array 形式返回所有节点的信息 data.connections Integer 当前接入此节点的客户端数量 data.load1 String 1 分钟内的 CPU 平均负载 data.load5 String 5 分钟内的 CPU 平均负载 data.load15 String 15 分钟内的 CPU 平均负载 data.max_fds Integer 操作系统的最大文件描述符限制 data.memory_total String VM 已分配的系统内存 data.memory_used String VM 已占用的内存大小 data.node String 节点名称 data.node_status String 节点状态 data.otp_release String EMQ X 使用的 Erlang/OTP 版本 data.process_available Integer 可用的进程数量 data.process_used Integer 已占用的进程数量 data.uptime String EMQ X 运行时间 data.version String EMQ X 版本 Examples: 获取所有节点的状态： $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes\" {\"data\":[{\"version\":\"develop\",\"uptime\":\"7 seconds\",\"process_used\":315,\"process_available\":2097152,\"otp_release\":\"R21/10.3.5\",\"node_status\":\"Running\",\"node\":\"emqx@127.0.0.1\",\"memory_used\":\"96.75M\",\"memory_total\":\"118.27M\",\"max_fds\":10240,\"load5\":\"2.60\",\"load15\":\"2.65\",\"load1\":\"2.31\",\"connections\":0}],\"code\":0} 获取指定节点的状态： $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1\" {\"data\":{\"version\":\"develop\",\"uptime\":\"2 minutes, 21 seconds\",\"process_used\":310,\"process_available\":2097152,\"otp_release\":\"R21/10.3.5\",\"node_status\":\"Running\",\"node\":\"emqx@127.0.0.1\",\"memory_used\":101379168,\"memory_total\":123342848,\"max_fds\":10240,\"load5\":\"2.50\",\"load15\":\"2.61\",\"load1\":\"1.99\",\"connections\":0},\"code\":0} 客户端 GET /api/v4/clients 返回集群下所有客户端的信息，支持分页。 Query String Parameters: Name Type Required Default Description _page Integer False 1 页码 _limit Integer False 10000 每页显示的数据条数，未指定时由 emqx-management 插件的配置项 max_row_limit 决定 在 4.1 后，支持多条件和模糊查询，其包含的查询参数有： Name Type Required Description clientid String False 客户端标识符 username String False 客户端用户名 zone String False 客户端配置组名称 ip_address String False 客户端 IP 地址 conn_state Enum False 客户端当前连接状态，可取值有：connected,idle,disconnected clean_start Bool False 客户端是否使用了全新的会话 proto_name Enum False 客户端协议名称，可取值有：MQTT,CoAP,LwM2M,MQTT-SN proto_ver Integer False 客户端协议版本 _like_clientid String False 客户端标识符，子串方式模糊查找 _like_username String False 客户端用户名，子串方式模糊查找 _gte_created_at Integer False 客户端会话创建时间，小于等于查找 _lte_created_at Integer False 客户端会话创建时间，大于等于查找 _gte_connected_at Integer False 客户端连接创建时间，小于等于查找 _lte_connected_at Integer False 客户端连接创建时间，大于等于查找 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有客户端的信息 data[0].node String 客户端所连接的节点名称 data[0].clientid String 客户端标识符 data[0].username String 客户端连接时使用的用户名 data[0].proto_name String 客户端协议名称 data[0].proto_ver Integer 客户端使用的协议版本 data[0].ip_address String 客户端的 IP 地址 data[0].port Integer 客户端的端口 data[0].is_bridge Boolean 指示客户端是否通过桥接方式连接 data[0].connected_at String 客户端连接时间，格式为 \"YYYY-MM-DD HH:mm:ss\" data[0].disconnected_at String 客户端离线时间，格式为 \"YYYY-MM-DD HH:mm:ss\"，此字段仅在 connected 为 false 时有效并被返回 data[0].connected Boolean 客户端是否处于连接状态 data[0].zone String 指示客户端使用的配置组 data[0].keepalive Integer 保持连接时间，单位：秒 data[0].clean_start Boolean 指示客户端是否使用了全新的会话 data[0].expiry_interval Integer 会话过期间隔，单位：秒 data[0].created_at String 会话创建时间，格式为 \"YYYY-MM-DD HH:mm:ss\" data[0].subscriptions_cnt Integer 此客户端已建立的订阅数量 data[0].max_subscriptions Integer 此客户端允许建立的最大订阅数量 data[0].inflight Integer 飞行队列当前长度 data[0].max_inflight Integer 飞行队列最大长度 data[0].mqueue_len Integer 消息队列当前长度 data[0].max_mqueue Integer 消息队列最大长度 data[0].mqueue_dropped Integer 消息队列因超出长度而丢弃的消息数量 data[0].awaiting_rel Integer 未确认的 PUBREC 报文数量 data[0].max_awaiting_rel Integer 允许存在未确认的 PUBREC 报文的最大数量 data[0].recv_oct Integer EMQ X Broker（下同）接收的字节数量 data[0].recv_cnt Integer 接收的 TCP 报文数量 data[0].recv_pkt Integer 接收的 MQTT 报文数量 data[0].recv_msg Integer 接收的 PUBLISH 报文数量 data[0].send_oct Integer 发送的字节数量 data[0].send_cnt Integer 发送的 TCP 报文数量 data[0].send_pkt Integer 发送的 MQTT 报文数量 data[0].send_msg Integer 发送的 PUBLISH 报文数量 data[0].mailbox_len Integer 进程邮箱大小 data[0].heap_size Integer 进程堆栈大小，单位：字节 data[0].reductions Integer Erlang reduction meta Object 分页信息 meta.page Integer 页码 meta.limit Integer 每页显示的数据条数 meta.count Integer 数据总条数 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/clients?_page=1&_limit=10\" {\"meta\":{\"page\":1,\"limit\":10,\"count\":1},\"data\":[{\"zone\":\"external\",\"recv_cnt\":2,\"max_mqueue\":1000,\"node\":\"emqx@127.0.0.1\",\"username\":\"test\",\"mqueue_len\":0,\"max_inflight\":32,\"is_bridge\":false,\"mqueue_dropped\":0,\"inflight\":0,\"heap_size\":2586,\"max_subscriptions\":0,\"proto_name\":\"MQTT\",\"created_at\":\"2020-02-19 17:01:26\",\"proto_ver\":4,\"reductions\":3997,\"send_msg\":0,\"ip_address\":\"127.0.0.1\",\"send_cnt\":0,\"mailbox_len\":1,\"awaiting_rel\":0,\"keepalive\":60,\"recv_msg\":0,\"send_pkt\":0,\"recv_oct\":29,\"clientid\":\"example\",\"clean_start\":true,\"expiry_interval\":0,\"connected\":true,\"port\":64491,\"send_oct\":0,\"recv_pkt\":1,\"connected_at\":\"2020-02-19 17:01:26\",\"max_awaiting_rel\":100,\"subscriptions_cnt\":0}],\"code\":0} 注：在 4.1 后，返回的 meta 内容做了修改： count：仍表示总数，但在 多条件/模糊查询时，固定为 -1。 hasnext：为新增字段，表示是否存在下一页。 GET /api/v4/clients/{clientid} 返回指定客户端的信息 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 客户端的信息，详细请参见GET /api/v4/clients Examples: 查询指定客户端 $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/clients/example\" {\"data\":[{\"recv_cnt\":2,\"max_subscriptions\":0,\"node\":\"emqx@127.0.0.1\",\"proto_ver\":4,\"recv_pkt\":1,\"inflight\":0,\"max_mqueue\":1000,\"heap_size\":2586,\"username\":\"test\",\"proto_name\":\"MQTT\",\"subscriptions_cnt\":0,\"send_pkt\":0,\"created_at\":\"2020-02-20 13:38:51\",\"reductions\":3978,\"ip_address\":\"127.0.0.1\",\"send_msg\":0,\"send_cnt\":0,\"expiry_interval\":0,\"keepalive\":60,\"mqueue_dropped\":0,\"is_bridge\":false,\"max_inflight\":32,\"recv_msg\":0,\"max_awaiting_rel\":100,\"awaiting_rel\":0,\"mailbox_len\":1,\"mqueue_len\":0,\"recv_oct\":29,\"connected_at\":\"2020-02-20 13:38:51\",\"clean_start\":true,\"clientid\":\"example\",\"connected\":true,\"port\":54889,\"send_oct\":0,\"zone\":\"external\"}],\"code\":0} DELETE /api/v4/clients/{clientid} 踢除指定客户端。注意踢除客户端操作会将连接与会话一并终结。 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 Examples: 踢除指定客户端 $ curl -i --basic -u admin:public -X DELETE \"http://localhost:8081/api/v4/clients/example\" {\"code\":0} GET /api/v4/nodes/{node}/clients 类似 GET /api/v4/clients，返回指定节点下所有客户端的信息，支持分页。 Query String Parameters: Name Type Required Default Description _page Integer False 1 页码 _limit Integer False 10000 每页显示的数据条数，未指定时由 emqx-management 插件的配置项 max_row_limit 决定 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有客户端的信息，详情请参看 GET /api/v4/clients Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/clients?_page=1&_limit=10\" {\"meta\":{\"page\":1,\"limit\":10,\"count\":1},\"data\":[{\"recv_cnt\":2,\"max_subscriptions\":0,\"node\":\"emqx@127.0.0.1\",\"proto_ver\":4,\"recv_pkt\":1,\"inflight\":0,\"max_mqueue\":1000,\"heap_size\":2586,\"username\":\"test\",\"proto_name\":\"MQTT\",\"subscriptions_cnt\":0,\"send_pkt\":0,\"created_at\":\"2020-02-19 18:25:18\",\"reductions\":4137,\"ip_address\":\"127.0.0.1\",\"send_msg\":0,\"send_cnt\":0,\"expiry_interval\":0,\"keepalive\":60,\"mqueue_dropped\":0,\"is_bridge\":false,\"max_inflight\":32,\"recv_msg\":0,\"max_awaiting_rel\":100,\"awaiting_rel\":0,\"mailbox_len\":1,\"mqueue_len\":0,\"recv_oct\":29,\"connected_at\":\"2020-02-19 18:25:18\",\"clean_start\":true,\"clientid\":\"example\",\"connected\":true,\"port\":49509,\"send_oct\":0,\"zone\":\"external\"}],\"code\":0} GET /api/v4/nodes/{node}/clients/{clientid} 类似 GET /api/v4/clients/{clientid}，返回指定节点下指定客户端的信息。 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 data Object 客户端的信息，详细请参见GET /api/v4/clients Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/clients/example\" {\"data\":[{\"recv_cnt\":4,\"max_subscriptions\":0,\"node\":\"emqx@127.0.0.1\",\"proto_ver\":4,\"recv_pkt\":1,\"inflight\":0,\"max_mqueue\":1000,\"heap_size\":2586,\"username\":\"test\",\"proto_name\":\"MQTT\",\"subscriptions_cnt\":0,\"send_pkt\":3,\"created_at\":\"2020-02-20 13:38:51\",\"reductions\":5994,\"ip_address\":\"127.0.0.1\",\"send_msg\":0,\"send_cnt\":3,\"expiry_interval\":0,\"keepalive\":60,\"mqueue_dropped\":0,\"is_bridge\":false,\"max_inflight\":32,\"recv_msg\":0,\"max_awaiting_rel\":100,\"awaiting_rel\":0,\"mailbox_len\":0,\"mqueue_len\":0,\"recv_oct\":33,\"connected_at\":\"2020-02-20 13:38:51\",\"clean_start\":true,\"clientid\":\"example\",\"connected\":true,\"port\":54889,\"send_oct\":8,\"zone\":\"external\"}],\"code\":0} DELETE /api/v4/nodes/{node}/clients/{clientid} 类似 DELETE /api/v4/clients/{clientid}，踢除指定节点下的指定客户端。 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 Examples: $ curl -i --basic -u admin:public -X DELETE \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/clients/example\" {\"code\":0} GET /api/v4/clients/username/{username} 通过 Username 查询客户端的信息。由于可能存在多个客户端使用相同的用户名的情况，所以可能同时返回多个客户端信息。 Path Parameters: Name Type Required Description username String True Username Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 客户端的信息，详细请参见GET /api/v4/clients Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/clients/username/steve\" {\"data\":[{\"clean_start\":true,\"awaiting_rel\":0,\"recv_msg\":0,\"proto_name\":\"MQTT\",\"recv_cnt\":2,\"mailbox_len\":0,\"node\":\"emqx@127.0.0.1\",\"mqueue_len\":0,\"max_subscriptions\":0,\"created_at\":\"2020-02-20 13:50:11\",\"is_bridge\":false,\"heap_size\":2586,\"proto_ver\":4,\"subscriptions_cnt\":0,\"clientid\":\"example\",\"expiry_interval\":0,\"send_msg\":0,\"inflight\":0,\"reductions\":4673,\"send_pkt\":1,\"zone\":\"external\",\"send_cnt\":1,\"ip_address\":\"127.0.0.1\",\"keepalive\":60,\"max_inflight\":32,\"recv_oct\":29,\"recv_pkt\":1,\"max_awaiting_rel\":100,\"username\":\"steve\",\"connected_at\":\"2020-02-20 13:50:11\",\"connected\":true,\"port\":56429,\"send_oct\":4,\"mqueue_dropped\":0,\"max_mqueue\":1000}],\"code\":0} GET /api/v4/nodes/{node}/clients/username/{username} 类似 GET /api/v4/clients/username/{username}，在指定节点下，通过 Username 查询指定客户端的信息。 Path Parameters: Name Type Required Description username String True Username Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 客户端的信息，详细请参见GET /api/v4/clients Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/clients/username/test\" {\"data\":[{\"clean_start\":true,\"awaiting_rel\":0,\"recv_msg\":0,\"proto_name\":\"MQTT\",\"recv_cnt\":6,\"mailbox_len\":0,\"node\":\"emqx@127.0.0.1\",\"mqueue_len\":0,\"max_subscriptions\":0,\"created_at\":\"2020-02-20 13:50:11\",\"is_bridge\":false,\"heap_size\":1598,\"proto_ver\":4,\"subscriptions_cnt\":0,\"clientid\":\"example\",\"expiry_interval\":0,\"send_msg\":0,\"inflight\":0,\"reductions\":7615,\"send_pkt\":5,\"zone\":\"external\",\"send_cnt\":5,\"ip_address\":\"127.0.0.1\",\"keepalive\":60,\"max_inflight\":32,\"recv_oct\":37,\"recv_pkt\":1,\"max_awaiting_rel\":100,\"username\":\"test\",\"connected_at\":\"2020-02-20 13:50:11\",\"connected\":true,\"port\":56429,\"send_oct\":12,\"mqueue_dropped\":0,\"max_mqueue\":1000}],\"code\":0} GET /api/v4/clients/{clientid}/acl_cache 查询指定客户端的 ACL 缓存。 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects ACL 详情 data[0].access String 发布/订阅 data[0].topic String MQTT 主题 data[0].result String 允许/拒绝 data[0].updated_time Integer ACL 缓存建立时间 Examples: 查询 ACL 缓存 $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/clients/example/acl_cache\" {\"data\":[{\"updated_time\":1582180824571,\"topic\":\"test\",\"result\":\"allow\",\"access\":\"publish\"}],\"code\":0} DELETE /api/v4/clients/{clientid}/acl_cache 清除指定客户端的 ACL 缓存。 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 Examples: 清除 ACL 缓存 $ curl -i --basic -u admin:public -X DELETE \"http://localhost:8081/api/v4/clients/example/acl_cache\" {\"code\":0} 订阅信息 GET /api/v4/subscriptions 返回集群下所有订阅信息，支持分页机制。 Query String Parameters: Name Type Required Default Description _page Integer False 1 页码 _limit Integer False 10000 每页显示的数据条数，未指定时由 emqx-management 插件的配置项 max_row_limit 决定 在 4.1 版本后，支持多条件和模糊查询： | Name | Type | Description | | ------------ | ------- | ----------- | | clientid | String | 客户端标识符 | | topic | String | 主题，全等查询 | | qos | Enum | 可取值为：0,1,2 | | share | String | 共享订阅的组名称 | | _match_topic | String | 主题，匹配查询 | Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有订阅信息 data[0].node String 节点名称 data[0].clientid String 客户端标识符 data[0].topic String 订阅主题 data[0].qos Integer QoS 等级 meta Object 同 /api/v4/clients Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/subscriptions?_page=1&_limit=10\" {\"meta\":{\"page\":1,\"limit\":10000,\"count\":2},\"data\":[{\"topic\":\"a/+/c\",\"qos\":0,\"node\":\"emqx@127.0.0.1\",\"clientid\":\"78082755-e8eb-4a87-bab7-8277541513f0\"},{\"topic\":\"a/b/c\",\"qos\":1,\"node\":\"emqx@127.0.0.1\",\"clientid\":\"7a1dfceb-89c0-4f7e-992b-dfeb09329f01\"}],\"code\":0} 注：在 4.1 后，返回的 meta 内容做了修改： count：仍表示总数，但在 多条件/模糊查询 时，固定为 -1。 hasnext：为新增字段，表示是否存在下一页。 GET /api/v4/subscriptions/{clientid} 返回集群下指定客户端的订阅信息。 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 data Object 所有订阅信息 data.node String 节点名称 data.clientid String 客户端标识符 data.topic String 订阅主题 data.qos Integer QoS 等级 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/subscriptions/123\" {\"data\":[{\"topic\":\"a/b/c\",\"qos\":1,\"node\":\"emqx@127.0.0.1\",\"clientid\":\"123\"}],\"code\":0} GET /api/v4/nodes/{node}/subscriptions 类似 GET /api/v4/subscriptions，返回指定节点下的所有订阅信息，支持分页机制。 Query String Parameters: Name Type Required Default Description _page Integer False 1 页码 _limit Integer False 10000 每页显示的数据条数，未指定时由 emqx-management 插件的配置项 max_row_limit 决定 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有订阅信息 data[0].node String 节点名称 data[0].clientid String 客户端标识符 data[0].topic String 订阅主题 data[0].qos Integer QoS 等级 meta Object 同 /api/v4/clients Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/subscriptions?_page=1&limit=10\" {\"meta\":{\"page\":1,\"limit\":10000,\"count\":2},\"data\":[{\"topic\":\"a/+/c\",\"qos\":0,\"node\":\"emqx@127.0.0.1\",\"clientid\":\"78082755-e8eb-4a87-bab7-8277541513f0\"},{\"topic\":\"a/b/c\",\"qos\":1,\"node\":\"emqx@127.0.0.1\",\"clientid\":\"7a1dfceb-89c0-4f7e-992b-dfeb09329f01\"}],\"code\":0} GET /api/v4/nodes/{node}/subscriptions/{clientid} 类似 GET /api/v4/subscriptions/{clientid}，在指定节点下，查询某 clientid 的所有订阅信息，支持分页机制。 Path Parameters: Name Type Required Description clientid String True ClientID Success Response Body (JSON): Name Type Description code Integer 0 data Object 所有订阅信息 data.node String 节点名称 data.clientid String 客户端标识符 data.topic String 订阅主题 data.qos Integer QoS 等级 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/subscriptions/sample\" {\"data\":[{\"topic\":\"a/+/c\",\"qos\":0,\"node\":\"emqx@127.0.0.1\",\"clientid\":\"sample\"}],\"code\":0} 路由 GET /api/v4/routes 返回集群下的所有路由信息，支持分页机制。 Query String Parameters: Name Type Required Default Description _page Integer False 1 页码 _limit Integer False 10000 每页显示的数据条数，未指定时由 emqx-management 插件的配置项 max_row_limit 决定 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有路由信息 data[0].topic String MQTT 主题 data[0].node String 节点名称 meta Object 同 /api/v4/clients Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/routes\" {\"meta\":{\"page\":1,\"limit\":10000,\"count\":2},\"data\":[{\"topic\":\"a/+/c\",\"node\":\"emqx@127.0.0.1\"},{\"topic\":\"a/b/c\",\"node\":\"emqx@127.0.0.1\"}],\"code\":0} GET /api/v4/routes/{topic} 返回集群下指定主题的路由信息。 Path Parameters: Name Type Required Description topic Integer True 主题 Success Response Body (JSON): Name Type Description code Integer 0 data Object 所有路由信息 data.topic String MQTT 主题 data.node String 节点名称 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/routes/a%2fb%2fc\" {\"data\":[{\"topic\":\"a/b/c\",\"node\":\"emqx@127.0.0.1\"}],\"code\":0} 消息发布 POST /api/v4/mqtt/publish 发布 MQTT 消息。 Parameters (json): Name Type Required Default Description topic String Optional 主题，与 topics 至少指定其中之一 topics String Optional 以 , 分割的多个主题，使用此字段能够同时发布消息到多个主题 clientid String Required 客户端标识符 payload String Required 消息正文 encoding String Optional plain 消息正文使用的编码方式，目前仅支持 plain 与 base64 两种 qos Integer Optional 0 QoS 等级 retain Boolean Optional false 是否为保留消息 Success Response Body (JSON): Name Type Description code Integer 0 Examples: $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/mqtt/publish\" -d '{\"topic\":\"a/b/c\",\"payload\":\"Hello World\",\"qos\":1,\"retain\":false,\"clientid\":\"example\"}' {\"code\":0} 主题订阅 POST /api/v4/mqtt/subscribe 订阅 MQTT 主题。 Parameters (json): Name Type Required Default Description topic String Optional 主题，与 topics 至少指定其中之一 topics String Optional 以 , 分割的多个主题，使用此字段能够同时订阅多个主题 clientid String Required 客户端标识符 qos Integer Optional 0 QoS 等级 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 同时订阅 a, b, c 三个主题 $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/mqtt/subscribe\" -d '{\"topics\":\"a,b,c\",\"qos\":1,\"clientid\":\"example\"}' {\"code\":0} POST /api/v4/mqtt/unsubscribe 取消订阅。 Parameters (json): Name Type Required Default Description topic String Required 主题 clientid String Required 客户端标识符 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 取消订阅 a 主题 $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/mqtt/unsubscribe\" -d '{\"topic\":\"a\",\"qos\":1,\"clientid\":\"example\"}' {\"code\":0} 消息批量发布 POST /api/v4/mqtt/publish_batch 批量发布 MQTT 消息。 Parameters (json): Name Type Required Default Description [0].topic String Optional 主题，与 topics 至少指定其中之一 [0].topics String Optional 以 , 分割的多个主题，使用此字段能够同时发布消息到多个主题 [0].clientid String Required 客户端标识符 [0].payload String Required 消息正文 [0].encoding String Optional plain 消息正文使用的编码方式，目前仅支持 plain 与 base64 两种 [0].qos Integer Optional 0 QoS 等级 [0].retain Boolean Optional false 是否为保留消息 Success Response Body (JSON): Name Type Description code Integer 0 Examples: $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/mqtt/publish_batch\" -d '[{\"topic\":\"a/b/c\",\"payload\":\"Hello World\",\"qos\":1,\"retain\":false,\"clientid\":\"example\"},{\"topic\":\"a/b/c\",\"payload\":\"Hello World Again\",\"qos\":0,\"retain\":false,\"clientid\":\"example\"}]' {\"code\":0} 主题批量订阅 POST /api/v4/mqtt/subscribe_batch 批量订阅 MQTT 主题。 Parameters (json): Name Type Required Default Description [0].topic String Optional 主题，与 topics 至少指定其中之一 [0].topics String Optional 以 , 分割的多个主题，使用此字段能够同时订阅多个主题 [0].clientid String Required 客户端标识符 [0].qos Integer Optional 0 QoS 等级 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 一次性订阅 a, b, c 三个主题 $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/mqtt/subscribe_batch\" -d '[{\"topic\":\"a\",\"qos\":1,\"clientid\":\"example\"},{\"topic\":\"b\",\"qos\":1,\"clientid\":\"example\"},{\"topic\":\"c\",\"qos\":1,\"clientid\":\"example\"}]' {\"code\":0} POST /api/v4/mqtt/unsubscribe_batch 批量取消订阅。 Parameters (json): Name Type Required Default Description [0].topic String Required 主题 [0].clientid String Required 客户端标识符 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 一次性取消订阅 a, b 主题 $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/mqtt/unsubscribe_batch\" -d '[{\"topic\":\"a\",\"qos\":1,\"clientid\":\"example\"},{\"topic\":\"b\",\"qos\":1,\"clientid\":\"example\"}]' {\"code\":0} 插件 GET /api/v4/plugins 返回集群下的所有插件信息。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有路由信息 data[0].node String 节点名称 data[0].plugins Array 插件信息，由对象组成的数组，见下文 data[0].plugins.name String 插件名称 data[0].plugins.version String 插件版本 data[0].plugins.description String 插件描述 data[0].plugins.active Boolean 插件是否启动 data[0].plugins.type String 插件类型，目前有auth、bridge、feature、protocol 四种类型 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/plugins\" {\"data\":[{\"plugins\":[{\"version\":\"develop\",\"type\":\"auth\",\"name\":\"emqx_auth_clientid\",\"description\":\"EMQ X Authentication with ClientId/Password\",\"active\":false}, ...],\"node\":\"emqx@127.0.0.1\"}],\"code\":0} GET /api/v4/nodes/{node}/plugins 类似 GET /api/v4/plugins，返回指定节点下的插件信息。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有路由信息 data[0].name String 插件名称 data[0].version String 插件版本 data[0].description String 插件描述 data[0].active Boolean 插件是否启动 data[0].type String 插件类型，目前有auth、bridge、feature、protocol 四种类型 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/plugins\" {\"data\":[{\"version\":\"develop\",\"type\":\"auth\",\"name\":\"emqx_auth_clientid\",\"description\":\"EMQ X Authentication with ClientId/Password\",\"active\":false}, ...],\"code\":0} PUT /api/v4/nodes/{node}/plugins/{plugin}/load 加载指定节点下的指定插件。 Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 Examples: $ curl -i --basic -u admin:public -X PUT \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/plugins/emqx_delayed_publish/load\" {\"code\":0} PUT /api/v4/nodes/{node}/plugins/{plugin}/unload 卸载指定节点下的指定插件。 Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 Examples: $ curl -i --basic -u admin:public -X PUT \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/plugins/emqx_delayed_publish/unload\" {\"code\":0} PUT /api/v4/nodes/{node}/plugins/{plugin}/reload 重新加载指定节点下的指定插件。 Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 Examples: $ curl -i --basic -u admin:public -X PUT \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/plugins/emqx_delayed_publish/reload\" {\"code\":0} 监听器 GET /api/v4/listeners 返回集群下的所有监听器信息。 Path Parameters: 无 Success Response Body (JSON):** Name Type Description code Integer 0 data Array of Objects 各节点的监听器列表 data[0].node String 节点名称 data[0].listeners Array of Objects 监听器列表 data[0].listeners[0].acceptors Integer Acceptor 进程数量 data[0].listeners[0].listen_on String 监听端口 data[0].listeners[0].protocol String 插件描述 data[0].listeners[0].current_conns Integer 插件是否启动 data[0].listeners[0].max_conns Integer 允许建立的最大连接数量 data[0].listeners[0].shutdown_count Array of Objects 连接关闭原因及计数 常见 shutdown_count Name Type Description normal Integer 正常关闭的连接数量，仅在计数大于 0 时返回 kicked Integer 被手动踢除的连接数量，仅在计数大于 0 时返回 discarded Integer 由于 Clean Session 或 Clean Start 为 true 而被丢弃的连接数量 takeovered Integer 由于 Clean Session 或 Clean Start 为 false 而被接管的连接数量 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/listeners\" {\"data\":[{\"node\":\"emqx@127.0.0.1\",\"listeners\":[{\"shutdown_count\":[],\"protocol\":\"mqtt:ssl\",\"max_conns\":102400,\"listen_on\":\"8883\",\"current_conns\":0,\"acceptors\":16},{\"shutdown_count\":[],\"protocol\":\"mqtt:tcp\",\"max_conns\":1024000,\"listen_on\":\"0.0.0.0:1883\",\"current_conns\":13,\"acceptors\":8},{\"shutdown_count\":[],\"protocol\":\"mqtt:tcp\",\"max_conns\":1024000,\"listen_on\":\"127.0.0.1:11883\",\"current_conns\":0,\"acceptors\":4},{\"shutdown_count\":[],\"protocol\":\"http:dashboard\",\"max_conns\":512,\"listen_on\":\"18083\",\"current_conns\":0,\"acceptors\":4},{\"shutdown_count\":[],\"protocol\":\"http:management\",\"max_conns\":512,\"listen_on\":\"8081\",\"current_conns\":1,\"acceptors\":2},{\"shutdown_count\":[],\"protocol\":\"https:dashboard\",\"max_conns\":512,\"listen_on\":\"18084\",\"current_conns\":0,\"acceptors\":2},{\"shutdown_count\":[],\"protocol\":\"mqtt:ws:8083\",\"max_conns\":102400,\"listen_on\":\"8083\",\"current_conns\":1,\"acceptors\":4},{\"shutdown_count\":[],\"protocol\":\"mqtt:wss:8084\",\"max_conns\":16,\"listen_on\":\"8084\",\"current_conns\":0,\"acceptors\":4}]}],\"code\":0} GET /api/v4/nodes/{node}/listeners 类似 GET /api/v4/listeners，返回指定节点的监听器信息。 Path Parameters: 无 Success Response Body (JSON):** Name Type Description code Integer 0 data Array of Objects 各节点的监听器列表 data[0].acceptors Integer Acceptor 进程数量 data[0].listen_on String 监听端口 data[0].protocol String 插件描述 data[0].current_conns Integer 插件是否启动 data[0].max_conns Integer 允许建立的最大连接数量 data[0].shutdown_count Array of Objects 连接关闭原因及计数 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/listeners\" {\"data\":[{\"shutdown_count\":[],\"protocol\":\"mqtt:ssl\",\"max_conns\":102400,\"listen_on\":\"8883\",\"current_conns\":0,\"acceptors\":16},{\"shutdown_count\":[],\"protocol\":\"mqtt:tcp\",\"max_conns\":1024000,\"listen_on\":\"0.0.0.0:1883\",\"current_conns\":13,\"acceptors\":8},{\"shutdown_count\":[],\"protocol\":\"mqtt:tcp\",\"max_conns\":1024000,\"listen_on\":\"127.0.0.1:11883\",\"current_conns\":0,\"acceptors\":4},{\"shutdown_count\":[],\"protocol\":\"http:dashboard\",\"max_conns\":512,\"listen_on\":\"18083\",\"current_conns\":0,\"acceptors\":4},{\"shutdown_count\":[],\"protocol\":\"http:management\",\"max_conns\":512,\"listen_on\":\"8081\",\"current_conns\":1,\"acceptors\":2},{\"shutdown_count\":[],\"protocol\":\"https:dashboard\",\"max_conns\":512,\"listen_on\":\"18084\",\"current_conns\":0,\"acceptors\":2},{\"shutdown_count\":[],\"protocol\":\"mqtt:ws:8083\",\"max_conns\":102400,\"listen_on\":\"8083\",\"current_conns\":1,\"acceptors\":4},{\"shutdown_count\":[],\"protocol\":\"mqtt:wss:8084\",\"max_conns\":16,\"listen_on\":\"8084\",\"current_conns\":0,\"acceptors\":4}],\"code\":0} 内置模块 GET /api/v4/modules 返回集群下所有内置模块信息。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 各节点上的内置模块列表 data[0].node String 节点名称 data[0].modules Object 内置模块信息列表，详见下面的 modules: modules: Name Type Description name String 模块名 description String 模块功能描述 active Boolean 是否处于活跃状态（是否正在运行） Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/modules\" {\"data\":[{\"node\":\"emqx@127.0.0.1\",\"modules\":[{\"name\":\"emqx_mod_delayed\",\"description\":\"EMQ X Delayed Publish Module\",\"active\":true},{\"name\":\"emqx_mod_topic_metrics\",\"description\":\"EMQ X Topic Metrics Module\",\"active\":false},{\"name\":\"emqx_mod_subscription\",\"description\":\"EMQ X Subscription Module\",\"active\":false},{\"name\":\"emqx_mod_acl_internal\",\"description\":\"EMQ X Internal ACL Module\",\"active\":true},{\"name\":\"emqx_mod_rewrite\",\"description\":\"EMQ X Topic Rewrite Module\",\"active\":false},{\"name\":\"emqx_mod_presence\",\"description\":\"EMQ X Presence Module\",\"active\":true}]}],\"code\":0} GET /api/v4/nodes/{node}/modules 类似 GET /api/v4/modules，返回指定节点下所有内置模块信息。 PUT /api/v4/modules/{module}/load 加载集群下所有节点的指定内置模块。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 message String 仅在发生错误时返回，用于提供更详细的错误信息 $ curl -i --basic -u admin:public -X PUT \"http://localhost:8081/api/v4/modules/emqx_mod_topic_metrics/load\" {\"code\":0} PUT /api/v4/nodes/{node}/modules/{module}/load 类似 PUT /api/v4/modules/{module}/load，加载指定节点下的指定内置模块。 PUT /api/v4/modules/{module}/unload 卸载集群下所有节点的指定内置模块。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 message String 仅在发生错误时返回，用于提供更详细的错误信息 $ curl -i --basic -u admin:public -X PUT \"http://localhost:8081/api/v4/modules/emqx_mod_topic_metrics/unload\" {\"code\":0} PUT /api/v4/nodes/{node}/modules/{module}/unload 类似 PUT /api/v4/modules/{module}/unload，卸载指定节点下的指定内置模块。 PUT /api/v4/modules/{module}/reload 重新加载集群下所有节点的指定内置模块，仅为 emqx_mod_acl_internal 提供此功能。 Name Type Description code Integer 0 message String 仅在发生错误时返回，用于提供更详细的错误信息 $ curl -i --basic -u admin:public -X PUT \"http://localhost:8081/api/v4/modules/emqx_mod_acl_internal/reload\" {\"code\":0} PUT /api/v4/nodes/{node}/modules/{module}/reload 类似 PUT /api/v4/modules/{module}/reload，重新加载指定节点下的指定内置模块，仅为 emqx_mod_acl_internal 提供此功能。 统计指标 GET /api/v4/metrics 返回集群下所有统计指标数据。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 各节点上的统计指标列表 data[0].node String 节点名称 data[0].metrics Object 监控指标数据，详见下面的 metrics： metrics： Name Type Description actions.failure Integer 规则引擎 action 成功失败次数 actions.success Integer 规则引擎 action 执行失败次数 bytes.received Integer EMQ X 接收的字节数 bytes.sent Integer EMQ X 在此连接上发送的字节数 client.authenticate Integer 客户端认证次数 client.auth.anonymous Integer 匿名登录的客户端数量 client.connect Integer 客户端连接次数 client.connack Integer 发送 CONNACK 报文的次数 client.connected Integer 客户端成功连接次数 client.disconnected Integer 客户端断开连接次数 client.check_acl Integer ACL 规则检查次数 client.subscribe Integer 客户端订阅次数 client.unsubscribe Integer 客户端取消订阅次数 delivery.dropped.too_large Integer 发送时由于长度超过限制而被丢弃的消息数量 delivery.dropped.queue_full Integer 发送时由于消息队列满而被丢弃的 QoS 不为 0 的消息数量 delivery.dropped.qos0_msg Integer 发送时由于消息队列满而被丢弃的 QoS 为 0 的消息数量 delivery.dropped.expired Integer 发送时由于消息过期而被丢弃的消息数量 delivery.dropped.no_local Integer 发送时由于 No Local 订阅选项而被丢弃的消息数量 delivery.dropped Integer 发送时丢弃的消息总数 messages.delayed Integer EMQ X 存储的延迟发布的消息数量 messages.delivered Integer EMQ X 内部转发到订阅进程的消息数量 messages.dropped Integer EMQ X 内部转发到订阅进程前丢弃的消息总数 messages.dropped.expired Integer 接收时由于消息过期而被丢弃的消息数量 messages.dropped.no_subscribers Integer 由于没有订阅者而被丢弃的消息数量 messages.forward Integer 向其他节点转发的消息数量 messages.publish Integer 除系统消息外发布的消息数量 messages.qos0.received Integer 接收来自客户端的 QoS 0 消息数量 messages.qos2.received Integer 接收来自客户端的 QoS 1 消息数量 messages.qos1.received Integer 接收来自客户端的 QoS 2 消息数量 messages.qos0.sent Integer 发送给客户端的 QoS 0 消息数量 messages.qos1.sent Integer 发送给客户端的 QoS 1 消息数量 messages.qos2.sent Integer 发送给客户端的 QoS 2 消息数量 messages.received Integer 接收来自客户端的消息数量，等于 messages.qos0.received，messages.qos1.received 与 messages.qos2.received 之和 messages.sent Integer 发送给客户端的消息数量，等于 messages.qos0.sent，messages.qos1.sent 与 messages.qos2.sent 之和 messages.retained Integer EMQ X 存储的保留消息数量 messages.acked Integer 接收的 PUBACK 和 PUBREC 报文数量 packets.received Integer 接收的报文数量 packets.sent Integer 发送的报文数量 packets.connect.received Integer 接收的 CONNECT 报文数量 packets.connack.auth_error Integer 接收的认证失败的 CONNECT 报文数量 packets.connack.error Integer 接收的未成功连接的 CONNECT 报文数量 packets.connack.sent Integer 发送的 CONNACK 报文数量 packets.publish.received Integer 接收的 PUBLISH 报文数量 packets.publish.sent Integer 发送的 PUBLISH 报文数量 packets.publish.inuse Integer 接收的报文标识符已被占用的 PUBLISH 报文数量 packets.publish.auth_error Integer 接收的未通过 ACL 检查的 PUBLISH 报文数量 packets.publish.error Integer 接收的无法被发布的 PUBLISH 报文数量 packets.publish.dropped Integer 超出接收限制而被丢弃的消息数量 packets.puback.received Integer 接收的 PUBACK 报文数量 packets.puback.sent Integer 发送的 PUBACK 报文数量 packets.puback.inuse Integer 接收的报文标识符已被占用的 PUBACK 报文数量 packets.puback.missed Integer 接收的未知报文标识符 PUBACK 报文数量 packets.pubrec.received Integer 接收的 PUBREC 报文数量 packets.pubrec.sent Integer 发送的 PUBREC 报文数量 packets.pubrec.inuse Integer 接收的报文标识符已被占用的 PUBREC 报文数量 packets.pubrec.missed Integer 接收的未知报文标识符 PUBREC 报文数量 packets.pubrel.received Integer 接收的 PUBREL 报文数量 packets.pubrel.sent Integer 发送的 PUBREL 报文数量 packets.pubrel.missed Integer 接收的未知报文标识符 PUBREL 报文数量 packets.pubcomp.received Integer 接收的 PUBCOMP 报文数量 packets.pubcomp.sent Integer 发送的 PUBCOMP 报文数量 packets.pubcomp.inuse Integer 接收的报文标识符已被占用的 PUBCOMP 报文数量 packets.pubcomp.missed Integer 发送的 PUBCOMP 报文数量 packets.subscribe.received Integer 接收的 SUBSCRIBE 报文数量 packets.subscribe.error Integer 接收的订阅失败的 SUBSCRIBE 报文数量 packets.subscribe.auth_error Integer 接收的未通过 ACL 检查的 SUBACK 报文数量 packets.suback.sent Integer 发送的 SUBACK 报文数量 packets.unsubscribe.received Integer 接收的 UNSUBSCRIBE 报文数量 packets.unsubscribe.error Integer 接收的取消订阅失败的 UNSUBSCRIBE 报文数量 packets.unsuback.sent Integer 发送的 UNSUBACK 报文数量 packets.pingreq.received Integer 接收的 PINGREQ 报文数量 packets.pingresp.sent Integer 发送的 PUBRESP 报文数量 packets.disconnect.received Integer 接收的 DISCONNECT 报文数量 packets.disconnect.sent Integer 发送的 DISCONNECT 报文数量 packets.auth.received Integer 接收的 AUTH 报文数量 packets.auth.sent Integer 发送的 AUTH 报文数量 rules.matched Integer 规则的匹配次数 session.created Integer 创建的会话数量 session.discarded Integer 由于 Clean Session 或 Clean Start 为 true 而被丢弃的会话数量 session.resumed Integer 由于 Clean Session 或 Clean Start 为 false 而恢复的会话数量 session.takeovered Integer 由于 Clean Session 或 Clean Start 为 false 而被接管的会话数量 session.terminated Integer 终结的会话数量 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/metrics\" {\"data\":[{\"node\":\"emqx@127.0.0.1\",\"metrics\":{\"messages.dropped.no_subscribers\":0,\"packets.connack.sent\":13,\"bytes.received\":805,\"messages.received\":0,\"packets.unsuback.sent\":0,\"messages.delivered\":0,\"client.disconnected\":0,\"packets.puback.sent\":0,\"packets.subscribe.auth_error\":0,\"delivery.dropped.queue_full\":0,\"messages.forward\":0,\"delivery.dropped.qos0_msg\":0,\"delivery.dropped.expired\":0,\"bytes.sent\":52,\"messages.sent\":0,\"delivery.dropped.no_local\":0,\"packets.pubrec.received\":0,\"packets.pubcomp.received\":0,\"client.check_acl\":0,\"packets.puback.received\":0,\"session.takeovered\":0,\"messages.dropped.expired\":0,\"actions.success\":0,\"messages.qos1.sent\":0,\"messages.retained\":0,\"packets.pubcomp.inuse\":0,\"packets.pubrec.sent\":0,\"packets.received\":13,\"messages.acked\":0,\"session.terminated\":0,\"packets.sent\":13,\"packets.unsubscribe.error\":0,\"client.connect\":13,\"packets.pubrec.missed\":0,\"packets.auth.sent\":0,\"packets.disconnect.received\":0,\"messages.qos2.sent\":0,\"client.auth.anonymous\":13,\"packets.auth.received\":0,\"packets.unsubscribe.received\":0,\"packets.publish.auth_error\":0,\"client.connected\":13,\"rules.matched\":0,\"packets.disconnect.sent\":0,\"session.created\":13,\"packets.pingreq.received\":0,\"messages.dropped\":0,\"actions.failure\":0,\"packets.publish.sent\":0,\"session.resumed\":0,\"packets.connack.auth_error\":0,\"packets.pubrel.sent\":0,\"delivery.dropped\":0,\"packets.pubcomp.sent\":0,\"messages.qos2.received\":0,\"messages.qos0.received\":0,\"packets.publish.inuse\":0,\"client.unsubscribe\":0,\"packets.pubrel.received\":0,\"client.connack\":13,\"packets.connack.error\":0,\"packets.publish.dropped\":0,\"packets.publish.received\":0,\"client.subscribe\":0,\"packets.subscribe.error\":0,\"packets.suback.sent\":0,\"packets.pubcomp.missed\":0,\"messages.qos1.received\":0,\"delivery.dropped.too_large\":0,\"packets.pingresp.sent\":0,\"packets.pubrel.missed\":0,\"messages.qos0.sent\":0,\"packets.connect.received\":13,\"packets.puback.missed\":0,\"packets.subscribe.received\":0,\"packets.puback.inuse\":0,\"client.authenticate\":13,\"messages.publish\":0,\"packets.pubrec.inuse\":0,\"packets.publish.error\":0,\"messages.delayed\":0,\"session.discarded\":0}}],\"code\":0} GET /api/v4/nodes/{node}/metrics 类似 GET /api/v4/metrics，返回指定节点下所有监控指标数据。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Object 各节点上的统计指标列表，详见 GET /api/v4/metrics Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/metrics\" {\"data\":{\"bytes.received\":0,\"client.connected\":0,\"packets.pingreq.received\":0,\"messages.delayed\":0,\"rules.matched\":0,\"actions.failure\":0,\"packets.puback.sent\":0,\"packets.pingresp.sent\":0,\"packets.publish.auth_error\":0,\"client.check_acl\":0,\"delivery.dropped.queue_full\":0,\"actions.success\":0,\"packets.publish.error\":0,\"packets.pubcomp.received\":0,\"bytes.sent\":0,\"packets.pubrec.inuse\":0,\"packets.pubrec.missed\":0,\"packets.pubrel.sent\":0,\"delivery.dropped.too_large\":0,\"packets.pubcomp.missed\":0,\"packets.subscribe.error\":0,\"packets.suback.sent\":0,\"messages.qos2.sent\":0,\"messages.qos1.sent\":0,\"packets.pubrel.missed\":0,\"messages.publish\":0,\"messages.forward\":0,\"packets.auth.received\":0,\"delivery.dropped\":0,\"packets.sent\":0,\"packets.puback.inuse\":0,\"delivery.dropped.qos0_msg\":0,\"packets.publish.dropped\":0,\"packets.disconnect.sent\":0,\"packets.auth.sent\":0,\"packets.unsubscribe.received\":0,\"session.takeovered\":0,\"messages.delivered\":0,\"client.auth.anonymous\":0,\"packets.connack.error\":0,\"packets.connack.sent\":0,\"packets.subscribe.auth_error\":0,\"packets.unsuback.sent\":0,\"packets.pubcomp.sent\":0,\"packets.publish.sent\":0,\"client.connack\":0,\"packets.publish.received\":0,\"client.subscribe\":0,\"session.created\":0,\"delivery.dropped.expired\":0,\"client.unsubscribe\":0,\"packets.received\":0,\"packets.pubrel.received\":0,\"packets.unsubscribe.error\":0,\"messages.qos0.sent\":0,\"packets.connack.auth_error\":0,\"session.resumed\":0,\"delivery.dropped.no_local\":0,\"packets.puback.missed\":0,\"packets.pubcomp.inuse\":0,\"packets.pubrec.sent\":0,\"messages.dropped.expired\":0,\"messages.dropped.no_subscribers\":0,\"session.discarded\":0,\"messages.sent\":0,\"messages.received\":0,\"packets.puback.received\":0,\"messages.qos0.received\":0,\"messages.acked\":0,\"client.connect\":0,\"packets.disconnect.received\":0,\"client.disconnected\":0,\"messages.retained\":3,\"session.terminated\":0,\"packets.publish.inuse\":0,\"packets.pubrec.received\":0,\"messages.qos2.received\":0,\"messages.dropped\":0,\"packets.connect.received\":0,\"client.authenticate\":0,\"packets.subscribe.received\":0,\"messages.qos1.received\":0},\"code\":0} 统计指标 GET /api/v4/topic-metrics 返回所有主题统计指标数据。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 各节点上的统计指标列表 data[0].topic String 主题名 data[0].metrics Object 主题统计指标数据，详见下面的 metrics: metrics: Name Type Description messages.qos2.out.rate Integer QoS 2 消息 5 秒内平均发送速率 messages.qos2.out.count Integer QoS 2 消息发送数量统计 messages.qos2.in.rate Integer QoS 2 消息 5 秒内平均接收速率 messages.qos2.in.count Integer QoS 2 消息接收数量统计 messages.qos1.out.rate Integer QoS 1 消息 5 秒内平均发送速率 messages.qos1.out.count Integer QoS 1 消息发送数量统计 messages.qos1.in.rate Integer QoS 1 消息 5 秒内平均接收速率 messages.qos1.in.count Integer QoS 1 消息接收数量统计 messages.qos0.out.rate Integer QoS 0 消息 5 秒内平均发送速率 messages.qos0.out.count Integer QoS 0 消息发送数量统计 messages.qos0.in.rate Integer QoS 0 消息 5 秒内平均接收速率 messages.qos0.in.count Integer QoS 0 消息接收数量统计 messages.out.rate Integer MQTT 消息 5 秒内平均发送速率 messages.out.count Integer MQTT 消息发送数量统计 messages.in.rate Integer MQTT 消息 5 秒内平均接收速率 messages.in.count Integer MQTT 消息接收数量统计 messages.dropped.rate Integer MQTT 消息 5 秒内平均丢弃速率 messages.dropped.count Integer MQTT 消息丢弃数量统计 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/topic-metrics\" {\"data\":[],\"code\":0} $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/topic-metrics\" -d '{\"topic\":\"a/b/c\"}' {\"code\":0} $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/topic-metrics\" {\"data\":[{\"topic\":\"a/b/c\",\"metrics\":{\"messages.qos2.out.rate\":0.0,\"messages.qos2.out.count\":0,\"messages.qos2.in.rate\":0.0,\"messages.qos2.in.count\":0,\"messages.qos1.out.rate\":0.0,\"messages.qos1.out.count\":0,\"messages.qos1.in.rate\":0.0,\"messages.qos1.in.count\":0,\"messages.qos0.out.rate\":0.0,\"messages.qos0.out.count\":0,\"messages.qos0.in.rate\":0.0,\"messages.qos0.in.count\":0,\"messages.out.rate\":0.0,\"messages.out.count\":0,\"messages.in.rate\":0.0,\"messages.in.count\":0,\"messages.dropped.rate\":0.0,\"messages.dropped.count\":0}}],\"code\":0} GET /api/v4/topic-metrics/{topic} 返回指定主题的统计指标数据。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Object 主题统计指标数据，详见下面的 data: data: Name Type Description messages.qos2.out.rate Integer QoS 2 消息 5 秒内平均发送速率 messages.qos2.out.count Integer QoS 2 消息发送数量统计 messages.qos2.in.rate Integer QoS 2 消息 5 秒内平均接收速率 messages.qos2.in.count Integer QoS 2 消息接收数量统计 messages.qos1.out.rate Integer QoS 1 消息 5 秒内平均发送速率 messages.qos1.out.count Integer QoS 1 消息发送数量统计 messages.qos1.in.rate Integer QoS 1 消息 5 秒内平均接收速率 messages.qos1.in.count Integer QoS 1 消息接收数量统计 messages.qos0.out.rate Integer QoS 0 消息 5 秒内平均发送速率 messages.qos0.out.count Integer QoS 0 消息发送数量统计 messages.qos0.in.rate Integer QoS 0 消息 5 秒内平均接收速率 messages.qos0.in.count Integer QoS 0 消息接收数量统计 messages.out.rate Integer MQTT 消息 5 秒内平均发送速率 messages.out.count Integer MQTT 消息发送数量统计 messages.in.rate Integer MQTT 消息 5 秒内平均接收速率 messages.in.count Integer MQTT 消息接收数量统计 messages.dropped.rate Integer MQTT 消息 5 秒内平均丢弃速率 messages.dropped.count Integer MQTT 消息丢弃数量统计 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/topic-metrics/a%2Fb%2Fc\" {\"data\":{\"messages.qos2.out.rate\":0.0,\"messages.qos2.out.count\":0,\"messages.qos2.in.rate\":0.0,\"messages.qos2.in.count\":0,\"messages.qos1.out.rate\":0.0,\"messages.qos1.out.count\":0,\"messages.qos1.in.rate\":0.0,\"messages.qos1.in.count\":0,\"messages.qos0.out.rate\":0.0,\"messages.qos0.out.count\":0,\"messages.qos0.in.rate\":0.0,\"messages.qos0.in.count\":0,\"messages.out.rate\":0.0,\"messages.out.count\":0,\"messages.in.rate\":0.0,\"messages.in.count\":0,\"messages.dropped.rate\":0.0,\"messages.dropped.count\":0},\"code\":0} POST /api/v4/topic-metrics 开启对指定主题的指标统计。 Parameters (json): Name Type Required Default Description topic String Required MQTT 主题名 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 开启对 a/b/c 主题的指标统计 $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/topic-metrics\" -d '{\"topic\":\"a/b/c\"}' {\"code\":0} DELETE /api/v4/topic-metrics/{topic} 关闭对指定主题的指标统计。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 关闭对 a/b/c 主题的指标统计 $ curl -i --basic -u admin:public -X DELETE \"http://localhost:8081/api/v4/topic-metrics/a%2Fb%2Fc\" {\"code\":0} DELETE /api/v4/topic-metrics 关闭所有主题的指标统计。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 关闭所有主题的指标统计 $ curl -i --basic -u admin:public -X DELETE \"http://localhost:8081/api/v4/topic-metrics\" {\"code\":0} 状态 GET /api/v4/stats 返回集群下所有状态数据。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 各节点上的状态数据列表 data[0].node String 节点名称 data[0].stats Array 状态数据，详见下面的 stats stats： Name Type Description connections.count Integer 当前连接数量 connections.max Integer 连接数量的历史最大值 channels.count Integer 即 sessions.count channels.max Integer 即 session.max sessions.count Integer 当前会话数量 sessions.max Integer 会话数量的历史最大值 topics.count Integer 当前主题数量 topics.max Integer 主题数量的历史最大值 suboptions.count Integer 即 subscriptions.count suboptions.max Integer 即 subscriptions.max subscribers.count Integer 当前订阅者数量 subscribers.max Integer 订阅者数量的历史最大值 subscriptions.count Integer 当前订阅数量，包含共享订阅 subscriptions.max Integer 订阅数量的历史最大值 subscriptions.shared.count Integer 当前共享订阅数量 subscriptions.shared.max Integer 共享订阅数量的历史最大值 routes.count Integer 当前路由数量 routes.max Integer 路由数量的历史最大值 retained.count Integer 当前保留消息数量 retained.max Integer 保留消息的历史最大值 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/stats\" {\"data\":[{\"stats\":{\"topics.max\":0,\"topics.count\":0,\"subscriptions.shared.max\":0,\"subscriptions.shared.count\":0,\"subscriptions.max\":0,\"subscriptions.count\":0,\"subscribers.max\":0,\"subscribers.count\":0,\"suboptions.max\":0,\"suboptions.count\":0,\"sessions.max\":0,\"sessions.count\":0,\"rules.max\":0,\"rules.count\":0,\"routes.max\":0,\"routes.count\":0,\"retained.max\":3,\"retained.count\":3,\"resources.max\":0,\"resources.count\":0,\"connections.max\":0,\"connections.count\":0,\"channels.max\":0,\"channels.count\":0,\"actions.max\":5,\"actions.count\":5},\"node\":\"emqx@127.0.0.1\"}],\"code\":0} GET /api/v4/nodes/{node}/stats 类似 GET /api/v4/stats，返回指定节点上的有状态数据。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 各节点上的状态数据列表，详见 GET /api/v4/stats Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/nodes/emqx@127.0.0.1/stats\" {\"data\":{\"topics.max\":0,\"topics.count\":0,\"subscriptions.shared.max\":0,\"subscriptions.shared.count\":0,\"subscriptions.max\":0,\"subscriptions.count\":0,\"subscribers.max\":0,\"subscribers.count\":0,\"suboptions.max\":0,\"suboptions.count\":0,\"sessions.max\":0,\"sessions.count\":0,\"rules.max\":0,\"rules.count\":0,\"routes.max\":0,\"routes.count\":0,\"retained.max\":3,\"retained.count\":3,\"resources.max\":0,\"resources.count\":0,\"connections.max\":0,\"connections.count\":0,\"channels.max\":0,\"channels.count\":0,\"actions.max\":5,\"actions.count\":5},\"code\":0} 告警 GET /api/v4/alarms/present 返回集群下当前告警信息。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 各节点上的告警列表 data[0].node String 节点名称 data[0].alarms Array of Objects 当前告警列表 data[0].alarms[0].id String 告警标识符 data[0].alarms[0].desc String 告警的详细描述 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/alarms/present\" {\"data\":[{\"node\":\"emqx@127.0.0.1\",\"alarms\":[{\"id\":\"cpu_high_watermark\",\"desc\":\"88.30833333333334\"}]}],\"code\":0} GET /api/v4/alarms/present/{node} 返回指定节点下当前告警信息。接口参数和返回请参看 GET /api/v4/stats。 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/alarms/present/emqx@127.0.0.1\" {\"data\":[{\"id\":\"cpu_high_watermark\",\"desc\":\"91.68333333333332\"}],\"code\":0} GET /api/v4/alarms/history 返回集群下历史告警信息。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 各节点上的告警列表 data[0].node String 节点名称 data[0].alarms Array of Objects 当前告警列表 data[0].alarms[0].id String 告警标识符 data[0].alarms[0].desc String 告警的详细描述 data[0].alarms[0].clear_at String 告警清除时间，格式为 \"YYYY-MM-DD HH:mm:ss\" Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/alarms/history\" {\"data\":[{\"node\":\"emqx@127.0.0.1\",\"alarms\":[{\"id\":\"cpu_high_watermark\",\"desc\":\"93.27055293970582\",\"clear_at\":\"2020-02-21 13:50:10\"}]}],\"code\":0} GET /api/v4/alarms/history/{node} 返回指定节点下历史告警信息。接口参数和返回请参看 GET /api/v4/alarms/history。 Examples: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/alarms/history/emqx@127.0.0.1\" {\"data\":[{\"id\":\"cpu_high_watermark\",\"desc\":\"93.27055293970582\",\"clear_at\":\"2020-02-21 13:50:10\"}],\"code\":0} 黑名单 GET /api/v4/banned 获取黑名单 Query String Parameters: 同 /api/v4/clients。 Success Response Body (JSON): Name Type Description code Integer 0 data Array 由对象构成的数组，对象中的字段与 POST 方法中的 Request Body 相同 meta Object 同 /api/v4/clients Examples: 获取黑名单列表: $ curl -i --basic -u admin:public -vX GET \"http://localhost:8081/api/v4/banned\" {\"meta\":{\"page\":1,\"limit\":10000,\"count\":1},\"data\":[{\"who\":\"example\",\"until\":1582265833,\"reason\":\"undefined\",\"by\":\"user\",\"at\":1582265533,\"as\":\"clientid\"}],\"code\":0} POST /api/v4/banned 将对象添加至黑名单 Parameters (json): Name Type Required Default Description who String Required 添加至黑名单的对象，可以是客户端标识符、用户名和 IP 地址 as String Required 用于区分黑名单对象类型，可以是 clientid，username，peerhost by String Optional user 指示该对象被谁添加至黑名单 at Integer Optional 当前系统时间 添加至黑名单的时间，单位：秒 until Integer Optional 当前系统时间 + 5 分钟 何时从黑名单中解除，单位：秒 Success Response Body (JSON): Name Type Description code Integer 0 data Object 与传入的 Request Body 相同 Examples: 将 client 添加到黑名单: $ curl -i --basic -u admin:public -vX POST \"http://localhost:8081/api/v4/banned\" -d '{\"who\":\"example\",\"as\":\"clientid\"}' {\"data\":{\"who\":\"example\",\"as\":\"clientid\"},\"code\":0} DELETE /api/v4/banned/{as}/{who} 将对象从黑名单中删除 Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 message String 仅在发生错误时返回，用于提供更详细的错误信息 Examples: 将 client 从黑名单中移除: $ curl -i --basic -u admin:public -X DELETE \"http://localhost:8081/api/v4/banned/clientid/example\" {\"code\":0} 数据导入导出 数据导入导出。 GET /api/v4/data/export 获取当前的导出文件信息列表，包括文件名、大小和创建时间。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Array of Objects 所有路由信息 data[0].filename String 文件名 data[0].created_at String \"YYYY-MM-DD HH-mm-SS\" 格式的文件创建时间 data[0].size String 文件大小，单位：字节 Examples: 列出当前的导出文件信息列表: $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/data/export\" {\"data\":[{\"size\":350,\"filename\":\"emqx-export-2020-5-15-18-6-29.json\",\"created_at\":\"2020-5-15 18:6:29\"},{\"size\":388,\"filename\":\"emqx-export-2020-5-15-17-39-0.json\",\"created_at\":\"2020-5-15 17:39:0\"}],\"code\":0} POST /api/v4/data/export 导出当前数据到文件。 Path Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 data Object 文件信息 data.filename String 文件名 data.created_at String \"YYYY-MM-DD HH-mm-SS\" 格式的文件创建时间 data.size String 文件大小，单位：字节 Examples: 导出文件： $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/data/export\" {\"data\":{\"size\":350,\"filename\":\"emqx-export-2020-5-18-17-17-44.json\",\"created_at\":\"2020-5-18 17:17:44\"},\"code\":0} POST /api/v4/data/import 从指定文件导入数据。 Path Parameters: 无 Parameters (json): Name Type Required Default Description filename String Required 导入的文件名 Success Response Body (JSON): Name Type Description code Integer 0 message String 仅在发生错误时返回，用于提供更详细的错误信息 Examples: 从指定文件导入数据： $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/data/import\" -d '{\"filename\":\"emqx-export-2020-5-18-17-17-44.json\"}' {\"code\":0} GET /api/v4/data/file/{filename} 下载数据文件。 Path Parameters: 无 Parameters (json): Name Type Required Default Description filename String Required 导入的文件名 Success Response Body (JSON): Name Type Description filename String 文件名 file String 文件内容 Examples: 下载指定的数据文件： $ curl -i --basic -u admin:public -X GET \"http://localhost:8081/api/v4/data/file/emqx-export-2020-5-18-17-17-44.json\" {\"filename\":\"/Users/zhouzibo/emqx-rel/_build/emqx/rel/emqx/data/emqx-export-2020-5-18-17-17-44.json\",\"file\":\"{\\\"version\\\":\\\"dev\\\",\\\"users\\\":[{\\\"username\\\":\\\"admin\\\",\\\"tags\\\":\\\"administrator\\\",\\\"password\\\":\\\"oKQPB1hbigv6+2ntALELNOb1fF0=\\\"}],\\\"schemas\\\":[],\\\"rules\\\":[],\\\"resources\\\":[],\\\"date\\\":\\\"2020-05-18 17:17:44\\\",\\\"blacklist\\\":[],\\\"auth_mnesia\\\":[],\\\"apps\\\":[{\\\"status\\\":true,\\\"secret\\\":\\\"public\\\",\\\"name\\\":\\\"Default\\\",\\\"id\\\":\\\"admin\\\",\\\"expired\\\":\\\"undefined\\\",\\\"desc\\\":\\\"Application user\\\"}],\\\"acl_mnesia\\\":[]}\"} POST /api/v4/data/file 上传数据文件。 Path Parameters: 无 Parameters (json): Name Type Required Default Description filename String Required 文件名 file String Required 文件内容 Success Response Body (JSON): Name Type Description code Integer 0 message String 仅在发生错误时返回，用于提供更详细的错误信息 Examples: 上传指定的数据文件： $ curl -i --basic -u admin:public -X POST \"http://localhost:8081/api/v4/data/file\" -d '{\"filename\":\"emqx-export-2020-5-18-17-17-44.json\",\"file\":\"{\\\"version\\\":\\\"dev\\\",\\\"users\\\":[{\\\"username\\\":\\\"admin\\\",\\\"tags\\\":\\\"administrator\\\",\\\"password\\\":\\\"oKQPB1hbigv6+2ntALELNOb1fF0=\\\"}],\\\"schemas\\\":[],\\\"rules\\\":[],\\\"resources\\\":[],\\\"date\\\":\\\"2020-05-18 17:17:44\\\",\\\"blacklist\\\":[],\\\"auth_mnesia\\\":[],\\\"apps\\\":[{\\\"status\\\":true,\\\"secret\\\":\\\"public\\\",\\\"name\\\":\\\"Default\\\",\\\"id\\\":\\\"admin\\\",\\\"expired\\\":\\\"undefined\\\",\\\"desc\\\":\\\"Application user\\\"}],\\\"acl_mnesia\\\":[]}\"}' {\"code\":0} DELETE /api/v4/data/file/{filename} 远程删除数据文件。 Path Parameters: 无 Parameters (json): Name Type Required Default Description filename String Required 文件名 Success Response Body (JSON): Name Type Description code Integer 0 message String 仅在发生错误时返回，用于提供更详细的错误信息 Examples: 删除指定的数据文件： $ curl -i --basic -u admin:public -X DELETE \"http://localhost:8081/api/v4/data/file/emqx-export-2020-5-18-17-17-44.json\" {\"code\":0} 规则 查询规则引擎的动作 GET /api/v4/rules/{rule_id} 获取某个规则的详情，包括规则的 SQL、Topics 列表、动作列表等。还会返回当前规则和动作的统计指标的值。 Path Parameters: Name Type Required Description rule_id String False 可选，Rule ID。如不指定 rule_id 则以数组形式返回所有已创建的规则 Success Response Body (JSON): Name Type Description code Integer 0 data Object 规则对象 - data.id String Rule ID - data.rawsql String SQL 语句，与请求中的 rawsql 一致 - data.for String Topic 列表，表示哪些 topic 可以匹配到此规则 - data.metrics Array 统计指标，具体可参看 Dashboard 上的 Rule Metrics - data.description String 规则的描述信息，与请求中的 description 一致 - data.actions Array 动作列表 - data.actions[0].id String Action ID - data.actions[0].params Object 动作参数，与请求中的 actions.params 一致 - data.actions[0].name String 动作名字，与请求中的 actions.name 一致 - data.actions[0].metrics Array 统计指标，具体可参看 Dashboard 上的 Rule Metrics POST /api/v4/rules 创建规则，返回规则 ID。 Parameters (json): Name Type Required Description rawsql String True 规则的 SQL 语句 actions Array True 动作列表 - actions[0].name String True 动作名称 - actions[0].params Object True 动作参数。参数以 key-value 形式表示。详情可参看添加规则的示例 description String False 可选，规则描述 Success Response Body (JSON): Name Type Description code Integer 0 data Object 创建成功的规则对象，包含 Rule ID - data.id String Rule ID - data.rawsql String SQL 语句，与请求中的 rawsql 一致 - data.for String Topic 列表，表示哪些 topic 可以匹配到此规则 - data.metrics Array 统计指标，具体可参看 Dashboard 上的 Rule Metrics - data.description String 规则的描述信息，与请求中的 description 一致 - data.actions Array 动作列表，每个动作是一个 Object - data.actions[0].id String Action ID - data.actions[0].params Object 动作参数，与请求中的 actions.params 一致 - data.actions[0].name String 动作名字，与请求中的 actions.name 一致 - data.actions[0].metrics Array 统计指标，具体可参看 Dashboard 上的 Rule Metrics PUT /api/v4/rules/{rule_id} 更新规则，返回规则 ID。 Parameters (json): Name Type Required Description rawsql String True 可选，规则的 SQL 语句 actions Array True 可选，动作列表 - actions[0].name String True 可选，动作名称 - actions[0].params Object True 可选，动作参数。参数以 key-value 形式表示。详情可参看添加规则的示例 description String False 可选，规则描述 Success Response Body (JSON): Name Type Description code Integer 0 data Object 创建成功的规则对象，包含 Rule ID - data.id String Rule ID - data.rawsql String SQL 语句，与请求中的 rawsql 一致 - data.for String Topic 列表，表示哪些 topic 可以匹配到此规则 - data.metrics Array 统计指标，具体可参看 Dashboard 上的 Rule Metrics - data.description String 规则的描述信息，与请求中的 description 一致 - data.actions Array 动作列表，每个动作是一个 Object - data.actions[0].id String Action ID - data.actions[0].params Object 动作参数，与请求中的 actions.params 一致 - data.actions[0].name String 动作名字，与请求中的 actions.name 一致 - data.actions[0].metrics Array 统计指标，具体可参看 Dashboard 上的 Rule Metrics DELETE /api/v4/rules/{rule_id} 删除规则。 Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 添加一个规则，对于所有匹配到主题 \"t/a\" 的消息，打印其规则运行参数。 $ curl -XPOST -d '{ \"rawsql\": \"select * from \\\"t/a\\\"\", \"actions\": [{ \"name\": \"inspect\", \"params\": { \"a\": 1 } }], \"description\": \"test-rule\" }' --basic -u admin:public 'http://localhost:8081/api/v4/rules' {\"data\":{\"rawsql\":\"select * from \\\"t/a\\\"\",\"metrics\":[{\"speed_max\":0,\"speed_last5m\":0.0,\"speed\":0.0,\"node\":\"emqx@127.0.0.1\",\"matched\":0}],\"id\":\"rule:7fdb2c9e\",\"for\":[\"t/a\"],\"enabled\":true,\"description\":\"test-rule\",\"actions\":[{\"params\":{\"a\":1},\"name\":\"inspect\",\"metrics\":[{\"success\":0,\"node\":\"emqx@127.0.0.1\",\"failed\":0}],\"id\":\"inspect_1582434715354188116\"}]},\"code\":0} 使用规则 ID 获取刚才创建的规则详情: $ curl --basic -u admin:public 'http://localhost:8081/api/v4/rules/rule:7fdb2c9e' {\"data\":{\"rawsql\":\"select * from \\\"t/a\\\"\",\"metrics\":[{\"speed_max\":0,\"speed_last5m\":0.0,\"speed\":0.0,\"node\":\"emqx@127.0.0.1\",\"matched\":0}],\"id\":\"rule:7fdb2c9e\",\"for\":[\"t/a\"],\"enabled\":true,\"description\":\"test-rule\",\"actions\":[{\"params\":{\"a\":1},\"name\":\"inspect\",\"metrics\":[{\"success\":0,\"node\":\"emqx@127.0.0.1\",\"failed\":0}],\"id\":\"inspect_1582434715354188116\"}]},\"code\":0} 获取所有的规则，注意返回值里的 data 是个规则对象的数组: $ curl --basic -u admin:public 'http://localhost:8081/api/v4/rules' {\"data\":[{\"rawsql\":\"select * from \\\"t/a\\\"\",\"metrics\":[{\"speed_max\":0,\"speed_last5m\":0.0,\"speed\":0.0,\"node\":\"emqx@127.0.0.1\",\"matched\":0}],\"id\":\"rule:7fdb2c9e\",\"for\":[\"t/a\"],\"enabled\":true,\"description\":\"test-rule\",\"actions\":[{\"params\":{\"a\":1},\"name\":\"inspect\",\"metrics\":[{\"success\":0,\"node\":\"emqx@127.0.0.1\",\"failed\":0}],\"id\":\"inspect_1582434715354188116\"}]}],\"code\":0} 更新一下规则的 SQL 语句，改为 select * from \"t/b\": $ curl -XPUT --basic -u admin:public 'http://localhost:8081/api/v4/rules/rule:7fdb2c9e' -d '{\"rawsql\":\"select * from \\\"t/b\\\"\"}' {\"data\":{\"rawsql\":\"select * from \\\"t/b\\\"\",\"metrics\":[{\"speed_max\":0,\"speed_last5m\":0.0,\"speed\":0.0,\"node\":\"emqx@127.0.0.1\",\"matched\":0}],\"id\":\"rule:7fdb2c9e\",\"for\":[\"t/a\"],\"enabled\":true,\"description\":\"test-rule\",\"actions\":[{\"params\":{\"a\":1},\"name\":\"inspect\",\"metrics\":[{\"success\":0,\"node\":\"emqx@127.0.0.1\",\"failed\":0}],\"id\":\"inspect_1582434715354188116\"}]},\"code\":0} 停用规则 (disable): $ curl -XPUT --basic -u admin:public 'http://localhost:8081/api/v4/rules/rule:7fdb2c9e' -d '{\"enabled\": false}' {\"data\":{\"rawsql\":\"select * from \\\"t/b\\\"\",\"metrics\":[{\"speed_max\":0,\"speed_last5m\":0.0,\"speed\":0.0,\"node\":\"emqx@127.0.0.1\",\"matched\":0}],\"id\":\"rule:7fdb2c9e\",\"for\":[\"t/a\"],\"enabled\":false,\"description\":\"test-rule\",\"actions\":[{\"params\":{\"a\":1},\"name\":\"inspect\",\"metrics\":[{\"success\":0,\"node\":\"emqx@127.0.0.1\",\"failed\":0}],\"id\":\"inspect_1582434715354188116\"}]},\"code\":0} 删除规则: $ curl -XDELETE --basic -u admin:public 'http://localhost:8081/api/v4/rules/rule:7fdb2c9e' {\"code\":0} 动作 查询规则引擎的动作。注意动作只能由 emqx 提供，不能添加。 GET api/v4/actions/{action_name} 获取某个动作的详情，包括动作名字、参数列表等。 Path Parameters: Name Type Required Description action_name String False 可选，动作名。如不指定 action_name 则以数组形式返回当前支持的所有动作。 Success Response Body (JSON): Name Type Description code Integer 0 data Object 规则对象 - data.types String 指示当前动作从属于那些资源类型 - data.title Object 动作的简述，中英文。 - data.params Object 动作的参数列表。参数以 key-value 形式表示。详情可参看后面的示例 - data.description Object 动作的描述信息，中英文。 - data.app String 动作的提供者 Examples: 查询 inspect 动作的详情： $ curl --basic -u admin:public 'http://localhost:8081/api/v4/actions/inspect' {\"data\":{\"types\":[],\"title\":{\"zh\":\"检查 (调试)\",\"en\":\"Inspect (debug)\"},\"params\":{},\"name\":\"inspect\",\"for\":\"$any\",\"description\":{\"zh\":\"检查动作参数 (用以调试)\",\"en\":\"Inspect the details of action params for debug purpose\"},\"app\":\"emqx_rule_engine\"},\"code\":0} 查询当前所有的动作： $ curl --basic -u admin:public 'http://localhost:8081/api/v4/actions' {\"data\":[{\"types\":[],\"title\":{\"zh\":\"空动作 (调试)\",\"en\":\"Do Nothing (debug)\"},\"params\":{},\"name\":\"do_nothing\",\"for\":\"$any\",\"description\":{\"zh\":\"此动作什么都不做，并且不会失败 (用以调试)\",\"en\":\"This action does nothing and never fails. It's for debug purpose\"},\"app\":\"emqx_rule_engine\"}, ...],\"code\":0} 资源类型 查询规则引擎的资源类型。注意资源类型只能由 emqx 提供，不能添加。 GET api/v4/resource_types/{resource_type_name} 获取某个动作的详情，包括动作名字、参数列表等。 Path Parameters: Name Type Required Description resource_type_name String False 可选，资源类型名。如不指定 resource_type_name 则以数组形式返回当前支持的所有资源类型。 Success Response Body (JSON): Name Type Description code Integer 0 data Object 规则对象 - data.title Object 资源类型的简述，中英文。 - data.params Object 资源类型的参数列表。参数以 key-value 形式表示。详情可参看后面的示例 - data.description Object 资源类型的描述信息，中英文。 - data.provider String 资源类型的提供者 Examples: 查询 web_hook 资源类型的详细信息： $ curl --basic -u admin:public 'http://localhost:8081/api/v4/resource_types/web_hook' {\"data\":{\"title\":{\"zh\":\"WebHook\",\"en\":\"WebHook\"},\"provider\":\"emqx_web_hook\",\"params\":{\"url\":{\"type\":\"string\",\"title\":{\"zh\":\"请求 URL\",\"en\":\"Request URL\"},\"required\":true,\"format\":\"url\",\"description\":{\"zh\":\"请求 URL\",\"en\":\"Request URL\"}},\"method\":{\"type\":\"string\",\"title\":{\"zh\":\"请求方法\",\"en\":\"Request Method\"},\"enum\":[\"PUT\",\"POST\"],\"description\":{\"zh\":\"请求方法\",\"en\":\"Request Method\"},\"default\":\"POST\"},\"headers\":{\"type\":\"object\",\"title\":{\"zh\":\"请求头\",\"en\":\"Request Header\"},\"schema\":{},\"description\":{\"zh\":\"请求头\",\"en\":\"Request Header\"},\"default\":{}}},\"name\":\"web_hook\",\"description\":{\"zh\":\"WebHook\",\"en\":\"WebHook\"}},\"code\":0} 查询当前所有的资源类型： $ curl --basic -u admin:public 'http://localhost:8081/api/v4/resource_types' {\"data\":[{\"title\":{\"zh\":\"WebHook\",\"en\":\"WebHook\"},\"provider\":\"emqx_web_hook\",\"params\":{\"url\":{\"type\":\"string\",\"title\":{\"zh\":\"请求 URL\",\"en\":\"Request URL\"},\"required\":true,\"format\":\"url\",\"description\":{\"zh\":\"请求 URL\",\"en\":\"Request URL\"}},\"method\":{\"type\":\"string\",\"title\":{\"zh\":\"请求方法\",\"en\":\"Request Method\"},\"enum\":[\"PUT\",\"POST\"],\"description\":{\"zh\":\"请求方法\",\"en\":\"Request Method\"},\"default\":\"POST\"},\"headers\":{\"type\":\"object\",\"title\":{\"zh\":\"请求头\",\"en\":\"Request Header\"},\"schema\":{},\"description\":{\"zh\":\"请求头\",\"en\":\"Request Header\"},\"default\":{}}},\"name\":\"web_hook\",\"description\":{\"zh\":\"WebHook\",\"en\":\"WebHook\"}}, ...],\"code\":0} 资源 管理规则引擎的资源。资源是资源类型的实例，用于维护数据库连接等相关资源。 GET api/v4/resources/{resource_id} 获取指定的资源的详细信息。 Path Parameters: Name Type Required Description resource_id String False 可选，资源类型 ID。如不指定 resource_id 则以数组形式返回当前所有的资源。 Success Response Body (JSON): Name Type Description code Integer 0 data Object 规则对象 - data.id String 资源 ID - data.type String 资源所从属的资源类型的名字。 - data.config Object 资源的配置。参数以 key-value 形式表示。详情可参看后面的示例 - data.status Array 资源的状态信息。详情请参看 Dashboard 上资源的状态。 - data.description Object 资源的描述信息，中英文。 POST /api/v4/resources 创建规则，返回资源 ID。 Parameters (json): Name Type Required Description type String True 资源类型名。指定要使用哪个资源类型创建资源。 config Object True 资源参数。要跟对应的资源类型的 params 里指定的格式相一致。 description String False 可选，资源描述 Success Response Body (JSON): Name Type Description code Integer 0 data Object 规则对象 - data.id String 资源 ID - data.type String 资源所从属的资源类型的名字。 - data.config Object 资源的配置。参数以 key-value 形式表示。详情可参看后面的示例 - data.description Object 资源的描述信息，中英文。 DELETE /api/v4/resources/{resource_id} 删除资源。 Parameters: 无 Success Response Body (JSON): Name Type Description code Integer 0 Examples: 创建一个 webhook 资源，webserver 的 URL 为 http://127.0.0.1:9910 ： $ curl -XPOST -d '{ \"type\": \"web_hook\", \"config\": { \"url\": \"http://127.0.0.1:9910\", \"headers\": {\"token\":\"axfw34y235wrq234t4ersgw4t\"}, \"method\": \"POST\" }, \"description\": \"web hook resource-1\" }' --basic -u admin:public 'http://localhost:8081/api/v4/resources' {\"data\":{\"type\":\"web_hook\",\"id\":\"resource:b12d3e44\",\"description\":\"web hook resource-1\",\"config\":{\"url\":\"http://127.0.0.1:9910\",\"method\":\"POST\",\"headers\":{\"token\":\"axfw34y235wrq234t4ersgw4t\"}}},\"code\":0} 使用资源 ID 查询刚创建的资源： $ curl --basic -u admin:public 'http://localhost:8081/api/v4/resources/resource:b12d3e44' {\"data\":{\"type\":\"web_hook\",\"status\":[{\"node\":\"emqx@127.0.0.1\",\"is_alive\":false}],\"id\":\"resource:b12d3e44\",\"description\":\"web hook resource-1\",\"config\":{\"url\":\"http://127.0.0.1:9910\",\"method\":\"POST\",\"headers\":{\"token\":\"axfw34y235wrq234t4ersgw4t\"}}},\"code\":0} 查询当前已创建的所有的资源： $ curl --basic -u admin:public 'http://localhost:8081/api/v4/resources' {\"data\":[{\"type\":\"web_hook\",\"id\":\"resource:b12d3e44\",\"description\":\"web hook resource-1\",\"config\":{\"url\":\"http://127.0.0.1:9910\",\"method\":\"POST\",\"headers\":{\"token\":\"axfw34y235wrq234t4ersgw4t\"}}}],\"code\":0} 删除资源: $ curl -XDELETE --basic -u admin:public 'http://localhost:8081/api/v4/resources/resource:b12d3e44' {\"code\":0} .emqxee { display: none; }"},"rule/rule-engine.html":{"url":"rule/rule-engine.html","title":"规则引擎","summary":null,"keywords":"","body":"规则引擎消息发布事件触发最小规则规则引擎典型应用场景举例迁移指南规则引擎组成SQL 语句 SQL 语法 事件和事件主题 SQL 语句示例: FROM 子句可用的事件主题 SELECT 和 WHERE 子句可用的字段 SQL 关键字和符号 SQL 语句中可用的函数 在 Dashboard 中测试 SQL 语句 规则引擎 EMQ X Rule Engine (以下简称规则引擎) 用于配置 EMQ X 消息流与设备事件的处理、响应规则。规则引擎不仅提供了清晰、灵活的 \"配置式\" 的业务集成方案，简化了业务开发流程，提升用户易用性，降低业务系统与 EMQ X 的耦合度；也为 EMQ X 的私有功能定制提供了一个更优秀的基础架构。 EMQ X 在 消息发布或事件触发 时将触发规则引擎，满足触发条件的规则将执行各自的 SQL 语句筛选并处理消息和事件的上下文信息。 适用版本: EMQ X v3.1.0+ 兼容提示: EMQ X v4.0 对规则引擎 SQL 语法做出较大调整，v3.x 升级用户请参照 迁移指南 进行适配。 消息发布 规则引擎借助响应动作可将特定主题的消息处理结果存储到数据库，发送到 HTTP Server，转发到消息队列 Kafka 或 RabbitMQ，重新发布到新的主题甚至是另一个 Broker 集群中，每个规则可以配置多个响应动作。 选择发布到 t/# 主题的消息，并筛选出全部字段： SELECT * FROM \"t/#\" 选择发布到 t/a 主题的消息，并从 JSON 格式的消息内容中筛选出 \"x\" 字段： SELECT payload.x as x FROM \"t/a\" 事件触发 规则引擎使用 $events/ 开头的虚拟主题（事件主题）处理 EMQ X 内置事件，内置事件提供更精细的消息控制和客户端动作处理能力，可用在 QoS 1 QoS 2 的消息抵达记录、设备上下线记录等业务中。 选择客户端连接事件，筛选 Username 为 'emqx' 的设备并获取连接信息： SELECT clientid, connected_at FROM \"$events/client_connected\" WHERE username = 'emqx' 规则引擎数据和 SQL 语句格式，事件主题 列表详细教程参见 SQL 手册。 最小规则 规则描述了 数据从哪里来、如何筛选并处理数据、处理结果到哪里去 三个配置，即一条可用的规则包含三个要素： 触发事件：规则通过事件触发，触发时事件给规则注入事件的上下文信息（数据源），通过 SQL 的 FROM 子句指定事件类型； 处理规则（SQL）：使用 SELECT 子句 和 WHERE 子句以及内置处理函数， 从上下文信息中过滤和处理数据； 响应动作：如果有处理结果输出，规则将执行相应的动作，如持久化到数据库、重新发布处理后的消息、转发消息到消息队列等。一条规则可以配置多个响应动作。 如图所示是一条简单的规则，该条规则用于处理 消息发布 时的数据，将全部主题消息的 msg 字段，消息 topic 、qos 筛选出来，发送到 Web Server 与 /uplink 主题： 规则引擎典型应用场景举例 动作监听：智慧家庭智能门锁开发中，门锁会因为网络、电源故障、人为破坏等原因离线导致功能异常，使用规则引擎配置监听离线事件向应用服务推送该故障信息，可以在接入层实现第一时间的故障检测的能力； 数据筛选：车辆网的卡车车队管理，车辆传感器采集并上报了大量运行数据，应用平台仅关注车速大于 40 km/h 时的数据，此场景下可以使用规则引擎对消息进行条件过滤，向业务消息队列写入满足条件的数据； 消息路由：智能计费应用中，终端设备通过不同主题区分业务类型，可通过配置规则引擎将计费业务的消息接入计费消息队列并在消息抵达设备端后发送确认通知到业务系统，非计费信息接入其他消息队列，实现业务消息路由配置； 消息编解码：其他公共协议 / 私有 TCP 协议接入、工控行业等应用场景下，可以通过规则引擎的本地处理函数（可在 EMQ X 上定制开发）做二进制 / 特殊格式消息体的编解码工作；亦可通过规则引擎的消息路由将相关消息流向外部计算资源如函数计算进行处理（可由用户自行开发处理逻辑），将消息转为业务易于处理的 JSON 格式，简化项目集成难度、提升应用快速开发交付能力。 迁移指南 4.0 版本中规则引擎 SQL 语法更加易用，3.x 版本中所有事件 FROM 子句后面均需要指定事件名称，4.0 以后我们引入 事件主题 概念，默认情况下 消息发布 事件不再需要指定事件名称： ## 3.x 版本 ## 需要指定事件名称进行处理 SELECT * FROM \"t/#\" WHERE topic =~ 't/#' ## 4.0 及以后版本 ## 默认处理 message.publish 事件，FROM 后面直接填写 MQTT 主题 ## 上述 SQL 语句等价于: SELECT * FROM 't/#' ## 其他事件，FROM 后面填写事件主题 SELECT * FROM \"$events/message_acked\" where topic =~ 't/#' SELECT * FROM \"$events/client_connected\" Dashboard 中提供了旧版 SQL 语法转换功能可以完成 SQL 升级迁移。 规则引擎组成 使用 EMQ X 的规则引擎可以灵活地处理消息和事件。使用规则引擎可以方便地实现诸如将消息转换成指定格式，然后存入数据库表，或者发送到消息队列等。 与 EMQ X 规则引擎相关的概念包括: 规则(rule)、动作(action)、资源(resource) 和 资源类型(resource-type)。 规则、动作、资源的关系: 规则: { SQL 语句, 动作列表: [ { 动作1, 动作参数, 绑定资源: { 资源配置 } }, { 动作2, 动作参数, 绑定资源: { 资源配置 } } ] } 规则(Rule): 规则由 SQL 语句和动作列表组成。动作列表包含一个或多个动作及其参数。 SQL 语句用于筛选或转换消息中的数据。 动作(Action) 是 SQL 语句匹配通过之后，所执行的任务。动作定义了一个针对数据的操作。 动作可以绑定资源，也可以不绑定。例如，“inspect” 动作不需要绑定资源，它只是简单打印数据内容和动作参数。而 “data_to_webserver” 动作需要绑定一个 web_hook 类型的资源，此资源中配置了 URL。 资源(Resource): 资源是通过资源类型为模板实例化出来的对象，保存了与资源相关的配置(比如数据库连接地址和端口、用户名和密码等) 和系统资源(如文件句柄，连接套接字等)。 资源类型 (Resource Type): 资源类型是资源的静态定义，描述了此类型资源需要的配置项。 动作和资源类型是由 emqx 或插件的代码提供的，不能通过 API 和 CLI 动态创建。 SQL 语句 SQL 语法 FROM、SELECT 和 WHERE 子句: 规则引擎的 SQL 语句基本格式为: SELECT FROM [WHERE ] ` FROM 子句将规则挂载到某个主题上 SELECT 子句用于对数据进行变换，并选择出感兴趣的字段 WHERE 子句用于对 SELECT 选择出来的某个字段施加条件过滤 FOREACH、DO 和 INCASE 子句: 如果对于一个数组数据，想针对数组中的每个元素分别执行一些操作并执行 Actions，需要使用 FOREACH-DO-INCASE 语法。其基本格式为: FOREACH [DO ] [INCASE ] FROM [WHERE ] ` FOREACH 子句用于选择需要做 foreach 操作的字段，注意选择出的字段必须为数组类型 DO 子句用于对 FOREACH 选择出来的数组中的每个元素进行变换，并选择出感兴趣的字段 INCASE 子句用于对 DO 选择出来的某个字段施加条件过滤 其中 DO 和 INCASE 子句都是可选的。DO 相当于针对当前循环中对象的 SELECT 子句，而 INCASE 相当于针对当前循环中对象的 WHERE 语句。 事件和事件主题 规则引擎的 SQL 语句既可以处理消息(消息发布)，也可以处理事件(客户端上下线、客户端订阅等)。对于消息，FROM 子句后面直接跟主题名；对于事件，FROM 子句后面跟事件主题。 事件消息的主题以 \"$events/\" 开头，比如 \"$events/client_connected\", \"$events/session_subscribed\"。 如果想让 emqx 将事件消息发布出来，可以在 emqx_rule_engine.conf 文件中配置。 所有支持的事件及其可用字段详见: 规则事件。 SQL 语句示例: 基本语法举例 从 topic 为 \"t/a\" 的消息中提取所有字段: SELECT * FROM \"t/a\" 从 topic 为 \"t/a\" 或 \"t/b\" 的消息中提取所有字段: SELECT * FROM \"t/a\",\"t/b\" 从 topic 能够匹配到 't/#' 的消息中提取所有字段。 SELECT * FROM \"t/#\" 从 topic 能够匹配到 't/#' 的消息中提取 qos, username 和 clientid 字段: SELECT qos, username, clientid FROM \"t/#\" 从任意 topic 的消息中提取 username 字段，并且筛选条件为 username = 'Steven': SELECT username FROM \"#\" WHERE username='Steven' 从任意 topic 的 JSON 消息体(payload) 中提取 x 字段，并创建别名 x 以便在 WHERE 子句中使用。WHERE 子句限定条件为 x = 1。下面这个 SQL 语句可以匹配到消息体 {\"x\": 1}, 但不能匹配到消息体 {\"x\": 2}: SELECT payload as p FROM \"#\" WHERE p.x = 1 类似于上面的 SQL 语句，但嵌套地提取消息体中的数据，下面的 SQL 语句可以匹配到 JSON 消息体 {\"x\": {\"y\": 1}}: SELECT payload as a FROM \"#\" WHERE a.x.y = 1 在 clientid = 'c1' 尝试连接时，提取其来源 IP 地址和端口号: SELECT peername as ip_port FROM \"$events/client_connected\" WHERE clientid = 'c1' 筛选所有订阅 't/#' 主题且订阅级别为 QoS1 的 clientid: SELECT clientid FROM \"$events/session_subscribed\" WHERE topic = 't/#' and qos = 1 筛选所有订阅主题能匹配到 't/#' 且订阅级别为 QoS1 的 clientid。注意与上例不同的是，这里用的是主题匹配操作符 '=~'，所以会匹配订阅 't' 或 't/+/a' 的订阅事件: SELECT clientid FROM \"$events/session_subscribed\" WHERE topic =~ 't/#' and qos = 1 FROM 子句后面的主题需要用双引号 \"\" 引起来。 WHERE 子句后面接筛选条件，如果使用到字符串需要用单引号 '' 引起来。 FROM 子句里如有多个主题，需要用逗号 \",\" 分隔。例如 SELECT * FROM \"t/1\", \"t/2\" 。 可以使用使用 \".\" 符号对 payload 进行嵌套选择。 遍历语法(FOREACH-DO-INCASE) 举例 假设有 ClientID 为 c_steve、主题为 t/1 的消息，消息体为 JSON 格式，其中 sensors 字段为包含多个 Object 的数组: { \"date\": \"2020-04-24\", \"sensors\": [ {\"name\": \"a\", \"idx\":0}, {\"name\": \"b\", \"idx\":1}, {\"name\": \"c\", \"idx\":2} ] } 示例1: 要求将 sensors 里的各个对象，分别作为数据输入重新发布消息到 sensors/${idx} 主题，内容为 ${name}。即最终规则引擎将会发出 3 条消息: 1) 主题：sensors/0 内容：a 2) 主题：sensors/1 内容：b 3) 主题：sensors/2 内容：c 要完成这个规则，我们需要配置如下动作： 动作类型：消息重新发布 (republish) 目的主题：sensors/${idx} 目的 QoS：0 消息内容模板：${name} 以及如下 SQL 语句： FOREACH payload.sensors FROM \"t/#\" 示例解析: 这个 SQL 中，FOREACH 子句指定需要进行遍历的数组 sensors，则选取结果为: [ { \"name\": \"a\", \"idx\": 0 }, { \"name\": \"b\", \"idx\": 1 }, { \"name\": \"c\", \"idx\": 2 } ] FOREACH 语句将会对于结果数组里的每个对象分别执行 \"消息重新发布\" 动作，所以将会执行重新发布动作 3 次。 示例2: 要求将 sensors 里的 idx 值大于或等于 1 的对象，分别作为数据输入重新发布消息到 sensors/${idx} 主题，内容为 clientid=${clientid},name=${name},date=${date}。即最终规则引擎将会发出 2 条消息: 1) 主题：sensors/1 内容：clientid=c_steve,name=b,date=2020-04-24 2) 主题：sensors/2 内容：clientid=c_steve,name=c,date=2020-04-24 要完成这个规则，我们需要配置如下动作： 动作类型：消息重新发布 (republish) 目的主题：sensors/${idx} 目的 QoS：0 消息内容模板：clientid=${clientid},name=${name},date=${date} 以及如下 SQL 语句： FOREACH payload.sensors DO clientid, item.name as name, item.idx as idx INCASE item.idx >= 1 FROM \"t/#\" 示例解析: 这个 SQL 中，FOREACH 子句指定需要进行遍历的数组 sensors; DO 子句选取每次操作需要的字段，这里我们选了外层的 clientid 字段，以及当前 sensor 对象的 name 和 idx 两个字段，注意 item 代表 sensors 数组中本次循环的对象。INCASE 子句是针对 DO 语句中字段的筛选条件，仅仅当 idx >= 1 满足条件。所以 SQL 的选取结果为: [ { \"name\": \"b\", \"idx\": 1, \"clientid\": \"c_emqx\" }, { \"name\": \"c\", \"idx\": 2, \"clientid\": \"c_emqx\" } ] FOREACH 语句将会对于结果数组里的每个对象分别执行 \"消息重新发布\" 动作，所以将会执行重新发布动作 2 次。 在 DO 和 INCASE 语句里，可以使用 item 访问当前循环的对象，也可以通过在 FOREACH 使用 as 语法自定义一个变量名。所以本例中的 SQL 语句又可以写为： FOREACH payload.sensors as s DO clientid, s.name as name, s.idx as idx INCASE s.idx >= 1 FROM \"t/#\" 示例3: 在示例2 的基础上，去掉 clientid 字段 c_steve 中的 c_ 前缀 在 FOREACH 和 DO 语句中可以调用各类 SQL 函数，若要将 c_steve 变为 steve，则可以把例2 中的 SQL 改为： FOREACH payload.sensors as s DO nth(2, tokens(clientid,'_')) as clientid, s.name as name, s.idx as idx INCASE s.idx >= 1 FROM \"t/#\" 另外，FOREACH 子句中也可以放多个表达式，只要最后一个表达式是指定要遍历的数组即可。比如我们将消息体改一下，sensors 外面多套一层 Object： { \"date\": \"2020-04-24\", \"data\": { \"sensors\": [ {\"name\": \"a\", \"idx\":0}, {\"name\": \"b\", \"idx\":1}, {\"name\": \"c\", \"idx\":2} ] } } 则 FOREACH 中可以在决定要遍历的数组之前把 data 选取出来： FOREACH payload.data as data data.sensors as s ... CASE-WHEN 语法示例 示例1: 将消息中 x 字段的值范围限定在 0~7 之间。 SELECT CASE WHEN payload.x 7 THEN 7 ELSE payload.x END as x FROM \"t/#\" 假设消息为: {\"x\": 8} 则上面的 SQL 输出为: {\"x\": 7} FROM 子句可用的事件主题 事件主题名 释义 $events/message_delivered 消息投递 $events/message_acked 消息确认 $events/message_dropped 消息丢弃 $events/client_connected 连接完成 $events/client_disconnected 连接断开 $events/session_subscribed 订阅 $events/session_unsubscribed 取消订阅 SELECT 和 WHERE 子句可用的字段 SELECT 和 WHERE 子句可用的字段与事件的类型相关。其中 clientid, username 和 event 是通用字段，每种事件类型都有。 普通主题 (消息发布) event 事件类型，固定为 \"message.publish\" id MQTT 消息 ID clientid Client ID username 用户名 payload MQTT 消息体 peerhost 客户端的 IPAddress topic MQTT 主题 qos MQTT 消息的 QoS flags MQTT 消息的 Flags headers MQTT 消息内部与流程处理相关的额外数据 timestamp 事件触发时间 (ms) publish_received_at PUBLISH 消息到达 Broker 的时间 (ms) node 事件触发所在节点 $events/message_delivered (消息投递) event 事件类型，固定为 \"message.delivered\" id MQTT 消息 ID from_clientid 消息来源 Client ID from_username 消息来源用户名 clientid 消息目的 Client ID username 消息目的用户名 payload MQTT 消息体 peerhost 客户端的 IPAddress topic MQTT 主题 qos MQTT 消息的 QoS flags MQTT 消息的 Flags timestamp 事件触发时间 (ms) publish_received_at PUBLISH 消息到达 Broker 的时间 (ms) node 事件触发所在节点 $events/message_acked (消息确认) event 事件类型，固定为 \"message.acked\" id MQTT 消息 ID from_clientid 消息来源 Client ID from_username 消息来源用户名 clientid 消息目的 Client ID username 消息目的用户名 payload MQTT 消息体 peerhost 客户端的 IPAddress topic MQTT 主题 qos MQTT 消息的 QoS flags MQTT 消息的 Flags timestamp 事件触发时间 (ms) publish_received_at PUBLISH 消息到达 Broker 的时间 (ms) node 事件触发所在节点 $events/message_dropped (消息丢弃) event 事件类型，固定为 \"message.dropped\" id MQTT 消息 ID reason 消息丢弃原因 clientid 消息目的 Client ID username 消息目的用户名 payload MQTT 消息体 peerhost 客户端的 IPAddress topic MQTT 主题 qos MQTT 消息的 QoS flags MQTT 消息的 Flags timestamp 事件触发时间 (ms) publish_received_at PUBLISH 消息到达 Broker 的时间 (ms) node 事件触发所在节点 $events/client_connected (终端连接成功) event 事件类型，固定为 \"client.connected\" clientid 消息目的 Client ID username 消息目的用户名 mountpoint 主题挂载点(主题前缀) peername 终端的 IPAddress 和 Port sockname emqx 监听的 IPAddress 和 Port proto_name 协议名字 proto_ver 协议版本 keepalive MQTT 保活间隔 clean_start MQTT clean_start expiry_interval MQTT Session 过期时间 is_bridge 是否为 MQTT bridge 连接 connected_at 终端连接完成时间 (s) timestamp 事件触发时间 (ms) node 事件触发所在节点 $events/client_disconnected (终端连接断开) event 事件类型，固定为 \"client.disconnected\" reason 终端连接断开原因 clientid 消息目的 Client ID username 消息目的用户名 peername 终端的 IPAddress 和 Port sockname emqx 监听的 IPAddress 和 Port disconnected_at 终端连接断开时间 (s) timestamp 事件触发时间 (ms) node 事件触发所在节点 $events/session_subscribed (终端订阅成功) event 事件类型，固定为 \"session.subscribed\" clientid 消息目的 Client ID username 消息目的用户名 peerhost 客户端的 IPAddress topic MQTT 主题 qos MQTT 消息的 QoS timestamp 事件触发时间 (ms) node 事件触发所在节点 $events/session_unsubscribed (取消终端订阅成功) event 事件类型，固定为 \"session.unsubscribed\" clientid 消息目的 Client ID username 消息目的用户名 peerhost 客户端的 IPAddress topic MQTT 主题 qos MQTT 消息的 QoS timestamp 事件触发时间 (ms) node 事件触发所在节点 SQL 关键字和符号 SELECT - FROM - WHERE 语句 SELECT 语句用于决定最终的输出结果里的字段。比如: 下面 SQL 的输出结果中将只有两个字段 \"a\" 和 \"b\": SELECT a, b FROM \"t/#\" WHERE 语句用于对本事件中可用字段，或 SELECT 语句中定义的字段进行条件过滤。比如: # 选取 username 为 'abc' 的终端发来的消息，输出结果为所有可用字段: SELECT * FROM \"#\" WHERE username = 'abc' ## 选取 clientid 为 'abc' 的终端发来的消息，输出结果将只有 cid 一个字段。 ## 注意 cid 变量是在 SELECT 语句中定义的，故可在 WHERE 语句中使用: SELECT clientid as cid FROM \"#\" WHERE cid = 'abc' ## 选取 username 为 'abc' 的终端发来的消息，输出结果将只有 cid 一个字段。 ## 注意虽然 SELECT 语句中只选取了 cid 一个字段，所有消息发布事件中的可用字段 (比如 clientid, username 等) 仍然可以在 WHERE 语句中使用: SELECT clientid as cid FROM \"#\" WHERE username = 'abc' ## 但下面这个 SQL 语句就不能工作了，因为变量 xyz 既不是消息发布事件中的可用字段，又没有在 SELECT 语句中定义: SELECT clientid as cid FROM \"#\" WHERE xyz = 'abc' FROM 语句用于选择事件来源。如果是消息发布则填写消息的主题，如果是事件则填写对应的事件主题。 运算符号 函数名 函数作用 返回值 + 加法，或字符串拼接 加和，或拼接之后的字符串 - 减法 差值 * 乘法 乘积 / 除法 商值 div 整数除法 整数商值 mod 取模 模 = 比较两者是否完全相等。可用于比较变量和主题 true/false =~ 比较主题(topic)是否能够匹配到主题过滤器(topic filter)。只能用于主题匹配 true/false SQL 语句中可用的函数 数学函数 函数名 函数作用 参数 返回值 abs 绝对值 被操作数 绝对值 cos 余弦 被操作数 余弦值 cosh 双曲余弦 被操作数 双曲余弦值 acos 反余弦 被操作数 反余弦值 acosh 反双曲余弦 被操作数 反双曲余弦值 sin 正弦 被操作数 正弦值 sinh 双曲正弦 被操作数 双曲正弦值 asin 反正弦 被操作数 值 asinh 反双曲正弦 被操作数 反双曲正弦值 tan 正切 被操作数 正切值 tanh 双曲正切 被操作数 双曲正切值 atan 反正切 被操作数 反正切值 atanh 反双曲正切 被操作数 反双曲正切值 ceil 上取整 被操作数 整数值 floor 下取整 被操作数 整数值 round 四舍五入 被操作数 整数值 exp 幂运算 被操作数 e 的 x 次幂 power 指数运算 左操作数 x 2. 右操作数 y x 的 y 次方 sqrt 平方根运算 被操作数 平方根 fmod 负点数取模函数 左操作数 2. 右操作数 模 log 以 e 为底对数 被操作数 值 log10 以 10 为底对数 被操作数 值 log2 以 2 为底对数 被操作数 值 数据类型判断函数 函数名 函数作用 参数 返回值 is_null 判断变量是否为空值 Data Boolean 类型的数据。如果为空值(undefined) 则返回 true，否则返回 false is_not_null 判断变量是否为非空值 Data Boolean 类型的数据。如果为空值(undefined) 则返回 false，否则返回 true is_str 判断变量是否为 String 类型 Data Boolean 类型的数据。 is_bool 判断变量是否为 Boolean 类型 Data Boolean 类型的数据。 is_int 判断变量是否为 Integer 类型 Data Boolean 类型的数据。 is_float 判断变量是否为 Float 类型 Data Boolean 类型的数据。 is_num 判断变量是否为数字类型，包括 Integer 和 Float 类型 Data Boolean 类型的数据。 is_map 判断变量是否为 Map 类型 Data Boolean 类型的数据。 is_array 判断变量是否为 Array 类型 Data Boolean 类型的数据。 数据类型转换函数 函数名 函数作用 参数 返回值 str 将数据转换为 String 类型 Data String 类型的数据。无法转换将会导致 SQL 匹配失败 str_utf8 将数据转换为 UTF-8 String 类型 Data UTF-8 String 类型的数据。无法转换将会导致 SQL 匹配失败 bool 将数据转换为 Boolean 类型 Data Boolean 类型的数据。无法转换将会导致 SQL 匹配失败 int 将数据转换为整数类型 Data 整数类型的数据。无法转换将会导致 SQL 匹配失败 float 将数据转换为浮点型类型 Data 浮点型类型的数据。无法转换将会导致 SQL 匹配失败 map 将数据转换为 Map 类型 Data Map 类型的数据。无法转换将会导致 SQL 匹配失败 字符串函数 函数名 函数作用 参数 返回值 举例 lower 转为小写 1. 原字符串 小写字符串 1. lower('AbC') = 'abc'2. lower('abc') = 'abc' upper 转为大写 1. 原字符串 大写字符串 1. upper('AbC') = 'ABC'2. lower('ABC') = 'ABC' trim 去掉左右空格 1. 原字符串 去掉空格后的字符串 1. trim(' hello ') = 'hello' ltrim 去掉左空格 1. 原字符串 去掉空格后的字符串 1. ltrim(' hello ') = 'hello ' rtrim 去掉右空格 1. 原字符串 去掉空格后的字符串 1. rtrim(' hello ') = ' hello' reverse 字符串反转 1. 原字符串 翻转后的字符串 1. reverse('hello') = 'olleh' strlen 取字符串长度 1. 原字符串 整数值，字符长度 1. strlen('hello') = 5 substr 取字符的子串 1. 原字符串 2. 起始位置. 注意: 下标从 0 开始 子串 1. substr('abcdef', 2) = 'cdef' substr 取字符的子串 1. 原字符串 2. 起始位置 3. 要取出的子串长度. 注意: 下标从 0 开始 子串 1. substr('abcdef', 2, 3) = 'cde' split 字符串分割 1. 原字符串 2. 分割符子串 分割后的字符串数组 1. split('a/b/ c', '/') = ['a', 'b', ' c'] split 字符串分割, 只查找左边第一个分隔符 1. 原字符串 2. 分割符子串 3. 'leading' 分割后的字符串数组 1. split('a/b/ c', '/', 'leading') = ['a', 'b/ c'] split 字符串分割, 只查找右边第一个分隔符 1. 原字符串 2. 分割符子串 3. 'trailing' 分割后的字符串数组 1. split('a/b/ c', '/', 'trailing') = ['a/b', ' c'] concat 字符串拼接 1. 左字符串 2. 右符子串 拼接后的字符串 1. concat('a', '/bc') = 'a/bc'2. 'a' + '/bc' = 'a/bc' tokens 字符串分解(按照指定字符串符分解) 1. 输入字符串 2. 分割符或字符串 分解后的字符串数组 1. tokens(' a/b/ c', '/') = [' a', 'b', ' c']2. tokens(' a/b/ c', '/ ') = ['a', 'b', 'c']3. tokens(' a/b/ c\\n', '/ ') = ['a', 'b', 'c\\n'] tokens 字符串分解(按照指定字符串和换行符分解) 1. 输入字符串 2. 分割符或字符串 3. 'nocrlf' 分解后的字符串数组 1. tokens(' a/b/ c\\n', '/ ', 'nocrlf') = ['a', 'b', 'c']2. tokens(' a/b/ c\\r\\n', '/ ', 'nocrlf') = ['a', 'b', 'c'] sprintf 字符串格式化, 格式字符串的用法详见 https://erlang.org/doc/man/io.html#fwrite-1 里的 Format 部分 1. 格式字符串 2,3,4... 参数列表。参数个数不定 分解后的字符串数组 1. sprintf('hello, ~s!', 'steve') = 'hello, steve!'2. sprintf('count: ~p~n', 100) = 'count: 100\\n' pad 字符串补足长度，补空格，从尾部补足 1. 原字符串 2. 字符总长度 补足后的字符串 1. pad('abc', 5) = 'abc ' pad 字符串补足长度，补空格，从尾部补足 1. 原字符串 2. 字符总长度 3. 'trailing' 补足后的字符串 1. pad('abc', 5, 'trailing') = 'abc ' pad 字符串补足长度，补空格，从两边补足 1. 原字符串 2. 字符总长度 3. 'both' 补足后的字符串 1. pad('abc', 5, 'both') = ' abc ' pad 字符串补足长度，补空格，从头部补足 1. 原字符串 2. 字符总长度 3. 'leading' 补足后的字符串 1. pad('abc', 5, 'leading') = ' abc' pad 字符串补足长度，补指定字符，从尾部补足 1. 原字符串 2. 字符总长度 3. 'trailing' 4. 指定用于补足的字符 补足后的字符串 1. pad('abc', 5, 'trailing', '*') = 'abc**'2. pad('abc', 5, 'trailing', '*#') = 'abc*#*#' pad 字符串补足长度，补指定字符，从两边补足 1. 原字符串 2. 字符总长度 3. 'both' 4. 指定用于补足的字符 补足后的字符串 1. pad('abc', 5, 'both', '*') = '*abc*'2. pad('abc', 5, 'both', '*#') = '*#abc*#' pad 字符串补足长度，补指定字符，从头部补足 1. 原字符串 2. 字符总长度 3. 'leading' 4. 指定用于补足的字符 补足后的字符串 1. pad('abc', 5, 'leading', '*') = '**abc'2. pad('abc', 5, 'leading', '*#') = '*#*#abc' replace 替换字符串中的某子串，查找所有匹配子串替换 1. 原字符串 2. 要被替换的子串 3. 指定用于替换的字符串 替换后的字符串 1. replace('ababef', 'ab', 'cd') = 'cdcdef' replace 替换字符串中的某子串，查找所有匹配子串替换 1. 原字符串 2. 要被替换的子串 3. 指定用于替换的字符串 4. 'all' 替换后的字符串 1. replace('ababef', 'ab', 'cd', 'all') = 'cdcdef' replace 替换字符串中的某子串，从尾部查找第一个匹配子串替换 1. 原字符串 2. 要被替换的子串 3. 指定用于替换的字符串 4. 'trailing' 替换后的字符串 1. replace('ababef', 'ab', 'cd', 'trailing') = 'abcdef' replace 替换字符串中的某子串，从头部查找第一个匹配子串替换 1. 原字符串 2. 要被替换的子串 3. 指定用于替换的字符串 4. 'leading' 替换后的字符串 1. replace('ababef', 'ab', 'cd', 'leading') = 'cdabef' regex_match 判断字符串是否与某正则表达式匹配 1. 原字符串 2. 正则表达式 true 或 false 1. regex_match('abc123', '[a-zA-Z1-9]*') = true regex_replace 替换字符串中匹配到某正则表达式的子串 1. 原字符串 2. 正则表达式 3. 指定用于替换的字符串 替换后的字符串 1. regex_replace('ab1cd3ef', '[1-9]', '[&]') = 'ab[1]cd[3]ef'2. regex_replace('ccefacef', 'c+', ':') = ':efa:ef' ascii 返回字符对应的 ASCII 码 1. 字符 整数值，字符对应的 ASCII 码 1. ascii('a') = 97 find 查找并返回字符串中的某个子串，从头部查找 1. 原字符串 2. 要查找的子串 查抄到的子串，如找不到则返回空字符串 1. find('eeabcabcee', 'abc') = 'abcabcee' find 查找并返回字符串中的某个子串，从头部查找 1. 原字符串 2. 要查找的子串 3. 'leading' 查抄到的子串，如找不到则返回空字符串 1. find('eeabcabcee', 'abc', 'leading') = 'abcabcee' find 查找并返回字符串中的某个子串，从尾部查找 1. 原字符串 2. 要查找的子串 3. 'trailing' 查抄到的子串，如找不到则返回空字符串 1. find('eeabcabcee', 'abc', 'trailing') = 'abcee' Map 函数 函数名 函数作用 参数 返回值 map_get 取 Map 中某个 Key 的值，如果没有则返回空值 Key 2. Map Map 中某个 Key 的值。支持嵌套的 Key，比如 \"a.b.c\" map_get 取 Map 中某个 Key 的值，如果没有则返回指定默认值 Key 2. Map 3. Default Value Map 中某个 Key 的值。支持嵌套的 Key，比如 \"a.b.c\" map_put 向 Map 中插入值 Key 2. Value 3. Map 插入后的 Map。支持嵌套的 Key，比如 \"a.b.c\" 数组函数 函数名 函数作用 参数 返回值 nth 取第 n 个元素，下标从 1 开始 原数组 第 n 个元素 length 获取数组的长度 原数组 数组长度 sublist 取从第一个元素开始、长度为 len 的子数组。下标从 1 开始 长度 len 2. 原数组 子数组 sublist 取从第 n 个元素开始、长度为 len 的子数组。下标从 1 开始 起始位置 n 2. 长度 len 3. 原数组 子数组 first 取第 1 个元素。下标从 1 开始 原数组 第 1 个元素 last 取最后一个元素。 原数组 最后一个元素 contains 判断数据是否在数组里面 数据 2. 原数组 Boolean 值 哈希函数 函数名 函数作用 参数 返回值 md5 求 MD5 值 数据 MD5 值 sha 求 SHA 值 数据 SHA 值 sha256 求 SHA256 值 数据 SHA256 值 编解码函数 函数名 函数作用 参数 返回值 base64_encode BASE64 编码 数据 BASE64 字符串 base64_decode BASE64 解码 BASE64 字符串 数据 json_encode JSON 编码 JSON 字符串 内部 Map json_decode JSON 解码 内部 Map JSON 字符串 schema_encode Schema 编码 Schema ID 2. 内部 Map 数据 schema_encode Schema 编码 Schema ID 2. 内部 Map 3. Protobuf Message 名 数据 schema_decode Schema 解码 Schema ID 2. 数据 内部 Map schema_decode Schema 解码 Schema ID 2. 数据 3. Protobuf Message 名 内部 Map 在 Dashboard 中测试 SQL 语句 Dashboard 界面提供了 SQL 语句测试功能，通过给定的 SQL 语句和事件参数，展示 SQL 测试结果。 在创建规则界面，输入 规则SQL，并启用 SQL 测试 开关: 修改模拟事件的字段，或者使用默认的配置，点击 测试 按钮: SQL 处理后的结果将在 测试输出 文本框里展示: .emqxee { display: none; }"},"rule/rule-create.html":{"url":"rule/rule-create.html","title":"创建规则","keywords":"","body":"创建规则 使用 Dashboard 创建规则 创建 WebHook 规则 通过 CLI 创建简单规则 创建 Inspect 规则 创建 WebHook 规则 创建规则 使用 Dashboard 创建规则 创建 WebHook 规则 搭建 Web 服务，这里使用 nc 命令做一个简单的Web 服务: nc 命令在部分 Linux 操作系统上有问题，无法与 EMQ X 发起的 HTTP 请求连接握手成功，第 7 步可能无法正常进行。 $ while true; do echo -e \"HTTP/1.1 200 OK\\n\\n $(date)\" | nc -l 127.0.0.1 8081; done; 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 填写用以处理 t/# 主题的规则 SQL: SELECT * FROM \"t/#\" WHERE qos = 1 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “发送数据到 Web 服务”。 给动作关联资源: 现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 WebHook 资源: 选择 “WebHook 资源”: 填写资源配置: 填写 “请求 URL” 和请求头(可选): http://127.0.0.1:8081 点击 “测试连接” 按钮，确保连接测试成功，最后点击 “新建” 按钮: 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，规则列表里展示出了新创建的规则: 发一条消息: Topic: \"t/1\" QoS: 1 Payload: \"Hello web server\" 然后检查 Web 服务是否收到消息: 通过 CLI 创建简单规则 创建 Inspect 规则 创建一个测试规则，当有消息发送到 't/a' 主题时，打印消息内容以及动作参数细节。 规则的筛选 SQL 语句为: SELECT * FROM \"t/a\"; 动作是: \"打印动作参数细节\"，需要使用内置动作 'inspect'。 $ ./bin/emqx_ctl rules create \\ \"SELECT * FROM \\\"t/a\\\" \\ '[{\"name\":\"inspect\", \"params\": {\"a\": 1}}]' \\ -d 'Rule for debug' Rule rule:803de6db created 上面的 CLI 命令创建了一个 ID 为 'Rule rule:803de6db' 的规则。 参数中前两个为必选参数: SQL 语句: SELECT * FROM \"t/a\" 动作列表: [{\"name\":\"inspect\", \"params\": {\"a\": 1}}]。动作列表是用 JSON Array 格式表示的。name 字段是动作的名字，params 字段是动作的参数。注意 inspect 动作是不需要绑定资源的。 最后一个可选参数，是规则的描述: 'Rule for debug'。 接下来当发送 \"hello\" 消息到主题 't/a' 时，上面创建的 \"Rule rule:803de6db\" 规则匹配成功，然后 \"inspect\" 动作被触发，将消息和参数内容打印到 emqx 控制台: $ tail -f log/erlang.log.1 (emqx@127.0.0.1)1> [inspect] Selected Data: #{client_id => >,event => 'message.publish', flags => #{dup => false,retain => false}, id => >, payload => >, peername => >,qos => 1, timestamp => 1558587875090,topic => >, username => undefined} Envs: #{event => 'message.publish', flags => #{dup => false,retain => false}, from => >, headers => #{allow_publish => true, peername => {{127,0,0,1},61770}, username => undefined}, id => >, payload => >,qos => 1, timestamp => {1558,587875,89754}, topic => >} Action Init Params: #{> => 1} Selected Data 列出的是消息经过 SQL 筛选、提取后的字段，由于我们用的是 select *，所以这里会列出所有可用的字段。 Envs 是动作内部可以使用的环境变量。 Action Init Params 是初始化动作的时候，我们传递给动作的参数。 创建 WebHook 规则 创建一个规则，将所有发送自 client_id='Steven' 的消息，转发到地址为 'http://127.0.0.1:9910' 的 Web 服务器: 规则的筛选条件为: SELECT username as u, payload FROM \"t/a\" where u='Steven'; 动作是: \"转发到地址为 'http://127.0.0.1:9910' 的 Web 服务\"; 资源类型是: web_hook; 资源是: \"到 url='http://127.0.0.1:9910' 的 WebHook 资源\"。 首先我们创建一个简易 Web 服务，这可以使用 nc 命令实现: $ while true; do echo -e \"HTTP/1.1 200 OK\\n\\n $(date)\" | nc -l 127.0.0.1 9910; done; 使用 WebHook 类型创建一个资源，并配置资源参数 url: 1). 列出当前所有可用的资源类型，确保 'web_hook' 资源类型已存在: $ ./bin/emqx_ctl resource-types list resource_type(name='web_hook', provider='emqx_web_hook', params=#{...}}, on_create={emqx_web_hook_actions,on_resource_create}, description='WebHook Resource') ... 2). 使用类型 'web_hook' 创建一个新的资源，并配置 \"url\"=\"http://127.0.0.1:9910\": $ ./bin/emqx_ctl resources create \\ 'web_hook' \\ -c '{\"url\": \"http://127.0.0.1:9910\", \"headers\": {\"token\":\"axfw34y235wrq234t4ersgw4t\"}, \"method\": \"POST\"}' Resource resource:691c29ba created 上面的 CLI 命令创建了一个 ID 为 '' 的资源，第一个参数是必选参数 - 资源类型(web_hook)。参数表明此资源指向 URL = \"http://127.0.0.1:9910\" 的 Web 服务，方法为 POST，并且设置了一个 HTTP Header: \"token\"。 然后创建规则，并选择规则的动作为 'data_to_webserver': 1). 列出当前所有可用的动作，确保 'data_to_webserver' 动作已存在: $ ./bin/emqx_ctl rule-actions list action(name='data_to_webserver', app='emqx_web_hook', for='$any', types=[web_hook], params=#{'$resource' => ...}, title ='Data to Web Server', description='Forward Messages to Web Server') ... 2). 创建规则，选择 data_to_webserver 动作，并通过 \"$resource\" 参数将 资源绑定到动作上: $ ./bin/emqx_ctl rules create \\ \"SELECT username as u, payload FROM \\\"message.publish\\\" where u='Steven'\" \\ '[{\"name\":\"data_to_webserver\", \"params\": {\"$resource\": \"resource:691c29ba\"}}]' \\ -d \"Forward publish msgs from steven to webserver\" rule:26d84768 上面的 CLI 命令与第一个例子里创建 Inspect 规则时类似，区别在于这里需要把刚才创建的资源 '' 绑定到 'data_to_webserver' 动作上。这个绑定通过给动作设置一个特殊的参数 '$resource' 完成。'data_to_webserver' 动作的作用是将数据发送到指定的 Web 服务器。 现在我们使用 username \"Steven\" 发送 \"hello\" 到任意主题，上面创建的规则就会被触发，Web Server 收到消息并回复 200 OK: $ while true; do echo -e \"HTTP/1.1 200 OK\\n\\n $(date)\" | nc -l 127.0.0.1 9910; done; POST / HTTP/1.1 content-type: application/json content-length: 32 te: host: 127.0.0.1:9910 connection: keep-alive token: axfw34y235wrq234t4ersgw4t {\"payload\":\"hello\",\"u\":\"Steven\"} .emqxee { display: none; }"},"rule/rule-example.html":{"url":"rule/rule-example.html","title":"空动作 (调试)","summary":null,"keywords":"","body":"规则引擎示例检查 (调试)发送数据到 Web 服务桥接数据到 MQTT Broker保存数据到 MySQL保存数据到 PostgreSQL保存数据到 Cassandra保存数据到 MongoDB保存数据到 DynamoDB保存数据到 Redis保存数据到 ClickHouse保存数据到 OpenTSDB保存数据到 TDengine通过发送数据到 Web 服务写入原生方式（企业版）测试保存数据到 TimescaleDB保存数据到 InfluxDB桥接数据到 Kafka桥接数据到 Pulsar桥接数据到 RocketMQ桥接数据到 RabbitMQ桥接数据到 RPC 服务离线消息保存到 Redis离线消息保存到 MySQL离线消息保存到 PostgreSQL离线消息保存到 Cassandra离线消息保存到 MongoDB从 Redis 中获取订阅关系从 MySQL 中获取订阅关系从 PostgreSQL 中获取订阅关系从 MySQL 中获取订阅关系从 MongoDB 中获取订阅关系从 Kafka 消费消息到 EMQX从 Pulsar 消费消息到 EMQX规则引擎示例 规则引擎示例检查 (调试)发送数据到 Web 服务桥接数据到 MQTT Broker保存数据到 MySQL保存数据到 PostgreSQL保存数据到 Cassandra保存数据到 MongoDB保存数据到 DynamoDB保存数据到 Redis保存数据到 ClickHouse保存数据到 OpenTSDB保存数据到 TDengine通过发送数据到 Web 服务写入原生方式（企业版）测试保存数据到 TimescaleDB保存数据到 InfluxDB桥接数据到 Kafka桥接数据到 Pulsar桥接数据到 RocketMQ桥接数据到 RabbitMQ桥接数据到 RPC 服务离线消息保存到 Redis离线消息保存到 MySQL离线消息保存到 PostgreSQL离线消息保存到 Cassandra离线消息保存到 MongoDB从 Redis 中获取订阅关系从 MySQL 中获取订阅关系从 PostgreSQL 中获取订阅关系从 MySQL 中获取订阅关系从 MongoDB 中获取订阅关系从 Kafka 消费消息到 EMQX从 Pulsar 消费消息到 EMQX EMQ X Broker 中仅适用以下操作： 检查 (调试) 发送数据到 Web 服务 桥接数据到 MQTT Broker 保存数据到 TDengine(使用 发送数据到 Web 服务 实现) 其余均是 EMQ X Enterprise 专属功能。 检查 (调试) 创建一个测试规则，当有消息发送到 't/a' 主题时，打印消息内容以及动作参数细节。 规则的筛选 SQL 语句为: SELECT * FROM \"t/a\"; 动作是: \"打印动作参数细节\"，需要使用内置动作 'inspect'。 $ ./bin/emqx_ctl rules create \\ \"SELECT * FROM \\\"t/a\\\" WHERE \" \\ '[{\"name\":\"inspect\", \"params\": {\"a\": 1}}]' \\ -d 'Rule for debug' Rule rule:803de6db created 上面的 CLI 命令创建了一个 ID 为 'Rule rule:803de6db' 的规则。 参数中前两个为必参数: SQL 语句: SELECT * FROM \"t/a\" 动作列表: [{\"name\":\"inspect\", \"params\": {\"a\": 1}}]。动作列表是用 JSON Array 格式表示的。name 字段是动作的名字，params 字段是动作的参数。注意 inspect 动作是不需要绑定资源的。 最后一个可选参数，是规则的描述: 'Rule for debug'。 接下来当发送 \"hello\" 消息到主题 't/a' 时，上面创建的 \"Rule rule:803de6db\" 规则匹配成功，然后 \"inspect\" 动作被触发，将消息和参数内容打印到 emqx 控制台: $ tail -f log/erlang.log.1 (emqx@127.0.0.1)1> [inspect] Selected Data: #{client_id => >,event => 'message.publish', flags => #{dup => false}, id => >, payload => >, peername => >,qos => 1, timestamp => 1558587875090,topic => >, username => undefined} Envs: #{event => 'message.publish', flags => #{dup => false}, from => >, headers => #{allow_publish => true, peername => {{127,0,0,1},61770}, username => undefined}, id => >, payload => >,qos => 1, timestamp => {1558,587875,89754}, topic => >} Action Init Params: #{> => 1} Selected Data 列出的是消息经过 SQL 筛选、提取后的字段，由于我们用的是 select *，所以这里会列出所有可用的字段。 Envs 是动作内部可以使用的环境变量。 Action Init Params 是初始化动作的时候，我们传递给动作的参数。 发送数据到 Web 服务 创建一个规则，将所有发送自 client_id='Steven' 的消息，转发到地址为 'http://127.0.0.1:9910' 的 Web 服务器: 规则的筛选条件为: SELECT username as u, payload FROM \"#\" where u='Steven'; 动作是: \"转发到地址为 'http://127.0.0.1:9910' 的 Web 服务\"; 资源类型是: web_hook; 资源是: \"到 url='http://127.0.0.1:9910' 的 WebHook 资源\"。 首先我们创建一个简易 Web 服务，这可以使用 nc ​ 命令实现: $ while true; do echo -e \"HTTP/1.1 200 OK\\n\\n $(date)\" | nc -l 127.0.0.1 9910; done; 使用 WebHook 类型创建一个资源，并配置资源参数 url: 1). 列出当前所有可用的资源类型，确保 'web_hook' 资源类型已存在: $ ./bin/emqx_ctl resource-types list resource_type(name='web_hook', provider='emqx_web_hook', params=#{...}}, on_create={emqx_web_hook_actions,on_resource_create}, description='WebHook Resource') ... 2). 使用类型 'web_hook' 创建一个新的资源，并配置 \"url\"=\"http://127.0.0.1:9910\": $ ./bin/emqx_ctl resources create \\ 'web_hook' \\ -c '{\"url\": \"http://127.0.0.1:9910\", \"headers\": {\"token\":\"axfw34y235wrq234t4ersgw4t\"}, \"method\": \"POST\"}' Resource resource:691c29ba create 上面的 CLI 命令创建了一个 ID 为 '' 的资源，第一个参数是必选参数 - 资源类型(web_hook)。参数表明此资源指向 URL = \"http://127.0.0.1:9910\" 的 Web 服务，方法为 POST，并且设置了一个 HTTP Header: \"token\"。 然后创建规则，并选择规则的动作为 'data_to_webserver': 1). 列出当前所有可用的动作，确保 'data_to_webserver' 动作已存在: $ ./bin/emqx_ctl rule-actions list action(name='data_to_webserver', app='emqx_web_hook', for='$any', types=[web_hook], params=#{'$resource' => ...}, title ='Data to Web Server', description='Forward Messages to Web Server') ... 2). 创建规则，选择 data_to_webserver 动作，并通过 \"$resource\" 参数将 资源绑定到动作上: $ ./bin/emqx_ctl rules create \\ \"SELECT username as u, payload FROM \\\"#\\\" where u='Steven'\" \\ '[{\"name\":\"data_to_webserver\", \"params\": {\"$resource\": \"resource:691c29ba\"}}]' \\ -d \"Forward publish msgs from steven to webserver\" rule:26d84768 上面的 CLI 命令与第一个例子里创建 Inspect 规则时类似，区别在于这里需要把刚才创建的资源 '' 绑定到 'data_to_webserver' 动作上。这个绑定通过给动作设置一个特殊的参数 '$resource' 完成。'data_to_webserver' 动作的作用是将数据发送到指定的 Web 服务器。 现在我们使用 username \"Steven\" 发送 \"hello\" 到任意主题，上面创建的规则就会被触发，Web Server收到消息并回复 200 OK: $ while true; do echo -e \"HTTP/1.1 200 OK\\n\\n $(date)\" | nc -l 127.0.0.1 9910; done; POST / HTTP/1.1 content-type: application/json content-length: 32 te: host: 127.0.0.1:9910 connection: keep-alive token: axfw34y235wrq234t4ersgw4t {\"payload\":\"hello\",\"u\":\"Steven\"} 桥接数据到 MQTT Broker 搭建 MQTT Broker 环境，以 MaxOS X 为例: $ brew install mosquitto 启动 mosquitto $ mosquitto 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “桥接数据到 MQTT Broker”。 填写动作参数: \"桥接数据到 MQTT Broker\" 动作只需要一个参数： 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 MQTT Bridge 资源: 选择 MQTT Bridge 资源,填写资源配置: 填写真实的 mosquitto 服务器地址，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"Hello, World\\!\" 然后通过 mqtt 客户端查看消息是否发布成功 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 MySQL 搭建 MySQL 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install mysql $ brew services start mysql $ mysql -u root -h localhost -p ALTER USER 'root'@'localhost' IDENTIFIED BY 'public'; 初始化 MySQL 表: $ mysql -u root -h localhost -ppublic 创建 “test” 数据库: CREATE DATABASE test; 创建 t_mqtt_msg 表: USE test; CREATE TABLE `t_mqtt_msg` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `msgid` varchar(64) DEFAULT NULL, `topic` varchar(255) NOT NULL, `qos` tinyint(1) NOT NULL DEFAULT '0', `payload` blob, `arrived` datetime NOT NULL, PRIMARY KEY (`id`), INDEX topic_index(`id`, `topic`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 MySQL”。 填写动作参数: “保存数据到 MySQL” 动作需要两个参数： 1). SQL 模板。这个例子里我们向 MySQL 插入一条数据，SQL ​ 模板为: insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000)) 2). 关联资源的 ID。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 MySQL 资源: 填写资源配置: 数据库名填写 “mqtt”，用户名填写 “root”，密码填写 “123456” 点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 在规则列表里，点击 “查看” 按钮或规则 ID 连接，可以预览刚才创建的规则: 规则已经创建完成，现在发一条数据: Topic: \"t/a\" QoS: 1 Payload: \"hello\" 然后检查 MySQL 表，新的 record 是否添加成功: 保存数据到 PostgreSQL 搭建 PostgreSQL 数据库，以 MacOS X 为例: $ brew install postgresql $ brew services start postgresql ## 使用用户名 root 创建名为 'mqtt' 的数据库 $ createdb -U root mqtt $ psql -U root mqtt mqtt=> \\dn; List of schemas Name | Owner --------+------- public | shawn (1 row) 初始化 PgSQL 表: $ psql -U root mqtt 创建 t_mqtt_msg 表: CREATE TABLE t_mqtt_msg ( id SERIAL primary key, msgid character varying(64), sender character varying(64), topic character varying(255), qos integer, payload text, arrived timestamp without time zone ); 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 PostgreSQL”。 填写动作参数: “保存数据到 PostgreSQL” 动作需要两个参数： 1). 关联资源的 ID。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 PostgreSQL 资源: 选择 “PostgreSQL 资源”。 填写资源配置: 数据库名填写 “mqtt”，用户名填写 “root”，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 2).SQL 模板。这个例子里我们向 PostgreSQL 插入一条数据，SQL ​ 模板为: insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, to_timestamp(${timestamp}::double precision /1000)) returning id 插入数据之前，SQL 模板里的 ${key} 占位符会被替换为相应的值。 返回规则创建界面，点击 “创建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"hello1\" 然后检查 PostgreSQL 表，新的 record 是否添加成功: 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 Cassandra 搭建 Cassandra 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install cassandra ## 修改配置，关闭匿名认证 $ vim /usr/local/etc/cassandra/cassandra.yaml authenticator: PasswordAuthenticator authorizer: CassandraAuthorizer $ brew services start cassandra ## 创建 root 用户 $ cqlsh -ucassandra -pcassandra create user root with password 'public' superuser; 初始化 Cassandra 表: $ cqlsh -uroot -ppublic 创建 \"test\" 表空间: CREATE KEYSPACE test WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes = true; 创建 “t_mqtt_msg” 表: USE test; CREATE TABLE t_mqtt_msg ( msgid text, topic text, qos int, payload text, arrived timestamp, PRIMARY KEY (msgid, topic) ); 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 Cassandra”。 填写动作参数: “保存数据到 Cassandra” 动作需要两个参数： 1). 关联资源的 ID。初始状况下，资源下拉框为空，现点击右上角的 “新建资源” 来创建一个 Cassandra 资源。 填写资源配置: Keysapce 填写 “test”，用户名填写 “root”，密码填写 “public” 其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 点击 “新建” 按钮，完成资源的创建。 2). SQL 模板。这个例子里我们向 Cassandra 插入一条数据，SQL ​ 模板为: insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, ${timestamp}) 插入数据之前，SQL 模板里的 ${key} 占位符会被替换为相应的值。 在点击 “新建” 完成规则创建 现在发送一条数据，测试该规则: Topic: \"t/cass\" QoS: 1 Payload: \"hello\" 然后检查 Cassandra 表，可以看到该消息已成功保存: 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 MongoDB 搭建 MongoDB 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install mongodb $ brew services start mongodb ## 新增 root/public 用户 $ use mqtt; $ db.createUser({user: \"root\", pwd: \"public\", roles: [{role: \"readWrite\", db: \"mqtt\"}]}); ## 修改配置，关闭匿名认证 $ vim /usr/local/etc/mongod.conf security: authorization: enabled $ brew services restart mongodb 初始化 MongoDB 表: $ mongo 127.0.0.1/mqtt -uroot -ppublic db.createCollection(\"t_mqtt_msg\"); 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT id as msgid, topic, qos, payload, publish_received_at as arrived FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 MongoDB”。 填写动作参数: “保存数据到 MongoDB” 动作需要三个参数： 1). 关联资源的 ID。初始状况下，资源下拉框为空，现点击右上角的 “新建资源” 来创建一个 MongoDB 单节点 资源。 填写资源配置: 数据库名称 填写 “mqtt”，用户名填写 “root”，密码填写 “public”，连接认证源填写 “mqtt” 其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 点击 “新建” 按钮，完成资源的创建。 2). Collection 名称。这个例子我们向刚刚新建的 collection 插入数据，填 “t_mqtt_msg” 3). Payload Tmpl 模板。这个例子里我们向 MongoDB 插入一条数据，模板为空, 插入的数据是上面SQL语句select出来的结果用json格式写入到MongoDB中 在点击 “新建” 完成规则创建 现在发送一条数据，测试该规则: Topic: \"t/mongo\" QoS: 1 Payload: \"hello\" 然后检查 MongoDB 表，可以看到该消息已成功保存: 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 DynamoDB 搭建 DynamoDB 数据库，以 MacOS X 为例: $ brew install dynamodb-local $ dynamodb-local 创建 DynamoDB 表定义文件 mqtt_msg.json : { \"TableName\": \"mqtt_msg\", \"KeySchema\": [ { \"AttributeName\": \"msgid\", \"KeyType\": \"HASH\" } ], \"AttributeDefinitions\": [ { \"AttributeName\": \"msgid\", \"AttributeType\": \"S\" } ], \"ProvisionedThroughput\": { \"ReadCapacityUnits\": 5, \"WriteCapacityUnits\": 5 } } 初始化 DynamoDB 表: $ aws dynamodb create-table --cli-input-json file://mqtt_msg.json --endpoint-url http://localhost:8000 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT id, topic, payload FROM \"#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 DynamoDB”。 填写动作参数: “保存数据到 DynamoDB” 动作需要两个参数： 1). DynamoDB 表名。这个例子里我们设置的表名为 \"mqtt_msg\" 2). DynamoDB Hash Key。这个例子里我们设置的 Hash Key 要与表定义的一致 3). DynamoDB Range Key。由于我们表定义里没有设置 Range Key。这个例子里我们把 Range Key 设置为空。 4). 关联资源的 ID。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 DynamoDB 资源: 填写资源配置: 点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/a\" QoS: 1 Payload: \"hello\" 然后检查 DynamoDB 的 mqtt_msg 表，新的 record 是否添加成功: 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 Redis 搭建 Redis 环境，以 MaxOS X 为例: $ wget http://download.redis.io/releases/redis-4.0.14.tar.gz $ tar xzf redis-4.0.14.tar.gz $ cd redis-4.0.14 $ make && make install # 启动 redis $ redis-server 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 Redis”。 填写动作参数: “保存数据到 Redis 动作需要两个参数： 1). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 Redis 资源: 选择 Redis 单节点模式资源”。 填写资源配置: 填写真实的 Redis 服务器地址，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 2). Redis 的命令: HMSET mqtt:msg:${id} id ${id} from ${client_id} qos ${qos} topic ${topic} payload ${payload} ts ${timestamp} 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"hello\" 然后通过 Redis 命令去查看消息是否生产成功: $ redis-cli KEYS mqtt:msg\\* hgetall Key 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 ClickHouse 搭建 ClickHouse 数据库，并设置用户名密码为 default/public，以 CentOS 为例: ## 安装依赖 sudo yum install -y epel-release ## 下载并运行packagecloud.io提供的安装shell脚本 curl -s https://packagecloud.io/install/repositories/altinity/clickhouse/script.rpm.sh | sudo bash ## 安装ClickHouse服务器和客户端 sudo yum install -y clickhouse-server clickhouse-client ## 启动ClickHouse服务器 clickhouse-server ## 启动ClickHouse客户端程序 clickhouse-client 创建 “test” 数据库: create database test; 创建 t_mqtt_msg 表: use test; create table t_mqtt_msg (msgid Nullable(String), topic Nullable(String), clientid Nullable(String), payload Nullable(String)) engine = Log; 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 ClickHouse”。 填写动作参数: “保存数据到 ClickHouse” 动作需要两个参数： 1). 关联资源的 ID。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 ClickHouse 资源: 选择 “ClickHouse 资源”。 填写资源配置: 点击 “新建” 按钮。 2). SQL 模板。这个例子里我们向 ClickHouse 插入一条数据，SQL ​ 模板为: insert into test.t_mqtt_msg(msgid, clientid, topic, payload) values ('${id}', '${clientid}', '${topic}', '${payload}') 返回响应动作界面，点击 “确认”。 在规则列表里，点击 “查看” 按钮或规则 ID 连接，可以预览刚才创建的规则: 规则已经创建完成，现在发一条数据: Topic: \"t/a\" QoS: 1 Payload: \"hello\" 然后检查 ClickHouse 表，新的 record 是否添加成功: 保存数据到 OpenTSDB 搭建 OpenTSDB 数据库环境，以 MaxOS X 为例: $ docker pull petergrace/opentsdb-docker $ docker run -d --name opentsdb -p 4242:4242 petergrace/opentsdb-docker 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT payload as p, p.metric as metric, p.tags as tags, p.value as value FROM \"#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 OpenTSDB”。 填写动作参数: “保存数据到 OpenTSDB” 动作需要六个参数: 1). 详细信息。是否需要 OpenTSDB Server 返回存储失败的 data point 及其原因的列表，默认为 false。 2). 摘要信息。是否需要 OpenTSDB Server 返回 data point 存储成功与失败的数量，默认为 true。 3). 最大批处理数量。消息请求频繁时允许 OpenTSDB 驱动将多少个 Data Points 合并为一次请求，默认为 20。 4). 是否同步调用。指定 OpenTSDB Server 是否等待所有数据都被写入后才返回结果，默认为 false。 5). 同步调用超时时间。同步调用最大等待时间，默认为 0。 6). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 OpenTSDB 资源: 选择 “OpenTSDB 资源”: 填写资源配置: 本示例中所有配置保持默认值即可，点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条消息: Topic: \"t/1\" QoS: 0 Payload: \"{\"metric\":\"cpu\",\"tags\":{\"host\":\"serverA\"},\"value\":12}\" 我们通过 Postman 或者 curl 命令，向 OpenTSDB Server 发送以下请求: POST /api/query HTTP/1.1 Host: 127.0.0.1:4242 Content-Type: application/json cache-control: no-cache Postman-Token: 69af0565-27f8-41e5-b0cd-d7c7f5b7a037 { \"start\": 1560409825000, \"queries\": [ { \"aggregator\": \"last\", \"metric\": \"cpu\", \"tags\": { \"host\": \"*\" } } ], \"showTSUIDs\": \"true\", \"showQuery\": \"true\", \"delete\": \"false\" } ------WebKitFormBoundary7MA4YWxkTrZu0gW-- 如果 data point 存储成功，将会得到以下应答: [ { \"metric\": \"cpu\", \"tags\": { \"host\": \"serverA\" }, \"aggregateTags\": [], \"query\": { \"aggregator\": \"last\", \"metric\": \"cpu\", \"tsuids\": null, \"downsample\": null, \"rate\": false, \"filters\": [ { \"tagk\": \"host\", \"filter\": \"*\", \"group_by\": true, \"type\": \"wildcard\" } ], \"index\": 0, \"tags\": { \"host\": \"wildcard(*)\" }, \"rateOptions\": null, \"filterTagKs\": [ \"AAAC\" ], \"explicitTags\": false }, \"tsuids\": [ \"000002000002000007\" ], \"dps\": { \"1561532453\": 12 } } ] 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 TDengine TDengine 是涛思数据推出的一款开源的专为物联网、车联网、工业互联网、IT 运维等设计和优化的大数据平台。除核心的快 10 倍以上的时序数据库功能外，还提供缓存、数据订阅、流式计算等功能，最大程度减少研发和运维的复杂度。 EMQ X 支持通过 发送到 Web 服务 的方式保存数据到 TDengine，也在企业版上提供原生的 TDengine 驱动实现直接保存。 使用 Docker 安装 TDengine 或在 Cloud 上部署： docker run --name TDengine -d -p 6020-6050:6020-6050/udp TDengine/TDengine 进入 Docker 容器： docker exec -it TDengine bash taos 创建 “test” 数据库: create database test; 创建 t_mqtt_msg 表，关于 TDengine 数据结构以及 SQL 命令参见 TAOS SQL： use test; CREATE TABLE t_mqtt_msg ( ts timestamp, msgid NCHAR(64), topic NCHAR(255), qos TINYINT, payload BINARY(1024), arrived timestamp ); 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 后续动作创建操作可以根据你的 EMQ X 版本灵活选择。 通过发送数据到 Web 服务写入 为支持各种不同类型平台的开发，TDengine 提供符合 REST 设计标准的 API。通过 RESTful Connector 提供了最简单的连接方式，即使用 HTTP 请求携带认证信息与要执行的 SQL 操作 TDengine。 EMQ X 规则引擎中有功能强大的发送数据到 Web 服务功能，可以实现无缝实现上述操作。 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 Web 服务“。 EMQ X 规则引擎中有功能强大的\\发送数据到 Web 服务功能**，可以实现无缝实现上述操作。 填写动作参数: “保存数据到 Web 服务” 动作需要两个参数： 1). 消息内容模板，即 HTTP 请求体。这个例子里我们向 TDengine 插入一条数据，应当在请求体内拼接携带 INSERT SQL。注意我们应当在 SQL 中指定数据库名，字符类型也要用单引号括起来， 消息内容模板为： insert into test.t_mqtt_msg(ts, msgid, topic, qos, payload) values (now, '${id}', '${topic}', ${qos}, '${payload}') 2). 关联资源的 ID。现在资源下拉框为空，可以点击旁边的 “新建” 来创建一个 Web 服务资源: 填写资源配置: 请求 URL 填写 http://127.0.0.1:6020/rest/sql ，请求方法选择 POST; 还需添加 Authorization 请求头作为认证信息，请求头的值为 Basic + TDengine {username}:{password} 经过Base64 编码之后的字符串, 例如默认的 root:taosdata 编码后为 cm9vdDp0YW9zZGF0YQ==， 填入的值为 Basic cm9vdDp0YW9zZGF0YQ==。 点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 原生方式（企业版） 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 TDengine”。 仅限企业版 4.1.1 及以后版本。 填写动作参数: “保存数据到 TDengine” 动作需要两个参数： 1). SQL 模板。这个例子里我们向 TDengine 插入一条数据，注意我们应当在 SQL 中指定数据库名，字符类型也要用单引号括起来，SQL 模板为： insert into test.t_mqtt_msg(ts, msgid, topic, qos, payload) values (now, '${id}', '${topic}', ${qos}, '${payload}') 2). 关联资源的 ID。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 TDengine资源: 填写资源配置: 用户名填写 “root”，密码填写缺省密码 “taosdata”，TDengine 不在资源中配置数据库名，请在 SQL 中自行配置。 点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 测试 在规则列表里，点击 “查看” 按钮或规则 ID 连接，可以预览刚才创建的规则: 规则已经创建完成，现在发一条数据: Topic: \"t/a\" QoS: 1 Payload: \"hello\" 然后检查 TDengine 表，新的 record 是否添加成功: select * from t_mqtt_msg; 保存数据到 TimescaleDB 搭建 TimescaleDB 数据库环境，以 MaxOS X 为例: $ docker pull timescale/timescaledb $ docker run -d --name timescaledb -p 5432:5432 -e POSTGRES_PASSWORD=password timescale/timescaledb:latest-pg11 $ docker exec -it timescaledb psql -U postgres ## 创建并连接 tutorial 数据库 CREATE database tutorial; \\c tutorial CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE; 初始化 TimescaleDB 表: $ docker exec -it timescaledb psql -U postgres -d tutorial 创建 conditions 表: CREATE TABLE conditions ( time TIMESTAMPTZ NOT NULL, location TEXT NOT NULL, temperature DOUBLE PRECISION NULL, humidity DOUBLE PRECISION NULL ); SELECT create_hypertable('conditions', 'time'); 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT payload as p, p.temp as temp, p.humidity as humidity, p.location as location FROM \"#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 TimescaleDB”。 填写动作参数: “保存数据到 TimescaleDB” 动作需要两个参数： 1). SQL 模板。这个例子里我们向 TimescaleDB 插入一条数据，SQL ​ 模板为: insert into conditions(time, location, temperature, humidity) values (NOW(), ${location}, ${temp}, ${humidity}) 插入数据之前，SQL 模板里的 ${key} 占位符会被替换为相应的值。 2). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 TimescaleDB 资源: 选择 “TimescaleDB 资源”。 填写资源配置: 数据库名填写 “tutorial”，用户名填写 “postgres”，密码填写 “password”，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"{\"temp\":24,\"humidity\":30,\"location\":\"hangzhou\"}\" 然后检查 TimescaleDB 表，新的 record 是否添加成功: tutorial=# SELECT * FROM conditions LIMIT 100; time | location | temperature | humidity -------------------------------+----------+-------------+---------- 2019-06-27 01:41:08.752103+00 | hangzhou | 24 | 30 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 保存数据到 InfluxDB 搭建 InfluxDB 数据库环境，以 macOS X 为例: $ docker pull influxdb $ docker run --name=influxdb --rm -d -p 8086:8086 -p 8089:8089/udp -v ${PWD}/files/influxdb.conf:/etc/influxdb/influxdb.conf influxdb:latest EMQ X 仅支持通过 UDP 协议连接 InfluxDB，需要修改 InfluxDB 配置文件： [[udp]] enabled = true bind-address = \":8089\" # 消息保存的数据库 database = \"emqx\" # InfluxDB precision for timestamps on received points (\"\" or \"n\", \"u\", \"ms\", \"s\", \"m\", \"h\") # EMQ X 默认时间戳是毫秒 precision = \"ms\" # 其他配置根据需要自行修改 # batch-size = 1000 # batch-pending = 5 # batch-timeout = \"5s\" # read-buffer = 1024 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT payload as p, p.host as host, p.location as location, p.internal as internal, p.external as external FROM \"#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “保存数据到 InfluxDB”。 填写动作参数: “保存数据到 InfluxDB” 动作需要六个参数： 1). Measurement。指定写入到 InfluxDB 的 data point 的 measurement。 2). Field Keys。指定写入到 InfluxDB 的 data point 的 fields 的值从哪里获取。 3). Tags Keys。指定写入到 InfluxDB 的 data point 的 tags 的值从哪里获取。 4). Timestamp Key。指定写入到 InfluxDB 的 data point 的 timestamp 的值从哪里获取。 5). 设置时间戳。未指定 Timestamp Key 时是否自动生成。 6). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 InfluxDB 资源: 选择 “InfluxDB 资源”: 填写资源配置: 本示例中所有配置保持默认值即可，点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条消息: Topic: \"t/1\" QoS: 0 Payload: \"{\"host\":\"serverA\",\"location\":\"roomA\",\"internal\":25,\"external\":37}\" 然后检查 InfluxDB，新的 data point 是否添加成功: $ docker exec -it influxdb influx use db Using database db select * from \"temperature\" name: temperature time external host internal location ---- -------- ---- -------- -------- 1561535778444457348 35 serverA 25 roomA 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 桥接数据到 Kafka 搭建 Kafka 环境，以 MaxOS X 为例: $ wget http://apache.claz.org/kafka/2.3.0/kafka_2.12-2.3.0.tgz $ tar -xzf kafka_2.12-2.3.0.tgz $ cd kafka_2.12-2.3.0 # 启动 Zookeeper $ ./bin/zookeeper-server-start.sh config/zookeeper.properties # 启动 Kafka $ ./bin/kafka-server-start.sh config/server.properties 创建 Kafka ​ 的主题: $ ./bin/kafka-topics.sh --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic testTopic --create 创建 Kafka Rule 之前必须先在 Kafka 中创建好主题，否则创建 Kafka Rule 失败。 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “桥接数据到 Kafka”。 填写动作参数: “保存数据到 Kafka 动作需要两个参数： 1). Kafka 的消息主题 2). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 Kafka 资源: 选择 Kafka 资源”。 填写资源配置: 填写真实的 Kafka 服务器地址，多个地址用,分隔，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"hello\" 然后通过 Kafka 命令去查看消息是否生产成功: $ ./bin/kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic testTopic --from-beginning 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 桥接数据到 Pulsar 搭建 Pulsar 环境，以 MaxOS X 为例: $ wget http://apache.mirrors.hoobly.com/pulsar/pulsar-2.3.2/apache-pulsar-2.3.2-bin.tar.gz $ tar xvfz apache-pulsar-2.3.2-bin.tar.gz $ cd apache-pulsar-2.3.2 # 启动 Pulsar $ ./bin/pulsar standalone 创建 Pulsar 的主题: $ ./bin/pulsar-admin topics create-partitioned-topic -p 5 testTopic 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “桥接数据到 Pulsar”。 填写动作参数: “保存数据到 Pulsar 动作需要两个参数： 1). Pulsar 的消息主题 2). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 Pulsar 资源: 选择 Pulsar 资源”。 填写资源配置: 填写真实的 Pulsar 服务器地址，多个地址用,分隔，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"hello\" 然后通过 Pulsar 命令去查看消息是否生产成功: $ ./bin/pulsar-client consume testTopic -s \"sub-name\" -n 1000 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 桥接数据到 RocketMQ 搭建 RocketMQ 环境，以 MaxOS X ​ 为例: $ wget http://mirror.metrocast.net/apache/rocketmq/4.5.2/rocketmq-all-4.5.2-bin-release.zip $ unzip rocketmq-all-4.5.2-bin-release.zip $ cd rocketmq-all-4.5.2-bin-release # 在conf/broker.conf添加了2个配置 brokerIP1 = 127.0.0.1 autoCreateTopicEnable = true # 启动 RocketMQ NameServer $ ./bin/mqnamesrv # 启动 RocketMQ Broker $ ./bin/mqbroker -n localhost:9876 -c conf/broker.conf 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “桥接数据到 RocketMQ”。 填写动作参数: “保存数据到 RocketMQ 动作需要两个参数： 1). RocketMQ 的消息主题 2). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 RocketMQ 资源: 填写资源配置: 填写真实的 RocketMQ 服务器地址，多个地址用,分隔，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"hello\" 然后通过 RocketMQ 命令去查看消息是否生产成功: $ ./bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer TopicTest 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 桥接数据到 RabbitMQ 搭建 RabbitMQ 环境，以 MaxOS X 为例: $ brew install rabbitmq # 启动 rabbitmq $ rabbitmq-server 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “桥接数据到 RabbitMQ”。 填写动作参数: “桥接数据到 RabbitMQ 动作需要四个参数： 1). RabbitMQ Exchange。这个例子里我们设置 Exchange 为 \"messages\"， 2). RabbitMQ Exchange Type。这个例子我们设置 Exchange Type 为 \"topic\" 3). RabbitMQ Routing Key。这个例子我们设置 Routing Key 为 \"test\" 4). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 RabbitMQ 资源: 选择 RabbitMQ 资源。 填写资源配置: 填写真实的 RabbitMQ 服务器地址，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"Hello, World\\!\" 编写 amqp 协议的客户端，以下是用 python 写的 amqp 客户端的示例代码: #!/usr/bin/env python import pika connection = pika.BlockingConnection( pika.ConnectionParameters(host='localhost')) channel = connection.channel() channel.exchange_declare(exchange='messages', exchange_type='topic') result = channel.queue_declare(queue='', exclusive=True) queue_name = result.method.queue channel.queue_bind(exchange='messages', queue=queue_name, routing_key='test') print('[*] Waiting for messages. To exit press CTRL+C') def callback(ch, method, properties, body): print(\" [x] %r\" % body) channel.basic_consume( queue=queue_name, on_message_callback=callback, auto_ack=True) channel.start_consuming() 然后通过 amqp 协议的客户端查看消息是否发布成功, 以下是 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 桥接数据到 RPC 服务 搭建 EMQX Broker 环境，以 MaxOS X 为例: $ brew tap emqx/emqx/emqx $ brew install emqx # 启动 emqx $ emqx console 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 选择触发事件 “消息发布”，然后填写规则 SQL: SELECT * FROM \"t/#\" 关联动作: 在 “响应动作” 界面选择 “添加”，然后在 “动作” 下拉框里选择 “桥接数据到 MQTT Broker”。 填写动作参数: 桥接数据到 MQTT Broker 动作只需要一个参数： 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 RPC Bridge 资源: 选择 RPC Bridge 资源。 填写资源配置: 填写真实的 emqx 节点名，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，现在发一条数据: Topic: \"t/1\" QoS: 0 Payload: \"Hello, World\\!\" 然后通过 mqtt 客户端查看消息是否发布成功 在规则列表里，可以看到刚才创建的规则的命中次数已经增加了 1: 离线消息保存到 Redis 搭建 Redis 环境，以 MaxOS X 为例: $ wget http://download.redis.io/releases/redis-4.0.14.tar.gz $ tar xzf redis-4.0.14.tar.gz $ cd redis-4.0.14 $ make && make install # 启动 redis $ redis-server 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 然后填写规则 SQL: FROM说明 t/#: 发布者发布消息触发保存离线消息到Redis $events/session_subscribed: 订阅者订阅主题触发获取离线消息 $events/message_acked: 订阅者回复消息ACK后触发删除已经被接收的离线消息 SELECT * FROM \"t/#\", \"$events/session_subscribed\", \"$events/message_acked\" WHERE topic =~ 't/#' 关联动作: 在 “响应动作” 界面选择 “添加动作”，然后在 “动作” 下拉框里选择 “离线消息保存到 Redis”。 填写动作参数: “离线消息保存到 Redis 动作需要两个参数： 1). Redis Key 超期的 TTL 2). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 Redis 资源: 选择 Redis 单节点模式资源”。 填写资源配置: 填写真实的 Redis 服务器地址，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，通过 Dashboard 的 WebSocket 客户端发一条数据(发布消息的QoS必须大于0): 消息发送后，通过 Redis CLI 查看到消息被保存到 Redis 里面: $ redis-cli KEYS mqtt:msg\\* hgetall Key 使用另外一个客户端，订阅主题 \"t/1\" (订阅主题的QoS必须大于0，否则消息会被重复接收, 不支持主题通配符方式订阅获取离线消息): 订阅后马上接收到了保存到 Redis 里面的离线消息: 离线消息被接收后会在 Redis 中删除: 离线消息保存到 MySQL 搭建 MySQL 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install mysql $ brew services start mysql $ mysql -u root -h localhost -p ALTER USER 'root'@'localhost' IDENTIFIED BY 'public'; 初始化 MySQL 数据库: $ mysql -u root -h localhost -ppublic create database mqtt; 创建 mqtt_msg 表: DROP TABLE IF EXISTS `mqtt_msg`; CREATE TABLE `mqtt_msg` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `msgid` varchar(64) DEFAULT NULL, `topic` varchar(180) NOT NULL, `sender` varchar(64) DEFAULT NULL, `qos` tinyint(1) NOT NULL DEFAULT '0', `retain` tinyint(1) DEFAULT NULL, `payload` blob, `arrived` datetime NOT NULL, PRIMARY KEY (`id`), INDEX topic_index(`id`, `topic`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 消息表结构不能修改，请使用上面SQL语句创建 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: FROM说明 ​ t/#: 发布者发布消息触发保存离线消息到MySQL ​ $events/session_subscribed: 订阅者订阅主题触发获取离线消息 ​ $events/message_acked: 订阅者回复消息ACK后触发删除已经被接收的离线消息 SELECT * FROM \"t/#\", \"$events/session_subscribed\", \"$events/message_acked\" WHERE topic =~ 't/#' 关联动作: 在“响应动作”界面选择“添加动作”，然后在“动作”下拉框里选择“离线消息保存到 MySQL”。 现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 MySQL 资源: 弹出一个“创建资源”对话框 填写资源配置: 填写真实的 MySQL 服务器地址，其他配置填写相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 Dashboard 的 WebSocket 客户端发一条数据(发布消息的QoS必须大于0): 消息发送后，通过 mysql 查看到消息被保存到 MySQL 里面: 使用另外一个客户端，订阅主题 \"t/1\" (订阅主题的QoS必须大于0，否则消息会被重复接收): 订阅后马上接收到了保存到 MySQL 里面的离线消息: 离线消息被接收后会在 MySQL 中删除: 离线消息保存到 PostgreSQL 搭建 PostgreSQL 数据库，以 MacOS X 为例: $ brew install postgresql $ brew services start postgresql 创建 mqtt 数据库: # 使用用户名 postgres 创建名为 'mqtt' 的数据库 $ createdb -U postgres mqtt $ psql -U postgres mqtt mqtt=> \\dn; List of schemas Name | Owner --------+------- public | postgres (1 row) 创建 mqtt_msg 表: $ psql -U postgres mqtt CREATE TABLE mqtt_msg ( id SERIAL8 primary key, msgid character varying(64), sender character varying(64), topic character varying(255), qos integer, retain integer, payload text, arrived timestamp without time zone ); 消息表结构不能修改，请使用上面SQL语句创建 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: FROM说明 ​ t/#: 发布者发布消息触发保存离线消息到PostgreSQL ​ $events/session_subscribed: 订阅者订阅主题触发获取离线消息 ​ $events/message_acked: 订阅者回复消息ACK后触发删除已经被接收的离线消息 SELECT * FROM \"t/#\", \"$events/session_subscribed\", \"$events/message_acked\" WHERE topic =~ 't/#' 关联动作: 在“响应动作”界面选择“添加动作”，然后在“动作”下拉框里选择“离线消息保存到 PostgreSQL”。 现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 PostgreSQL 资源: 弹出一个“创建资源”对话框 填写资源配置: 填写真实的 PostgreSQL 服务器地址，其他配置填写相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 Dashboard 的 WebSocket 客户端发一条数据(发布消息的QoS必须大于0): 消息发送后，通过 psql 查看到消息被保存到 PostgreSQL 里面: 使用另外一个客户端，订阅主题 \"t/1\" (订阅主题的QoS必须大于0，否则消息会被重复接收): 订阅后马上接收到了保存到 PostgreSQL 里面的离线消息: 离线消息被接收后会在 PostgreSQL 中删除: 离线消息保存到 Cassandra 搭建 Cassandra 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install cassandra ## 修改配置，关闭匿名认证 $ vim /usr/local/etc/cassandra/cassandra.yaml authenticator: PasswordAuthenticator authorizer: CassandraAuthorizer $ brew services start cassandra ## 创建 root 用户 $ cqlsh -ucassandra -pcassandra create user root with password 'public' superuser; 初始化 Cassandra 表空间: $ cqlsh -uroot -ppublic CREATE KEYSPACE mqtt WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes = true; 创建 mqtt_msg 表: CREATE TABLE mqtt.mqtt_msg ( topic text, msgid text, arrived timestamp, payload text, qos int, retain int, sender text, PRIMARY KEY (topic, msgid) ) WITH CLUSTERING ORDER BY (msgid DESC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'} AND comment = '' AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'} AND compression = {'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1.0 AND dclocal_read_repair_chance = 0.1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair_chance = 0.0 AND speculative_retry = '99PERCENTILE'; 消息表结构不能修改，请使用上面SQL语句创建 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: FROM说明 ​ t/#: 发布者发布消息触发保存离线消息到Cassandra ​ $events/session_subscribed: 订阅者订阅主题触发获取离线消息 ​ $events/message_acked: 订阅者回复消息ACK后触发删除已经被接收的离线消息 SELECT * FROM \"t/#\", \"$events/session_subscribed\", \"$events/message_acked\" WHERE topic =~ 't/#' 关联动作: 在“响应动作”界面选择“添加动作”，然后在“动作”下拉框里选择“离线消息保存到 Cassandra ”。 现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 Cassandra 资源: 弹出一个“创建资源”对话框 填写资源配置: 填写真实的 Cassandra 服务器地址，其他配置填写相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 Dashboard 的 WebSocket 客户端发一条数据(发布消息的QoS必须大于0): 消息发送后，通过 cqlsh 查看到消息被保存到 Cassandra 里面: 使用另外一个客户端，订阅主题 \"t/1\" (订阅主题的QoS必须大于0，否则消息会被重复接收): 订阅后马上接收到了保存到 Cassandra 里面的离线消息: 离线消息被接收后会在 Cassandra 中删除: 离线消息保存到 MongoDB 搭建 MongoDB 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install mongodb $ brew services start mongodb ## 新增 root/public 用户 $ use mqtt; $ db.createUser({user: \"root\", pwd: \"public\", roles: [{role: \"readWrite\", db: \"mqtt\"}]}); ## 修改配置，关闭匿名认证 $ vi /usr/local/etc/mongod.conf security: authorization: enabled $ brew services restart mongodb 创建 mqtt_msg 表: $ mongo 127.0.0.1/mqtt -uroot -ppublic db.createCollection(\"mqtt_msg\"); 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: FROM说明 ​ t/#: 发布者发布消息触发保存离线消息到MongoDB ​ $events/session_subscribed: 订阅者订阅主题触发获取离线消息 ​ $events/message_acked: 订阅者回复消息ACK后触发删除已经被接收的离线消息 SELECT * FROM \"t/#\", \"$events/session_subscribed\", \"$events/message_acked\" WHERE topic =~ 't/#' 关联动作: 在“响应动作”界面选择“添加动作”，然后在“动作”下拉框里选择“离线消息保存到 MongoDB”。 现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 MongoDB 资源: 弹出一个“创建资源”对话框 填写资源配置: 填写真实的 MongoDB 服务器地址，其他配置填写相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 Dashboard 的 WebSocket 客户端发一条数据(发布消息的QoS必须大于0): 消息发送后，通过 mongo 查看到消息被保存到 MongoDB 里面: db.mqtt_msg.find() 使用另外一个客户端，订阅主题 \"t/1\" (订阅主题的QoS必须大于0，否则消息会被重复接收): 订阅后马上接收到了保存到 MongoDB 里面的离线消息: 离线消息被接收后会在 MongoDB 中删除: 从 Redis 中获取订阅关系 搭建 Redis 环境，以 MaxOS X 为例: $ wget http://download.redis.io/releases/redis-4.0.14.tar.gz $ tar xzf redis-4.0.14.tar.gz $ cd redis-4.0.14 $ make && make install # 启动 redis $ redis-server 创建规则: 打开 emqx dashboard，选择左侧的 “规则” 选项卡。 然后填写规则 SQL: SELECT * FROM \"$events/client_connected\" 关联动作: 在 “响应动作” 界面选择 “添加动作”，然后在 “动作” 下拉框里选择 “从 Redis 中获取订阅关系”。 填写动作参数: “离线消息保存到 Redis 动作需要一个参数： 1). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建资源” 来创建一个 Redis 资源: 选择 Redis 单节点模式资源”。 填写资源配置: 填写真实的 Redis 服务器地址，其他配置保持默认值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “新建” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “新建”。 规则已经创建完成，通过 Redis CLI 往Redis插入一条订阅关系: HSET mqtt:sub:test t1 1 通过 Dashboard 登录 clientid 为 test 的设备: 查看订阅列表，可以看到 test 设备已经订阅了 t1 主题: 从 MySQL 中获取订阅关系 搭建 MySQL 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install mysql $ brew services start mysql $ mysql -u root -h localhost -p ALTER USER 'root'@'localhost' IDENTIFIED BY 'public'; 初始化 MySQL 数据库: $ mysql -u root -h localhost -ppublic create database mqtt; 创建 mqtt_sub 表: DROP TABLE IF EXISTS `mqtt_sub`; CREATE TABLE `mqtt_sub` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `clientid` varchar(64) DEFAULT NULL, `topic` varchar(180) DEFAULT NULL, `qos` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `mqtt_sub_idx` (`clientid`,`topic`,`qos`), UNIQUE KEY `mqtt_sub_key` (`clientid`,`topic`), INDEX topic_index(`id`, `topic`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 订阅关系表结构不能修改，请使用上面SQL语句创建 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: SELECT * FROM \"$events/client_connected\" 关联动作: 在“响应动作”界面选择“添加动作”，然后在“新增动作”下拉框里选择“从MySQL中获取订阅列表” 填写动作参数: “从 MySQL 中获取订阅列表”动作需要一个参数： 1). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 MySQL 资源： 弹出“创建资源”对话框 填写资源配置: 填写真实的 MySQL 服务器地址，其他配置相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 “mysql” 往MySQL插入一条订阅关系: insert into mqtt_sub(clientid, topic, qos) values(\"test\", \"t1\", 1); 通过 Dashboard 登录 clientid 为 test 的设备: 查看“订阅”列表，可以看到 Broker 从 MySQL 里面获取到订阅关系，并代理设备订阅: 从 PostgreSQL 中获取订阅关系 搭建 PostgreSQL 数据库，以 MacOS X 为例: $ brew install postgresql $ brew services start postgresql 创建 mqtt 数据库: # 使用用户名 postgres 创建名为 'mqtt' 的数据库 $ createdb -U postgres mqtt $ psql -U postgres mqtt mqtt=> \\dn; List of schemas Name | Owner --------+------- public | postgres (1 row) 创建 mqtt_sub 表: $ psql -U postgres mqtt CREATE TABLE mqtt_sub( id SERIAL8 primary key, clientid character varying(64), topic character varying(255), qos integer, UNIQUE (clientid, topic) ); 订阅关系表结构不能修改，请使用上面SQL语句创建 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: SELECT * FROM \"$events/client_connected\" 关联动作: 在“响应动作”界面选择“添加动作”，然后在“新增动作”下拉框里选择“从PostgreSQL中获取订阅列表” 填写动作参数: “从PostgreSQL中获取订阅列表“ 动作需要一个参数： 1). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 PostgreSQL 资源： 弹出“创建资源”对话框 填写资源配置: 填写真实的 PostgreSQL 服务器地址，其他配置相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 “psql” 往PostgreSQL插入一条订阅关系 insert into mqtt_sub(clientid, topic, qos) values('test', 't1', 1)' 通过 Dashboard 登录 clientid 为 test 的设备: 查看“订阅”列表，可以看到 Broker 从 PostgreSQL 里面获取到订阅关系，并代理设备订阅: 从 MySQL 中获取订阅关系 搭建 Cassandra 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install cassandra ## 修改配置，关闭匿名认证 $ vim /usr/local/etc/cassandra/cassandra.yaml authenticator: PasswordAuthenticator authorizer: CassandraAuthorizer $ brew services start cassandra ## 创建 root 用户 $ cqlsh -ucassandra -pcassandra create user root with password 'public' superuser; 创建 \"mqtt\" 表空间: $ cqlsh -uroot -ppublic CREATE KEYSPACE mqtt WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes = true; 创建 mqtt_sub 表: CREATE TABLE mqtt_sub ( clientid text, topic text, qos int, PRIMARY KEY (clientid, topic) ) WITH CLUSTERING ORDER BY (topic ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'NONE'} AND comment = '' AND compaction = {'class': 'org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy', 'max_threshold': '32', 'min_threshold': '4'} AND compression = {'chunk_length_in_kb': '64', 'class': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1.0 AND dclocal_read_repair_chance = 0.1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND read_repair_chance = 0.0 AND speculative_retry = '99PERCENTILE'; 订阅关系表结构不能修改，请使用上面SQL语句创建 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: SELECT * FROM \"$events/client_connected\" 关联动作: 在“响应动作”界面选择“添加动作”，然后在“新增动作”下拉框里选择“从 Cassandra 中获取订阅列表” 填写动作参数: “从 Cassandra 中获取订阅列表”动作需要一个参数： 1). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 Cassandra 资源： 弹出“创建资源”对话框 填写资源配置: 填写真实的 Cassandra 服务器地址，其他配置相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 “cqlsh” 往 Cassandra 插入一条订阅关系: insert into mqtt_sub(clientid, topic, qos) values('test', 't1', 1); 通过 Dashboard 登录 clientid 为 test 的设备: 查看“订阅”列表，可以看到 Broker 从 Cassandra 里面获取到订阅关系，并代理设备订阅: 从 MongoDB 中获取订阅关系 搭建 MongoDB 数据库，并设置用户名密码为 root/public，以 MacOS X 为例: $ brew install mongodb $ brew services start mongodb ## 新增 root/public 用户 $ use mqtt; $ db.createUser({user: \"root\", pwd: \"public\", roles: [{role: \"readWrite\", db: \"mqtt\"}]}); ## 修改配置，关闭匿名认证 $ vi /usr/local/etc/mongod.conf security: authorization: enabled $ brew services restart mongodb 创建 mqtt_sub 表: $ mongo 127.0.0.1/mqtt -uroot -ppublic db.createCollection(\"mqtt_sub\"); 创建规则: 打开 emqx dashboard，选择左侧的“规则”选项卡。 然后填写规则 SQL: SELECT * FROM \"$events/client_connected\" 关联动作: 在“响应动作”界面选择“添加动作”，然后在“新增动作”下拉框里选择“从MongoDB中获取订阅列表” 填写动作参数: “从 MongoDB 中获取订阅列表”动作需要一个参数： 1). 关联资源。现在资源下拉框为空，可以点击右上角的 “新建” 来创建一个 MongoDB 资源： 弹出“创建资源”对话框 填写资源配置: 填写真实的 MongoDB 服务器地址，其他配置相应的值，然后点击 “测试连接” 按钮，确保连接测试成功。 最后点击 “确定” 按钮。 返回响应动作界面，点击 “确认”。 返回规则创建界面，点击 “创建”。 规则已经创建完成，通过 “mongo” 往MongoDB插入一条订阅关系 db.mqtt_sub.insert({clientid: \"test\", topic: \"t1\", qos: 1}) 通过 Dashboard 登录 clientid 为 test 的设备: 查看“订阅”列表，可以看到 Broker 从 MongoDB 里面获取到订阅关系，并代理设备订阅: 从 Kafka 消费消息到 EMQX 搭建 Kafka 环境，以 MaxOS X 为例: $ wget http://apache.claz.org/kafka/2.3.1/kafka_2.12-2.3.1.tgz $ tar -xzf kafka_2.12-2.3.1.tgz $ cd kafka_2.12-2.3.1 # 启动 Zookeeper $ ./bin/zookeeper-server-start.sh config/zookeeper.properties # 启动 Kafka $ ./bin/kafka-server-start.sh config/server.properties Kafka消费组不支持Kafka0.9以下版本 创建资源之前，需要提前创建Kafka主题，不然会提示错误 创建 Kafka 的主题: $ ./bin/kafka-topics.sh --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic testTopic --create 创建资源: 打开 emqx dashboard，选择左侧的 “资源” 选项卡。 点击 “新建” 按钮: 选择资源类型 “Kafka 消费组”: 填写资源参数: 1). Kafka 服务器地址 2). Kafka consumer 连接池大小 3). Kafka 的订阅主题 4). Kafka 的消息主题 5). Kafka Max Bytes (每次从 Kafka 里消费消息的最大字节数) 6). Kafka Offset Reset Policy (重置Offset策略,reset_to_latest | reset_by_subdcriber) 7). Kafka consumer 是否重连 最后点击 “确认”，资源创建完成: 资源已经创建完成，现在用Dashboard的websocket工具订阅MQTT的主题 \"TestTopic\": 使用kafka 命令行 生产一条消息: ./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic TestTopic Dashboard的websocket工具接收到了Kafka 生产的消息\"hello-kafka\": 从 Pulsar 消费消息到 EMQX 搭建 Pulsar 环境，以 MaxOS X 为例: $ wget http://apache.mirrors.hoobly.com/pulsar/pulsar-2.3.2/apache-pulsar-2.3.2-bin.tar.gz $ tar xvfz apache-pulsar-2.3.2-bin.tar.gz $ cd apache-pulsar-2.3.2 # 启动 Pulsar $ ./bin/pulsar standalone 创建 Pulsar 的主题: $ ./bin/pulsar-admin topics create-partitioned-topic -p 5 testTopic 创建资源: 打开 emqx dashboard，选择左侧的 “资源” 选项卡。 点击 “新建” 按钮: 选择资源类型 “pulsar 消费组”: 填写资源参数: 1). Pulsar 服务器地址 2). Pulsar consumer 进程数量 3). Pulsar 的订阅主题 4). EMQX 的消息主题 5). Pulsar 流控阈值 (Pulsar 流控阈值，配置 Pulsar 向消费者发送多少条消息后阻塞 Pulsar Consumer) 6). EMQX 重置流控阈值百分比 (Pulsar 流控阈值重置百分比。此配置让消费者处理完成一定数量的消息之后，提前重置 Pulsar 流控阈值。 比如，Pulsar 流控阈值 为 1000，阈值重置百分比 为 80%，则重置) 最后点击 “确认”，资源创建完成: 资源已经创建完成，现在用Dashboard的websocket工具订阅MQTT的主题 \"TestTopic\": 使用pulsar-cli 生产一条消息: ./bin/pulsar-client produce TestTopic --messages \"hello-pulsar\" Dashboard的websocket工具接收到了pulsar 生产的消息\"hello-pulsar\": .emqxee { display: none; }"},"backend/backend.html":{"url":"backend/backend.html","title":"数据存储设计","summary":null,"keywords":"","body":"数据存储数据存储设计一对一消息存储一对多消息存储客户端在线状态存储客户端代理订阅存储插件列表配置步骤Redis 数据存储配置 Redis 服务器配置 Redis 存储规则Redis 存储规则说明Redis 命令行参数说明Redis 命令行配置 ActionRedis 设备在线状态 HashRedis 保留消息 HashRedis 消息存储 HashRedis 消息确认 SETRedis 订阅存储 HashRedis SUB/UNSUB 事件发布启用 Redis 数据存储插件MySQL 数据存储配置 MySQL 服务器配置 MySQL 存储规则MySQL 存储规则说明SQL 语句参数说明SQL 语句配置 Action创建 MySQL 数据库表导入 MySQL 库表结构MySQL 设备在线状态表MySQL 主题订阅表MySQL 消息存储表MySQL 保留消息表MySQL 消息确认表启用 MySQL 数据存储插件PostgreSQL 数据存储配置 PostgreSQL 服务器配置 PostgreSQL 存储规则PostgreSQL 存储规则说明SQL 语句参数说明SQL 语句配置 Action创建 PostgreSQL 数据库导入 PostgreSQL 库表结构PostgreSQL 设备在线状态表PostgreSQL 代理订阅表PostgreSQL 消息存储表PostgreSQL 保留消息表PostgreSQL 消息确认表启用 PostgreSQL 数据存储插件MongoDB 消息存储配置 MongoDB 消息存储配置 MongoDB 服务器MongoDB 数据库初始化MongoDB 用户状态集合(Client Collection)MongoDB 用户订阅主题集合(Subscription Collection)MongoDB 发布消息集合(Message Collection)MongoDB 保留消息集合(Retain Message Collection)MongoDB 接收消息 ack 集合(Message Acked Collection)启用 MongoDB 数据存储插件Cassandra 消息存储配置 Cassandra 服务器Cassandra 创建一个 Keyspace导入 Cassandra 表结构Cassandra 用户状态表(Client Table)Cassandra 用户订阅主题表(Sub Table)Cassandra 发布消息表(Msg Table)Cassandra 保留消息表(Retain Message Table)Cassandra 接收消息 ack 表(Message Acked Table)启用 Cassandra 存储插件DynamoDB 消息存储配置 DyanmoDB 消息存储DynamoDB 数据库创建表DynamoDB 用户状态表(Client Table)DynamoDB 用户订阅主题(Subscription Table)DynamoDB 发布消息(Message Table)DynamoDB 保留消息(Retain Message Table)DynamoDB 接收消息 ack (Message Acked Table)InfluxDB 消息存储InfluxDB 配置配置 InfluxDB 消息存储OpenTSDB 消息存储配置 OpenTSDB 消息存储Timescale 消息存储配置 Timescale 消息存储数据存储 数据存储的主要使用场景包括将客户端上下线状态，订阅主题信息，消息内容，消息抵达后发送消息回执等操作记录到 Redis、MySQL、PostgreSQL、MongoDB、Cassandra 等各种数据库中。用户也可以通过订阅相关主题的方式来实现类似的功能，但是在企业版中内置了对这些持久化的支持；相比于前者，后者的执行效率更高，也能大大降低开发者的工作量。 数据存储是 EMQ X Enterprise 专属功能。 数据存储设计 一对一消息存储 Publish 端发布一条消息； Backend 将消息记录数据库中； Subscribe 端订阅主题； Backend 从数据库中获取该主题的消息； 发送消息给 Subscribe 端； Subscribe 端确认后 Backend 从数据库中移除该消息； 一对多消息存储 Publish 端发布一条消息； Backend 将消息记录在数据库中； Subscribe1 和 Subscribe2 订阅主题； Backend 从数据库中获取该主题的消息； 发送消息给 Subscribe1 和 Subscribe2； Backend 记录 Subscribe1 和 Subscribe2 已读消息位置，下次获取消息从该位置开始。 客户端在线状态存储 支持将设备上下线状态，直接存储到 Redis 或数据库。 客户端代理订阅 支持代理订阅功能，设备客户端上线时，由存储模块直接从数据库，代理加载订阅主题。 存储插件列表 EMQ X 支持 MQTT 消息直接存储 Redis、MySQL、PostgreSQL、MongoDB、Cassandra、DynamoDB、InfluxDB、OpenTSDB 数据库: 存储插件 配置文件 说明 emqx_backend_redis emqx_backend_redis.conf Redis 消息存储 emqx_backend_mysql emqx_backend_mysql.conf MySQL 消息存储 emqx_backend_pgsql emqx_backend_pgsql.conf PostgreSQL 消息存储 emqx_backend_mongo emqx_backend_mongo.conf MongoDB 消息存储 emqx_backend_cassa emqx_backend_cassa.conf Cassandra 消息存储 emqx_backend_dynamo emqx_backend_dynamo.conf DynamoDB 消息存储 emqx_backend_influxdb emqx_backend_influxdb.conf InfluxDB 消息存储 emqx_backend_opentsdb emqx_backend_opentsdb.conf OpenTSDB 消息存储 配置步骤 EMQ X 中支持不同类型的数据库的持久化，虽然在一些细节的配置上有所不同，但是任何一种类型的持久化配置主要做两步操作： 数据源连接配置：这部分主要用于配置数据库的连接信息，包括服务器地址，数据库名称，以及用户名和密码等信息，针对每种不同的数据库，这部分配置可能会有所不同； 事件注册与行为：根据不同的事件，你可以在配置文件中配置相关的行为（action），相关的行为可以是函数，也可以是SQL语句。 Redis 数据存储 配置文件: emqx_backend_redis.conf 配置 Redis 服务器 支持配置多台 Redis 服务器连接池: ## Redis 服务集群类型: single | sentinel | cluster backend.redis.pool1.type = single ## Redis 服务器地址列表 backend.redis.pool1.server = 127.0.0.1:6379 ## Redis sentinel 模式下的 sentinel 名称 ## backend.redis.pool1.sentinel = mymaster ## Redis 连接池大小 backend.redis.pool1.pool_size = 8 ## Redis 数据库名称 backend.redis.pool1.database = 0 ## Redis 密码 ## backend.redis.pool1.password = ## 订阅的 Redis channel 名称 backend.redis.pool1.channel = mqtt_channel 配置 Redis 存储规则 backend.redis.hook.client.connected.1 = {\"action\": {\"function\": \"on_client_connected\"}, \"pool\": \"pool1\"} backend.redis.hook.session.created.1 = {\"action\": {\"function\": \"on_subscribe_lookup\"}, \"pool\": \"pool1\"} backend.redis.hook.client.disconnected.1 = {\"action\": {\"function\": \"on_client_disconnected\"}, \"pool\": \"pool1\"} backend.redis.hook.session.subscribed.1 = {\"topic\": \"queue/#\", \"action\": {\"function\": \"on_message_fetch_for_queue\"}, \"pool\": \"pool1\"} backend.redis.hook.session.subscribed.2 = {\"topic\": \"pubsub/#\", \"action\": {\"function\": \"on_message_fetch_for_pubsub\"}, \"pool\": \"pool1\"} backend.redis.hook.session.subscribed.3 = {\"action\": {\"function\": \"on_retain_lookup\"}, \"pool\": \"pool1\"} backend.redis.hook.session.unsubscribed.1= {\"topic\": \"#\", \"action\": {\"commands\": [\"DEL mqtt:acked:${clientid}:${topic}\"]}, \"pool\": \"pool1\"} backend.redis.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"expired_time\" : 3600, \"pool\": \"pool1\"} backend.redis.hook.message.publish.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_retain\"}, \"expired_time\" : 3600, \"pool\": \"pool1\"} backend.redis.hook.message.publish.3 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_delete\"}, \"pool\": \"pool1\"} backend.redis.hook.message.acked.1 = {\"topic\": \"queue/#\", \"action\": {\"function\": \"on_message_acked_for_queue\"}, \"pool\": \"pool1\"} backend.redis.hook.message.acked.2 = {\"topic\": \"pubsub/#\", \"action\": {\"function\": \"on_message_acked_for_pubsub\"}, \"pool\": \"pool1\"} ## backend.redis.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch_for_keep_latest\"}, \"pool\": \"pool1\"} ## backend.redis.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_store_keep_latest\"}, \"expired_time\" : 3600, \"pool\": \"pool1\"} ## backend.redis.hook.message.acked.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_acked_for_keep_latest\"}, \"pool\": \"pool1\"} Redis 存储规则说明 hook topic action/function 说明 client.connected on_client_connected 存储客户端在线状态 session.created on_subscribe_lookup 订阅主题 client.disconnected on_client_disconnected 存储客户端离线状态 session.subscribed queue/# on_message_fetch_for_queue 获取一对一离线消息 session.subscribed pubsub/# on_message_fetch_for_pubsub 获取一对多离线消息 session.subscribed # on_retain_lookup 获取 retain 消息 session.unsubscribed # 删除 acked 消息 message.publish # on_message_publish 存储发布消息 message.publish # on_message_retain 存储 retain 消息 message.publish # on_retain_delete 删除 retain 消息 message.acked queue/# on_message_acked_for_queue 一对一消息 ACK 处理 message.acked pubsub/# on_message_acked_for_pubsub 一对多消息 ACK 处理 Redis 命令行参数说明 hook 可用参数 示例(每个字段分隔，必须是一个空格) client.connected clientid SET conn:${clientid} ${clientid} client.disconnected clientid SET disconn:${clientid} ${clientid} session.subscribed clientid, topic, qos HSET sub:${clientid} ${topic} ${qos} session.unsubscribed clientid, topic SET unsub:${clientid} ${topic} message.publish message, msgid, topic, payload, qos, clientid RPUSH pub:${topic} ${msgid} message.acked msgid, topic, clientid HSET ack:${clientid} ${topic} ${msgid} message.deliver msgid, topic, clientid HSET deliver:${clientid} ${topic} ${msgid} Redis 命令行配置 Action Redis 存储支持用户采用 Redis Commands 语句配置 Action，例如: ## 在客户端连接到 EMQ X 服务器后，执行一条 redis backend.redis.hook.client.connected.3 = {\"action\": {\"commands\": [\"SET conn:${clientid} ${clientid}\"]}, \"pool\": \"pool1\"} Redis 设备在线状态 Hash mqtt:client Hash 存储设备在线状态: hmset key = mqtt:client:${clientid} value = {state:int, online_at:timestamp, offline_at:timestamp} hset key = mqtt:node:${node} field = ${clientid} value = ${ts} 查询设备在线状态: HGETALL \"mqtt:client:${clientId}\" 例如 ClientId 为 test 客户端上线: HGETALL mqtt:client:test 1) \"state\" 2) \"1\" 3) \"online_at\" 4) \"1481685802\" 5) \"offline_at\" 6) \"undefined\" 例如 ClientId 为 test 客户端下线: HGETALL mqtt:client:test 1) \"state\" 2) \"0\" 3) \"online_at\" 4) \"1481685802\" 5) \"offline_at\" 6) \"1481685924\" Redis 保留消息 Hash mqtt:retain Hash 存储 Retain 消息: hmset key = mqtt:retain:${topic} value = {id: string, from: string, qos: int, topic: string, retain: int, payload: string, ts: timestamp} 查询 retain 消息: HGETALL \"mqtt:retain:${topic}\" 例如查看 topic 为 topic 的 retain 消息: HGETALL mqtt:retain:topic 1) \"id\" > - 2) \"6P9NLcJ65VXBbC22sYb4\" > > 3) \"from\" > > - 4) \"test\" > > 5) \"qos\" > 6) \"1\" > 7) \"topic\" > 8) \"topic\" > 9) \"retain\" > > - 10\\) \"true\" > > 11) \"payload\" > 12) \"Hello world\\!\" > 13) \"ts\" > 14) \"1481690659\" Redis 消息存储 Hash mqtt:msg Hash 存储 MQTT 消息: hmset key = mqtt:msg:${msgid} value = {id: string, from: string, qos: int, topic: string, retain: int, payload: string, ts: timestamp} zadd key = mqtt:msg:${topic} field = 1 value = ${msgid} Redis 消息确认 SET mqtt:acked SET 存储客户端消息确认: set key = mqtt:acked:${clientid}:${topic} value = ${msgid} Redis 订阅存储 Hash mqtt:sub Hash 存储订阅关系: hset key = mqtt:sub:${clientid} field = ${topic} value = ${qos} 某个客户端订阅主题: HSET mqtt:sub:${clientid} ${topic} ${qos} 例如为 ClientId 为 test 的客户端订阅主题 topic1, topic2 : HSET \"mqtt:sub:test\" \"topic1\" 1 HSET \"mqtt:sub:test\" \"topic2\" 2 查询 ClientId 为 test 的客户端已订阅主题: HGETALL mqtt:sub:test 1) \"topic1\" 2) \"1\" 3) \"topic2\" 4) \"2\" Redis SUB/UNSUB 事件发布 设备需要订阅/取消订阅主题时，业务服务器向 Redis 发布事件消息: PUBLISH channel = \"mqtt_channel\" message = {type: string , topic: string, clientid: string, qos: int} \\*type: [subscribe/unsubscribe] 例如 ClientId 为 test 客户端订阅主题 topic0: PUBLISH \"mqtt_channel\" \"{\\\"type\\\": \\\"subscribe\\\", \\\"topic\\\": \\\"topic0\\\", \\\"clientid\\\": \\\"test\\\", \\\"qos\\\": \\\"0\\\"}\" 例如 ClientId 为 test 客户端取消订阅主题: PUBLISH \"mqtt_channel\" \"{\\\"type\\\": \\\"unsubscribe\\\", \\\"topic\\\": \\\"test_topic0\\\", \\\"clientid\\\": \\\"test\\\"}\" Redis Cluster 无法使用 Redis PUB/SUB 功能。 启用 Redis 数据存储插件 ./bin/emqx_ctl plugins load emqx_backend_redis MySQL 数据存储 配置文件: emqx_backend_mysql.conf 配置 MySQL 服务器 支持配置多台 MySQL 服务器连接池: ## Mysql 服务器地址 backend.mysql.pool1.server = 127.0.0.1:3306 ## Mysql 连接池大小 backend.mysql.pool1.pool_size = 8 ## Mysql 用户名 backend.mysql.pool1.user = root ## Mysql 密码 backend.mysql.pool1.password = public ## Mysql 数据库名称 backend.mysql.pool1.database = mqtt 配置 MySQL 存储规则 backend.mysql.hook.client.connected.1 = {\"action\": {\"function\": \"on_client_connected\"}, \"pool\": \"pool1\"} backend.mysql.hook.session.created.1 = {\"action\": {\"function\": \"on_subscribe_lookup\"}, \"pool\": \"pool1\"} backend.mysql.hook.client.disconnected.1 = {\"action\": {\"function\": \"on_client_disconnected\"}, \"pool\": \"pool1\"} backend.mysql.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"pool\": \"pool1\"} backend.mysql.hook.session.subscribed.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_lookup\"}, \"pool\": \"pool1\"} backend.mysql.hook.session.unsubscribed.1= {\"topic\": \"#\", \"action\": {\"sql\": [\"delete from mqtt_acked where clientid = ${clientid} and topic = ${topic}\"]}, \"pool\": \"pool1\"} backend.mysql.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} backend.mysql.hook.message.publish.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_retain\"}, \"pool\": \"pool1\"} backend.mysql.hook.message.publish.3 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_delete\"}, \"pool\": \"pool1\"} backend.mysql.hook.message.acked.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_acked\"}, \"pool\": \"pool1\"} ## 获取离线消息 ## \"offline_opts\": 获取离线消息的配置 ## - max_returned_count: 单次拉去的最大离线消息数目 ## - time_range: 仅拉去在当前时间范围的消息 ## backend.mysql.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"offline_opts\": {\"max_returned_count\": 500, \"time_range\": \"2h\"}, \"pool\": \"pool1\"} ## 如果需要存储 Qos0 消息, 可开启以下配置 ## 警告: 当开启以下配置时, 需关闭 'on_message_fetch', 否则 qos1, qos2 消息会被存储俩次 ## backend.mysql.hook.message.publish.4 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_store\"}, \"pool\": \"pool1\"} MySQL 存储规则说明 hook topic action 说明 client.connected on_client_connected 存储客户端在线状态 session.created on_subscribe_lookup 订阅主题 client.disconnected on_client_disconnected 存储客户端离线状态 session.subscribed # on_message_fetch 获取离线消息 session.subscribed # on_retain_lookup 获取retain消息 message.publish # on_message_publish 存储发布消息 message.publish # on_message_retain 存储retain消息 message.publish # on_retain_delete 删除retain消息 message.acked # on_message_acked 消息ACK处理 SQL 语句参数说明 hook 可用参数 示例(sql语句中${name} 表示可获取的参数) client.connected clientid insert into conn(clientid) values(${clientid}) client.disconnected clientid insert into disconn(clientid) values(${clientid}) session.subscribed clientid, topic, qos insert into sub(topic, qos) values(${topic}, ${qos}) session.unsubscribed clientid, topic delete from sub where topic = ${topic} message.publish msgid, topic, payload, qos, clientid insert into msg(msgid, topic) values(${msgid}, ${topic}) message.acked msgid, topic, clientid insert into ack(msgid, topic) values(${msgid}, ${topic}) message.deliver msgid, topic, clientid insert into deliver(msgid, topic) values(${msgid}, ${topic}) SQL 语句配置 Action MySQL 存储支持用户采用 SQL 语句配置 Action: ## 在客户端连接到 EMQ X 服务器后，执行一条 sql 语句(支持多条 sql 语句) backend.mysql.hook.client.connected.3 = {\"action\": {\"sql\": [\"insert into conn(clientid) values(${clientid})\"]}, \"pool\": \"pool1\"} 创建 MySQL 数据库表 create database mqtt; 导入 MySQL 库表结构 mysql -u root -p mqtt 数据库名称可自定义 MySQL 设备在线状态表 mqtt_client 存储设备在线状态: DROP TABLE IF EXISTS `mqtt_client`; CREATE TABLE `mqtt_client` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `clientid` varchar(64) DEFAULT NULL, `state` varchar(3) DEFAULT NULL, `node` varchar(64) DEFAULT NULL, `online_at` datetime DEFAULT NULL, `offline_at` datetime DEFAULT NULL, `created` timestamp NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), KEY `mqtt_client_idx` (`clientid`), UNIQUE KEY `mqtt_client_key` (`clientid`), INDEX topic_index(`id`, `clientid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 查询设备在线状态: select * from mqtt_client where clientid = ${clientid}; 例如 ClientId 为 test 客户端上线: select * from mqtt_client where clientid = \"test\"; +----+----------+-------+----------------+---------------------+---------------------+---------------------+ | id | clientid | state | node | online_at | offline_at | created | +----+----------+-------+----------------+---------------------+---------------------+---------------------+ | 1 | test | 1 | emqx@127.0.0.1 | 2016-11-15 09:40:40 | NULL | 2016-12-24 09:40:22 | +----+----------+-------+----------------+---------------------+---------------------+---------------------+ 1 rows in set (0.00 sec) 例如 ClientId 为 test 客户端下线: select * from mqtt_client where clientid = \"test\"; +----+----------+-------+----------------+---------------------+---------------------+---------------------+ | id | clientid | state | node | online_at | offline_at | created | +----+----------+-------+----------------+---------------------+---------------------+---------------------+ | 1 | test | 0 | emqx@127.0.0.1 | 2016-11-15 09:40:40 | 2016-11-15 09:46:10 | 2016-12-24 09:40:22 | +----+----------+-------+----------------+---------------------+---------------------+---------------------+ 1 rows in set (0.00 sec) MySQL 主题订阅表 mqtt_sub 存储设备的主题订阅关系: DROP TABLE IF EXISTS `mqtt_sub`; CREATE TABLE `mqtt_sub` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `clientid` varchar(64) DEFAULT NULL, `topic` varchar(180) DEFAULT NULL, `qos` tinyint(1) DEFAULT NULL, `created` timestamp NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), KEY `mqtt_sub_idx` (`clientid`,`topic`,`qos`), UNIQUE KEY `mqtt_sub_key` (`clientid`,`topic`), INDEX topic_index(`id`, `topic`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 例如 ClientId 为 test 客户端订阅主题 test_topic1 test_topic2: insert into mqtt_sub(clientid, topic, qos) values(\"test\", \"test_topic1\", 1); insert into mqtt_sub(clientid, topic, qos) values(\"test\", \"test_topic2\", 2); 某个客户端订阅主题: select * from mqtt_sub where clientid = ${clientid}; 查询 ClientId 为 test 的客户端已订阅主题: select * from mqtt_sub where clientid = \"test\"; +----+--------------+-------------+------+---------------------+ | id | clientId | topic | qos | created | +----+--------------+-------------+------+---------------------+ | 1 | test | test_topic1 | 1 | 2016-12-24 17:09:05 | | 2 | test | test_topic2 | 2 | 2016-12-24 17:12:51 | +----+--------------+-------------+------+---------------------+ 2 rows in set (0.00 sec) MySQL 消息存储表 mqtt_msg 存储 MQTT 消息: DROP TABLE IF EXISTS `mqtt_msg`; CREATE TABLE `mqtt_msg` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `msgid` varchar(64) DEFAULT NULL, `topic` varchar(180) NOT NULL, `sender` varchar(64) DEFAULT NULL, `node` varchar(64) DEFAULT NULL, `qos` tinyint(1) NOT NULL DEFAULT '0', `retain` tinyint(1) DEFAULT NULL, `payload` blob, `arrived` datetime NOT NULL, PRIMARY KEY (`id`), INDEX topic_index(`id`, `topic`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 查询某个客户端发布的消息: select * from mqtt_msg where sender = ${clientid}; 查询 ClientId 为 test 的客户端发布的消息: select * from mqtt_msg where sender = \"test\"; +----+-------------------------------+----------+--------+------+-----+--------+---------+---------------------+ | id | msgid | topic | sender | node | qos | retain | payload | arrived | +----+-------------------------------+----------+--------+------+-----+--------+---------+---------------------+ | 1 | 53F98F80F66017005000004A60003 | hello | test | NULL | 1 | 0 | hello | 2016-12-24 17:25:12 | | 2 | 53F98F9FE42AD7005000004A60004 | world | test | NULL | 1 | 0 | world | 2016-12-24 17:25:45 | +----+-------------------------------+----------+--------+------+-----+--------+---------+---------------------+ 2 rows in set (0.00 sec) MySQL 保留消息表 mqtt_retain 存储 retain 消息: DROP TABLE IF EXISTS `mqtt_retain`; CREATE TABLE `mqtt_retain` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `topic` varchar(180) DEFAULT NULL, `msgid` varchar(64) DEFAULT NULL, `sender` varchar(64) DEFAULT NULL, `node` varchar(64) DEFAULT NULL, `qos` tinyint(1) DEFAULT NULL, `payload` blob, `arrived` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `mqtt_retain_key` (`topic`), INDEX topic_index(`id`, `topic`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 查询 retain 消息: select * from mqtt_retain where topic = ${topic}; 查询 topic 为 retain 的 retain 消息: select * from mqtt_retain where topic = \"retain\"; +----+----------+-------------------------------+---------+------+------+---------+---------------------+ | id | topic | msgid | sender | node | qos | payload | arrived | +----+----------+-------------------------------+---------+------+------+---------+---------------------+ | 1 | retain | 53F33F7E4741E7007000004B70001 | test | NULL | 1 | www | 2016-12-24 16:55:18 | +----+----------+-------------------------------+---------+------+------+---------+---------------------+ > 1 rows in set (0.00 sec) MySQL 消息确认表 mqtt_acked 存储客户端消息确认: DROP TABLE IF EXISTS `mqtt_acked`; CREATE TABLE `mqtt_acked` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `clientid` varchar(64) DEFAULT NULL, `topic` varchar(180) DEFAULT NULL, `mid` int(11) unsigned DEFAULT NULL, `created` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `mqtt_acked_key` (`clientid`,`topic`), INDEX topic_index(`id`, `topic`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8MB4; 启用 MySQL 数据存储插件 ./bin/emqx_ctl plugins load emqx_backend_mysql PostgreSQL 数据存储 配置文件: emqx_backend_pgsql.conf 配置 PostgreSQL 服务器 支持配置多台PostgreSQL服务器连接池: ## Pgsql 服务器地址 backend.pgsql.pool1.server = 127.0.0.1:5432 ## Pgsql 连接池大小 backend.pgsql.pool1.pool_size = 8 ## Pgsql 用户名 backend.pgsql.pool1.username = root ## Pgsql 密码 backend.pgsql.pool1.password = public ## Pgsql 数据库名称 backend.pgsql.pool1.database = mqtt ## Pgsql Ssl backend.pgsql.pool1.ssl = false 配置 PostgreSQL 存储规则 backend.pgsql.hook.client.connected.1 = {\"action\": {\"function\": \"on_client_connected\"}, \"pool\": \"pool1\"} backend.pgsql.hook.session.created.1 = {\"action\": {\"function\": \"on_subscribe_lookup\"}, \"pool\": \"pool1\"} backend.pgsql.hook.client.disconnected.1 = {\"action\": {\"function\": \"on_client_disconnected\"}, \"pool\": \"pool1\"} backend.pgsql.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"pool\": \"pool1\"} backend.pgsql.hook.session.subscribed.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_lookup\"}, \"pool\": \"pool1\"} backend.pgsql.hook.session.unsubscribed.1= {\"topic\": \"#\", \"action\": {\"sql\": [\"delete from mqtt_acked where clientid = ${clientid} and topic = ${topic}\"]}, \"pool\": \"pool1\"} backend.pgsql.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} backend.pgsql.hook.message.publish.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_retain\"}, \"pool\": \"pool1\"} backend.pgsql.hook.message.publish.3 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_delete\"}, \"pool\": \"pool1\"} backend.pgsql.hook.message.acked.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_acked\"}, \"pool\": \"pool1\"} ## 获取离线消息 ## \"offline_opts\": 获取离线消息的配置 ## - max_returned_count: 单次拉去的最大离线消息数目 ## - time_range: 仅拉去在当前时间范围的消息 ## backend.pgsql.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"offline_opts\": {\"max_returned_count\": 500, \"time_range\": \"2h\"}, \"pool\": \"pool1\"} ## 如果需要存储 Qos0 消息, 可开启以下配置 ## 警告: 当开启以下配置时, 需关闭 'on_message_fetch', 否则 qos1, qos2 消息会被存储俩次 ## backend.pgsql.hook.message.publish.4 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_store\"}, \"pool\": \"pool1\"} PostgreSQL 存储规则说明 hook topic action 说明 client.connected on_client_connected 存储客户端在线状态 session.created on_subscribe_lookup 订阅主题 client.disconnected on_client_disconnected 存储客户端离线状态 session.subscribed # on_message_fetch 获取离线消息 session.subscribed # on_retain_lookup 获取 retain 消息 message.publish # on_message_publish 存储发布消息 message.publish # on_message_retain 存储 retain 消息 message.publish # on_retain_delete 删除 retain 消息 message.acked # on_message_acked 消息 ACK 处理 SQL 语句参数说明 hook 可用参数 示例(sql语句中${name} 表示可获取的参数) client.connected clientid insert into conn(clientid) values(${clientid}) client.disconnected clientid insert into disconn(clientid) values(${clientid}) session.subscribed clientid, topic, qos insert into sub(topic, qos) values(${topic}, ${qos}) session.unsubscribed clientid, topic delete from sub where topic = ${topic} message.publish msgid, topic, payload, qos, clientid insert into msg(msgid, topic) values(${msgid}, ${topic}) message.acked msgid, topic, clientid insert into ack(msgid, topic) values(${msgid}, ${topic}) message.deliver msgid, topic, clientid insert into deliver(msgid, topic) values(${msgid}, ${topic}) SQL 语句配置 Action PostgreSQL 存储支持用户采用SQL语句配置 Action，例如: ## 在客户端连接到 EMQ X 服务器后，执行一条 sql 语句(支持多条sql语句) backend.pgsql.hook.client.connected.3 = {\"action\": {\"sql\": [\"insert into conn(clientid) values(${clientid})\"]}, \"pool\": \"pool1\"} 创建 PostgreSQL 数据库 createdb mqtt -E UTF8 -e 导入 PostgreSQL 库表结构 \\i etc/sql/emqx_backend_pgsql.sql PostgreSQL 设备在线状态表 mqtt_client 存储设备在线状态: CREATE TABLE mqtt_client( id SERIAL8 primary key, clientid character varying(64), state integer, node character varying(64), online_at timestamp , offline_at timestamp, created timestamp without time zone, UNIQUE (clientid) ); 查询设备在线状态: select * from mqtt_client where clientid = ${clientid}; 例如 ClientId 为 test 客户端上线: select * from mqtt_client where clientid = 'test'; id | clientid | state | node | online_at | offline_at | created ----+----------+-------+----------------+---------------------+---------------------+--------------------- 1 | test | 1 | emqx@127.0.0.1 | 2016-11-15 09:40:40 | NULL | 2016-12-24 09:40:22 (1 rows) 例如 ClientId 为 test 客户端下线: select * from mqtt_client where clientid = 'test'; id | clientid | state | nod | online_at | offline_at | created ----+----------+-------+----------------+---------------------+---------------------+--------------------- 1 | test | 0 | emqx@127.0.0.1 | 2016-11-15 09:40:40 | 2016-11-15 09:46:10 | 2016-12-24 09:40:22 (1 rows) PostgreSQL 代理订阅表 mqtt_sub 存储订阅关系: CREATE TABLE mqtt_sub( id SERIAL8 primary key, clientid character varying(64), topic character varying(255), qos integer, created timestamp without time zone, UNIQUE (clientid, topic) ); 例如 ClientId 为 test 客户端订阅主题 test_topic1 test_topic2: insert into mqtt_sub(clientid, topic, qos) values('test', 'test_topic1', 1); insert into mqtt_sub(clientid, topic, qos) values('test', 'test_topic2', 2); 某个客户端订阅主题: select * from mqtt_sub where clientid = ${clientid}; 查询 ClientId 为 test 的客户端已订阅主题: select * from mqtt_sub where clientid = 'test'; id | clientId | topic | qos | created ----+--------------+-------------+------+--------------------- 1 | test | test_topic1 | 1 | 2016-12-24 17:09:05 2 | test | test_topic2 | 2 | 2016-12-24 17:12:51 (2 rows) PostgreSQL 消息存储表 mqtt_msg 存储MQTT消息: CREATE TABLE mqtt_msg ( id SERIAL8 primary key, msgid character varying(64), sender character varying(64), topic character varying(255), qos integer, retain integer, payload text, arrived timestamp without time zone ); 查询某个客户端发布的消息: select * from mqtt_msg where sender = ${clientid}; 查询 ClientId 为 test 的客户端发布的消息: select * from mqtt_msg where sender = 'test'; id | msgid | topic | sender | node | qos | retain | payload | arrived ----+-------------------------------+----------+--------+------+-----+--------+---------+--------------------- 1 | 53F98F80F66017005000004A60003 | hello | test | NULL | 1 | 0 | hello | 2016-12-24 17:25:12 2 | 53F98F9FE42AD7005000004A60004 | world | test | NULL | 1 | 0 | world | 2016-12-24 17:25:45 (2 rows) PostgreSQL 保留消息表 mqtt_retain 存储 Retain 消息: CREATE TABLE mqtt_retain( id SERIAL8 primary key, topic character varying(255), msgid character varying(64), sender character varying(64), qos integer, payload text, arrived timestamp without time zone, UNIQUE (topic) ); 查询 retain 消息: select * from mqtt_retain where topic = ${topic}; 查询 topic 为 retain 的 retain 消息: select * from mqtt_retain where topic = 'retain'; id | topic | msgid | sender | node | qos | payload | arrived ----+----------+-------------------------------+---------+------+------+---------+--------------------- 1 | retain | 53F33F7E4741E7007000004B70001 | test | NULL | 1 | www | 2016-12-24 16:55:18 (1 rows) PostgreSQL 消息确认表 mqtt_acked 存储客户端消息确认: CREATE TABLE mqtt_acked ( id SERIAL8 primary key, clientid character varying(64), topic character varying(64), mid integer, created timestamp without time zone, UNIQUE (clientid, topic) ); 启用 PostgreSQL 数据存储插件 ./bin/emqx_ctl plugins load emqx_backend_pgsql MongoDB 消息存储 配置 MongoDB 消息存储 配置文件: emqx_backend_mongo.conf 配置 MongoDB 服务器 支持配置多台 MongoDB 服务器连接池: ## MongoDB 集群类型: single | unknown | sharded | rs backend.mongo.pool1.type = single ## 如果 type = rs; 需要配置 setname ## backend.mongo.pool1.rs_set_name = testrs ## MongoDB 服务器地址列表 backend.mongo.pool1.server = 127.0.0.1:27017 ## MongoDB 连接池大小 backend.mongo.pool1.c_pool_size = 8 ## 连接的数据库名称 backend.mongo.pool1.database = mqtt ## MongoDB 认证用户名密码 ## backend.mongo.pool1.login = emqtt ## backend.mongo.pool1.password = emqtt ## MongoDB 认证源 ## backend.mongo.pool1.auth_source = admin ## 是否开启 SSL ## backend.mongo.pool1.ssl = false ## SSL 密钥文件路径 ## backend.mongo.pool1.keyfile = ## SSL 证书文件路径 ## backend.mongo.pool1.certfile = ## SSL CA 证书文件路径 ## backend.mongo.pool1.cacertfile = ## MongoDB 数据写入模式: unsafe | safe ## backend.mongo.pool1.w_mode = safe ## MongoDB 数据读取模式: master | slaver_ok ## backend.mongo.pool1.r_mode = slave_ok ## MongoDB 底层 driver 配置, 保持默认即可 ## backend.mongo.topology.pool_size = 1 ## backend.mongo.topology.max_overflow = 0 ## backend.mongo.topology.overflow_ttl = 1000 ## backend.mongo.topology.overflow_check_period = 1000 ## backend.mongo.topology.local_threshold_ms = 1000 ## backend.mongo.topology.connect_timeout_ms = 20000 ## backend.mongo.topology.socket_timeout_ms = 100 ## backend.mongo.topology.server_selection_timeout_ms = 30000 ## backend.mongo.topology.wait_queue_timeout_ms = 1000 ## backend.mongo.topology.heartbeat_frequency_ms = 10000 ## backend.mongo.topology.min_heartbeat_frequency_ms = 1000 ## MongoDB Backend Hooks backend.mongo.hook.client.connected.1 = {\"action\": {\"function\": \"on_client_connected\"}, \"pool\": \"pool1\"} backend.mongo.hook.session.created.1 = {\"action\": {\"function\": \"on_subscribe_lookup\"}, \"pool\": \"pool1\"} backend.mongo.hook.client.disconnected.1 = {\"action\": {\"function\": \"on_client_disconnected\"}, \"pool\": \"pool1\"} backend.mongo.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"pool\": \"pool1\", \"offline_opts\": {\"time_range\": \"2h\", \"max_returned_count\": 500}} backend.mongo.hook.session.subscribed.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_lookup\"}, \"pool\": \"pool1\"} backend.mongo.hook.session.unsubscribed.1= {\"topic\": \"#\", \"action\": {\"function\": \"on_acked_delete\"}, \"pool\": \"pool1\"} backend.mongo.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} backend.mongo.hook.message.publish.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_retain\"}, \"pool\": \"pool1\"} backend.mongo.hook.message.publish.3 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_delete\"}, \"pool\": \"pool1\"} backend.mongo.hook.message.acked.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_acked\"}, \"pool\": \"pool1\"} ## 获取离线消息 ## \"offline_opts\": 获取离线消息的配置 ## - max_returned_count: 单次拉去的最大离线消息数目 ## - time_range: 仅拉去在当前时间范围的消息 ## backend.mongo.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"pool\": \"pool1\", \"offline_opts\": {\"time_range\": \"2h\", \"max_returned_count\": 500}} ## 如果需要存储 Qos0 消息, 可开启以下配置 ## 警告: 当开启以下配置时, 需关闭 'on_message_fetch', 否则 qos1, qos2 消息会被存储俩次 ## backend.mongo.hook.message.publish.4 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_store\"}, \"pool\": \"pool1\", \"payload_format\": \"mongo_json\"} backend 消息存储规则包括: hook topic action 说明 client.connected on_client_connected 存储客户端在线状态 session.created on_subscribe_lookup 订阅主题 client.disconnected on_client_disconnected 存储客户端离线状态 session.subscribed # on_message_fetch 获取离线消息 session.subscribed # on_retain_lookup 获取retain消息 session.unsubscribed # on_acked_delete 删除 acked 消息 message.publish # on_message_publish 存储发布消息 message.publish # on_message_retain 存储retain消息 message.publish # on_retain_delete 删除retain消息 message.acked # on_message_acked 消息ACK处理 MongoDB 数据库初始化 use mqtt db.createCollection(\"mqtt_client\") db.createCollection(\"mqtt_sub\") db.createCollection(\"mqtt_msg\") db.createCollection(\"mqtt_retain\") db.createCollection(\"mqtt_acked\") db.mqtt_client.ensureIndex({clientid:1, node:2}) db.mqtt_sub.ensureIndex({clientid:1}) db.mqtt_msg.ensureIndex({sender:1, topic:2}) db.mqtt_retain.ensureIndex({topic:1}) MongoDB 用户状态集合(Client Collection) mqtt_client 存储设备在线状态: { clientid: string, state: 0,1, //0离线 1在线 node: string, online_at: timestamp, offline_at: timestamp } 查询设备在线状态: db.mqtt_client.findOne({clientid: ${clientid}}) 例如 ClientId 为 test 客户端上线: db.mqtt_client.findOne({clientid: \"test\"}) { \"_id\" : ObjectId(\"58646c9bdde89a9fb9f7fb73\"), \"clientid\" : \"test\", \"state\" : 1, \"node\" : \"emqx@127.0.0.1\", \"online_at\" : 1482976411, \"offline_at\" : null } 例如 ClientId 为 test 客户端下线: db.mqtt_client.findOne({clientid: \"test\"}) { \"_id\" : ObjectId(\"58646c9bdde89a9fb9f7fb73\"), \"clientid\" : \"test\", \"state\" : 0, \"node\" : \"emqx@127.0.0.1\", \"online_at\" : 1482976411, \"offline_at\" : 1482976501 } MongoDB 用户订阅主题集合(Subscription Collection) mqtt_sub 存储订阅关系: { clientid: string, topic: string, qos: 0,1,2 } 用户 test 分别订阅主题 test_topic0 test_topic1 test_topic2: db.mqtt_sub.insert({clientid: \"test\", topic: \"test_topic1\", qos: 1}) db.mqtt_sub.insert({clientid: \"test\", topic: \"test_topic2\", qos: 2}) 某个客户端订阅主题: db.mqtt_sub.find({clientid: ${clientid}}) 查询 ClientId 为 \"test\" 的客户端已订阅主题: db.mqtt_sub.find({clientid: \"test\"}) { \"_id\" : ObjectId(\"58646d90c65dff6ac9668ca1\"), \"clientid\" : \"test\", \"topic\" : \"test_topic1\", \"qos\" : 1 } { \"_id\" : ObjectId(\"58646d96c65dff6ac9668ca2\"), \"clientid\" : \"test\", \"topic\" : \"test_topic2\", \"qos\" : 2 } MongoDB 发布消息集合(Message Collection) mqtt_msg 存储 MQTT 消息: { _id: int, topic: string, msgid: string, sender: string, qos: 0,1,2, retain: boolean (true, false), payload: string, arrived: timestamp } 查询某个客户端发布的消息: db.mqtt_msg.find({sender: ${clientid}}) 查询 ClientId 为 \"test\" 的客户端发布的消息: db.mqtt_msg.find({sender: \"test\"}) { \"_id\" : 1, \"topic\" : \"/World\", \"msgid\" : \"AAVEwm0la4RufgAABeIAAQ==\", \"sender\" : \"test\", \"qos\" : 1, \"retain\" : 1, \"payload\" : \"Hello world!\", \"arrived\" : 1482976729 } MongoDB 保留消息集合(Retain Message Collection) mqtt_retain 存储 Retain 消息: { topic: string, msgid: string, sender: string, qos: 0,1,2, payload: string, arrived: timestamp } 查询 retain 消息: db.mqtt_retain.findOne({topic: ${topic}}) 查询topic为 \"t/retain\" 的 retain 消息: db.mqtt_retain.findOne({topic: \"t/retain\"}) { \"_id\" : ObjectId(\"58646dd9dde89a9fb9f7fb75\"), \"topic\" : \"t/retain\", \"msgid\" : \"AAVEwm0la4RufgAABeIAAQ==\", \"sender\" : \"c1\", \"qos\" : 1, \"payload\" : \"Hello world!\", \"arrived\" : 1482976729 } MongoDB 接收消息 ack 集合(Message Acked Collection) mqtt_acked 存储客户端消息确认: { clientid: string, topic: string, mongo_id: int } 启用 MongoDB 数据存储插件 ./bin/emqx_ctl plugins load emqx_backend_mongo Cassandra 消息存储 配置 Cassandra 服务器 配置文件: emqx_backend_cassa.conf 支持配置多台Cassandra服务器连接池: ## Cassandra 节点地址 backend.ecql.pool1.nodes = 127.0.0.1:9042 ## Cassandra 连接池大小 backend.ecql.pool1.size = 8 ## Cassandra 自动重连间隔(s) backend.ecql.pool1.auto_reconnect = 1 ## Cassandra 认证用户名/密码 backend.ecql.pool1.username = cassandra backend.ecql.pool1.password = cassandra ## Cassandra Keyspace backend.ecql.pool1.keyspace = mqtt ## Cassandra Logger type backend.ecql.pool1.logger = info ##-------------------------------------------------------------------- ## Cassandra Backend Hooks ##-------------------------------------------------------------------- ## Client Connected Record backend.cassa.hook.client.connected.1 = {\"action\": {\"function\": \"on_client_connected\"}, \"pool\": \"pool1\"} ## Subscribe Lookup Record backend.cassa.hook.session.created.1 = {\"action\": {\"function\": \"on_subscription_lookup\"}, \"pool\": \"pool1\"} ## Client DisConnected Record backend.cassa.hook.client.disconnected.1 = {\"action\": {\"function\": \"on_client_disconnected\"}, \"pool\": \"pool1\"} ## Lookup Unread Message QOS > 0 backend.cassa.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"pool\": \"pool1\"} ## Lookup Retain Message backend.cassa.hook.session.subscribed.2 = {\"action\": {\"function\": \"on_retain_lookup\"}, \"pool\": \"pool1\"} ## Store Publish Message QOS > 0 backend.cassa.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} ## Delete Acked Record backend.cassa.hook.session.unsubscribed.1= {\"topic\": \"#\", action\": {\"cql\": [\"delete from acked where client_id = ${clientid} and topic = ${topic}\"]}, \"pool\": \"pool1\"} ## Store Retain Message backend.cassa.hook.message.publish.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_retain\"}, \"pool\": \"pool1\"} ## Delete Retain Message backend.cassa.hook.message.publish.3 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_delete\"}, \"pool\": \"pool1\"} ## Store Ack backend.cassa.hook.message.acked.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_acked\"}, \"pool\": \"pool1\"} ## 获取离线消息 ## \"offline_opts\": 获取离线消息的配置 ## - max_returned_count: 单次拉去的最大离线消息数目 ## - time_range: 仅拉去在当前时间范围的消息 ## backend.cassa.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch\"}, \"offline_opts\": {\"max_returned_count\": 500, \"time_range\": \"2h\"}, \"pool\": \"pool1\"} ## 如果需要存储 Qos0 消息, 可开启以下配置 ## 警告: 当开启以下配置时, 需关闭 'on_message_fetch', 否则 qos1, qos2 消息会被存储俩次 ## backend.cassa.hook.message.publish.4 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_store\"}, \"pool\": \"pool1\"} backend 消息存储规则包括: hook topic action 说明 client.connected on_client_connected 存储客户端在线状态 session.created on_subscribe_lookup 订阅主题 client.disconnected on_client_disconnected 存储客户端离线状态 session.subscribed # on_message_fetch 获取离线消息 session.subscribed # on_retain_lookup 获取retain消息 session.unsubscribed # 删除 akced 消息 message.publish # on_message_publish 存储发布消息 message.publish # on_message_retain 存储retain消息 message.publish # on_retain_delete 删除retain消息 message.acked # on_message_acked 消息ACK处理 自定义 CQL 语句 可用参数包括: hook 可用参数 示例(cql语句中${name} 表示可获取的参数) client.connected clientid insert into conn(clientid) values(${clientid}) client.disconnected clientid insert into disconn(clientid) values(${clientid}) session.subscribed clientid, topic, qos insert into sub(topic, qos) values(${topic}, ${qos}) session.unsubscribed clientid, topic delete from sub where topic = ${topic} message.publish msgid, topic, payload, qos, clientid insert into msg(msgid, topic) values(${msgid}, ${topic}) message.acked msgid, topic, clientid insert into ack(msgid, topic) values(${msgid}, ${topic}) message.deliver msgid, topic, clientid insert into deliver(msgid, topic) values(${msgid}, ${topic}) 支持 CQL 语句配置: 考虑到用户的需求不同, backend cassandra 自带的函数无法满足用户需求, 用户可根据自己的需求配置 cql 语句 在 etc/plugins/emqx_backend_cassa.conf 中添加如下配置: ## 在客户端连接到 EMQ X 服务器后，执行一条 cql 语句(支持多条 cql 语句) backend.cassa.hook.client.connected.3 = {\"action\": {\"cql\": [\"insert into conn(clientid) values(${clientid})\"]}, \"pool\": \"pool1\"} Cassandra 创建一个 Keyspace CREATE KEYSPACE mqtt WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes = true; USR mqtt; 导入 Cassandra 表结构 cqlsh -e \"SOURCE 'emqx_backend_cassa.cql'\" Cassandra 用户状态表(Client Table) mqtt.client 存储设备在线状态: CREATE TABLE mqtt.client ( client_id text PRIMARY KEY, connected timestamp, disconnected timestamp, node text, state int ); 查询设备在线状态: select * from mqtt.client where client_id = ${clientid}; 例如 ClientId 为 test 的客户端上线: select * from mqtt.client where client_id = 'test'; client_id | connected | disconnected | node | state -----------+---------------------------------+---------------+-----------------+------- test | 2017-02-14 08:27:29.872000+0000 | null | emqx@127.0.0.1| 1 例如ClientId为test客户端下线: select * from mqtt.client where client_id = 'test'; client_id | connected | disconnected | node | state -----------+---------------------------------+---------------------------------+-----------------+------- test | 2017-02-14 08:27:29.872000+0000 | 2017-02-14 08:27:35.872000+0000 | emqx@127.0.0.1| 0 Cassandra 用户订阅主题表(Sub Table) mqtt.sub 存储订阅关系: CREATE TABLE mqtt.sub ( client_id text, topic text, qos int, PRIMARY KEY (client_id, topic) ); 用户test分别订阅主题test_topic1 test_topic2: insert into mqtt.sub(client_id, topic, qos) values('test', 'test_topic1', 1); insert into mqtt.sub(client_id, topic, qos) values('test', 'test_topic2', 2); 某个客户端订阅主题: select * from mqtt_sub where clientid = ${clientid}; 查询ClientId为'test'的客户端已订阅主题: select * from mqtt_sub where clientid = 'test'; client_id | topic | qos -----------+-------------+------ test | test_topic1 | 1 test | test_topic2 | 2 Cassandra 发布消息表(Msg Table) mqtt.msg 存储MQTT消息: CREATE TABLE mqtt.msg ( topic text, msgid text, arrived timestamp, payload text, qos int, retain int, sender text, PRIMARY KEY (topic, msgid) ) WITH CLUSTERING ORDER BY (msgid DESC); 查询某个客户端发布的消息: select * from mqtt_msg where sender = ${clientid}; 查询ClientId为'test'的客户端发布的消息: select * from mqtt_msg where sender = 'test'; topic | msgid | arrived | payload | qos | retain | sender -------+----------------------+---------------------------------+--------------+-----+--------+-------- hello | 2PguFrHsrzEvIIBdctmb | 2017-02-14 09:07:13.785000+0000 | Hello world! | 1 | 0 | test world | 2PguFrHsrzEvIIBdctmb | 2017-02-14 09:07:13.785000+0000 | Hello world! | 1 | 0 | test Cassandra 保留消息表(Retain Message Table) mqtt.retain 存储 Retain 消息: CREATE TABLE mqtt.retain ( topic text PRIMARY KEY, msgid text ); 查询 retain 消息: select * from mqtt_retain where topic = ${topic}; 查询 topic 为 't/retain' 的 retain 消息: select * from mqtt_retain where topic = 't/retain'; topic | msgid --------+---------------------- retain | 2PguFrHsrzEvIIBdctmb Cassandra 接收消息 ack 表(Message Acked Table) mqtt.acked 存储客户端消息确认: CREATE TABLE mqtt.acked ( client_id text, topic text, msgid text, PRIMARY KEY (client_id, topic) ); 启用 Cassandra 存储插件 ./bin/emqx_ctl plugins load emqx_backend_cassa DynamoDB 消息存储 配置 DyanmoDB 消息存储 配置文件: etc/plugins/emqx_backend_dynamo.conf ## DynamoDB Region backend.dynamo.region = us-west-2 ## DynamoDB Server backend.dynamo.pool1.server = http://localhost:8000 ## DynamoDB Pool Size backend.dynamo.pool1.pool_size = 8 ## AWS ACCESS KEY ID backend.dynamo.pool1.aws_access_key_id = AKIAU5IM2XOC7AQWG7HK ## AWS SECRET ACCESS KEY backend.dynamo.pool1.aws_secret_access_key = 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 ## DynamoDB Backend Hooks backend.dynamo.hook.client.connected.1 = {\"action\": {\"function\": \"on_client_connected\"}, \"pool\": \"pool1\"} backend.dynamo.hook.session.created.1 = {\"action\": {\"function\": \"on_subscribe_lookup\"}, \"pool\": \"pool1\"} backend.dynamo.hook.client.disconnected.1 = {\"action\": {\"function\": \"on_client_disconnected\"}, \"pool\": \"pool1\"} backend.dynamo.hook.session.subscribed.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_fetch_for_queue\"}, \"pool\": \"pool1\"} backend.dynamo.hook.session.subscribed.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_lookup\"}, \"pool\": \"pool1\"} backend.dynamo.hook.session.unsubscribed.1= {\"topic\": \"#\", \"action\": {\"function\": \"on_acked_delete\"}, \"pool\": \"pool1\"} backend.dynamo.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} backend.dynamo.hook.message.publish.2 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_retain\"}, \"pool\": \"pool1\"} backend.dynamo.hook.message.publish.3 = {\"topic\": \"#\", \"action\": {\"function\": \"on_retain_delete\"}, \"pool\": \"pool1\"} backend.dynamo.hook.message.acked.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_acked_for_queue\"}, \"pool\": \"pool1\"} # backend.dynamo.hook.message.publish.4 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_store\"}, \"pool\": \"pool1\"} backend 消息存储规则包括: hook topic action 说明 client.connected on_client_connected 存储客户端在线状态 client.connected on_subscribe_lookup 订阅主题 client.disconnected on_client_disconnected 存储客户端离线状态 session.subscribed # on_message_fetch_for_queue 获取一对一离线消息 session.subscribed # on_retain_lookup 获取retain消息 message.publish # on_message_publish 存储发布消息 message.publish # on_message_retain 存储retain消息 message.publish # on_retain_delete 删除retain消息 message.acked # on_message_acked_for_queue 一对一消息ACK处理 DynamoDB 数据库创建表 ./test/dynamo_test.sh DynamoDB 用户状态表(Client Table) mqtt_client 表定义(存储设备在线状态): { \"TableName\": \"mqtt_client\", \"KeySchema\": [ { \"AttributeName\": \"clientid\", \"KeyType\": \"HASH\" } ], \"AttributeDefinitions\": [ { \"AttributeName\": \"clientid\", \"AttributeType\": \"S\" } ], \"ProvisionedThroughput\": { \"ReadCapacityUnits\": 5, \"WriteCapacityUnits\": 5 } } 查询设备在线状态: aws dynamodb scan --table-name mqtt_client --region us-west-2 --endpoint-url http://localhost:8000 { \"Items\": [ { \"offline_at\": { \"N\": \"0\" }, \"node\": { \"S\": \"emqx@127.0.0.1\" }, \"clientid\": { \"S\": \"mqttjs_384b9c73a9\" }, \"connect_state\": { \"N\": \"1\" }, \"online_at\": { \"N\": \"1562224940\" } } ], \"Count\": 1, \"ScannedCount\": 1, \"ConsumedCapacity\": null } DynamoDB 用户订阅主题(Subscription Table) mqtt_sub 表定义(存储订阅关系): { \"TableName\": \"mqtt_sub\", \"KeySchema\": [ { \"AttributeName\": \"clientid\", \"KeyType\": \"HASH\" }, { \"AttributeName\": \"topic\", \"KeyType\": \"RANGE\" } ], \"AttributeDefinitions\": [ { \"AttributeName\": \"clientid\", \"AttributeType\": \"S\" }, { \"AttributeName\": \"topic\", \"AttributeType\": \"S\" } ], \"ProvisionedThroughput\": { \"ReadCapacityUnits\": 5, \"WriteCapacityUnits\": 5 } } 查询 ClientId 为 \"test-dynamo\" 的客户端已订阅主题: aws dynamodb scan --table-name mqtt_sub --region us-west-2 --endpoint-url http://localhost:8000 { \"Items\": [{\"qos\": { \"N\": \"2\" }, \"topic\": { \"S\": \"test-dynamo-sub\" }, \"clientid\": { \"S\": \"test-dynamo\" }}, {\"qos\": { \"N\": \"2\" }, \"topic\": { \"S\": \"test-dynamo-sub-1\"}, \"clientid\": { \"S\": \"test-dynamo\" }}, {\"qos\": { \"N\": \"2\" }, \"topic\": { \"S\": \"test-dynamo-sub-2\"}, \"clientid\": { \"S\": \"test-dynamo\" }}], \"Count\": 3, \"ScannedCount\": 3, \"ConsumedCapacity\": null } DynamoDB 发布消息(Message Table) mqtt_msg 表定义(存储 MQTT 消息): { \"TableName\": \"mqtt_msg\", \"KeySchema\": [ { \"AttributeName\": \"msgid\", \"KeyType\": \"HASH\" } ], \"AttributeDefinitions\": [ { \"AttributeName\": \"msgid\", \"AttributeType\": \"S\" } ], \"ProvisionedThroughput\": { \"ReadCapacityUnits\": 5, \"WriteCapacityUnits\": 5 } } mqtt_topic_msg_map 表定义(存储主题和消息的映射关系): { \"TableName\": \"mqtt_topic_msg_map\", \"KeySchema\": [ { \"AttributeName\": \"topic\", \"KeyType\": \"HASH\" } ], \"AttributeDefinitions\": [ { \"AttributeName\": \"topic\", \"AttributeType\": \"S\" } ], \"ProvisionedThroughput\": { \"ReadCapacityUnits\": 5, \"WriteCapacityUnits\": 5 } } 某个客户端向主题 test 发布消息后，查询 mqtt_msg 表和 mqtt_topic_msg_map 表: 查询 mqtt_msg 表: aws dynamodb scan --table-name mqtt_msg --region us-west-2 --endpoint-url http://localhost:8000 > - { > > - \"Items\": \\[ > > - { > \"arrived\": { \"N\": \"1562308553\" }, \"qos\": { \"N\": \"1\" }, > \"sender\": { \"S\": \"mqttjs_231b962d5c\" }, \"payload\": { \"S\": > \"{ \"msg\": \"Hello, World\\!\" }\"}, \"retain\": { \"N\": \"0\" }, > \"msgid\": { \"S\": > \"Mjg4MTk1MDYwNTk0NjYwNzYzMTg4MDk3OTQ2MDU2Nzg1OTD\" }, > \"topic\": { \"S\": \"test\" } > > } > > \\], \"Count\": 1, \"ScannedCount\": 1, \"ConsumedCapacity\": null > > } 查询 mqtt_topic_msg_map 表： aws dynamodb scan --table-name mqtt_topic_msg_map --region us-west-2 --endpoint-url http://localhost:8000 > - { > > - \"Items\": \\[ > > - { > \"topic\": { \"S\": \"test\" }, \"MsgId\": { \"SS\": \\[ > \"Mjg4MTk1MDYwNTk0NjYwNzYzMTg4MDk3OTQ2MDU2Nzg1OTD\" \\]} > > } > > \\], \"Count\": 1, \"ScannedCount\": 1, \"ConsumedCapacity\": null > > } DynamoDB 保留消息(Retain Message Table) mqtt_retain 表定义(存储 retain 消息): { \"TableName\": \"mqtt_retain\", \"KeySchema\": [ { \"AttributeName\": \"topic\", \"KeyType\": \"HASH\" } ], \"AttributeDefinitions\": [ { \"AttributeName\": \"topic\", \"AttributeType\": \"S\" } ], \"ProvisionedThroughput\": { \"ReadCapacityUnits\": 5, \"WriteCapacityUnits\": 5 } } 某个客户端向主题 test 发布消息后，查询 mqtt_retain 表: { \"Items\": [ { \"arrived\": { \"N\": \"1562312113\" }, \"qos\": { \"N\": \"1\" }, \"sender\": { \"S\": \"mqttjs_d0513acfce\" }, \"payload\": { \"S\": \"test\" }, \"retain\": { \"N\": \"1\" }, \"msgid\": { \"S\": \"Mjg4MTk1NzE3MTY4MjYxMjA5MDExMDg0NTk5ODgzMjAyNTH\" }, \"topic\": { \"S\": \"testtopic\" } } ], \"Count\": 1, \"ScannedCount\": 1, \"ConsumedCapacity\": null } DynamoDB 接收消息 ack (Message Acked Table) mqtt_acked 表定义(存储确认的消息): { \"TableName\": \"mqtt_acked\", \"KeySchema\": [ { \"AttributeName\": \"topic\", \"KeyType\": \"HASH\" }, { \"AttributeName\": \"clientid\", \"KeyType\": \"RANGE\" } ], \"AttributeDefinitions\": [ { \"AttributeName\": \"topic\", \"AttributeType\": \"S\" }, { \"AttributeName\": \"clientid\", \"AttributeType\": \"S\" } ], \"ProvisionedThroughput\": { \"ReadCapacityUnits\": 5, \"WriteCapacityUnits\": 5 } } 某个客户端向主题 test 发布消息后，查询 mqtt_acked 表: { \"Items\": [ { \"topic\": { \"S\": \"test\" }, \"msgid\": { \"S\": \"Mjg4MTk1MDYwNTk0NjYwNzYzMTg4MDk3OTQ2MDU2Nzg1OTD\" }, \"clientid\": { \"S\": \"mqttjs_861e582a70\" } } ], \"Count\": 1, \"ScannedCount\": 1, \"ConsumedCapacity\": null } 启用 DynamoDB 消息存储: ./bin/emqx_ctl plugins load emqx_backend_dynamo InfluxDB 消息存储 InfluxDB 配置 EMQ X 仅支持通过 UDP 协议连接 InfluxDB，需要修改 InfluxDB 配置文件： [[udp]] enabled = true bind-address = \":8089\" # 消息保存的数据库 database = \"emqx\" # InfluxDB precision for timestamps on received points (\"\" or \"n\", \"u\", \"ms\", \"s\", \"m\", \"h\") # EMQ X 默认时间戳是毫秒 precision = \"ms\" # 其他配置根据需要自行修改 # batch-size = 1000 # batch-pending = 5 # batch-timeout = \"5s\" # read-buffer = 1024 配置 InfluxDB 消息存储 配置文件: etc/plugins/emqx_backend_influxdb.conf: ## InfluxDB UDP 服务地址 backend.influxdb.pool1.server = 127.0.0.1:8089 ## InfluxDB 连接池大小 backend.influxdb.pool1.pool_size = 5 ## 是否自动添加 timestamp ## 如果设为 true，请将 InfluxDB UDP 配置中的 precision 设为 \"ms\" backend.influxdb.pool1.set_timestamp = true ## 存储 PUBLISH 消息 backend.influxdb.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} InfluxDB Backend 消息存储规则参数: Option Description topic 配置哪些主题下的消息需要执行 hook action 配置 hook 具体动作, function 为 Backend 提供的内置函数, 实现通用功能 pool Pool Name, 实现连接多个 InfluxDB Server 功能 Example: ## 存储主题为 \"sensor/#\" 的 PUBLISH 消息 backend.influxdb.hook.message.publish.1 = {\"topic\": \"sensor/#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} ## 存储主题为 \"stat/#\" 的 PUBLISH 消息 backend.influxdb.hook.message.publish.2 = {\"topic\": \"stat/#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} InfluxDB Backend 支持 Hook 与 相应内置函数列表: Hook Function list message.publish on_message_publish 由于 MQTT Message 无法直接写入 InfluxDB, InfluxDB Backend 提供了 emqx_backend_influxdb.tmpl 模板文件将 MQTT Message 转换为可写入 InfluxDB 的 DataPoint。 模板文件采用 JSON 格式, 组成部分: key - MQTT Topic, 字符串, 支持通配符 value - Template, Json 对象, 用于将 MQTT Message 转换成 measurement,tag_key=tag_value,... field_key=field_value,... timestamp 的形式以写入 InfluxDB。 你可以为不同 Topic 定义不同的 Template, 也可以为同一个 Topic 定义多个 Template, 类似: { : , : } Template 格式如下: { \"measurement\": , \"tags\": { : }, \"fields\": { : }, \"timestamp\": } measurement 与 fields 为必选项, tags 与 timestamp 为可选项。 所有的值 (例如 ) 你都可以直接在 Template 中配置为一个固定值, 它支持的数据类型依赖于你定义的数据表。当然更符合实际情况的是，你可以通过我们提供的占位符来获取 MQTT 消息中的数据。 目前我们支持的占位符如下: Placeholder Description $id MQTT 消息 UUID, 由 EMQ X 分配 $clientid 客户端使用的 Client ID $username 客户端使用的 Username $peerhost 客户端 IP $qos MQTT 消息的 QoS $topic MQTT 消息主题 $payload MQTT 消息载荷, 必须为合法的 Json $\\ 必须配合 $paylaod 使用, 用于从 Json Array 中获取数据 $timestamp EMQ X 准备转发消息时设置的时间戳, 精度: 纳秒 $payload 与 $\\: \b你可以直接使用 $payload 取得完整的消息载荷, 也可以通过 [\"$payload\", , ...] 取得消息载荷内部的数据。 例如 payload 为 {\"data\": {\"temperature\": 23.9}}, 你可以通过占位符 [\"$payload\", \"data\", \"temperature\"] 来获取其中的 23.9。 考虑到 Json 还有数组这一数据类型的情况, 我们引入了 $0 与 $, $0 表示获取数组内所有元素, $ 表示获取数组内第 个元素。 一个简单例子, [\"$payload\", \"$0\", \"temp\"] 将从 [{\"temp\": 20}, {\"temp\": 21}] 中取得 [20, 21], 而 [\"$payload\", \"$1\", \"temp\"] 将只取得 20。 值得注意的是, 当你使用 $0 时，我们希望你取得的数据个数都是相等的。因为我们需要将这些数组转换为多条记录写入 InfluxDB, 而当你一个字段取得了 3 份数据, 另一个字段却取得了 2 份数据, 我们将无从判断应当怎样为你组合这些数据。 Example data/templates 目录下提供了一个示例模板 (emqx_backend_influxdb_example.tmpl, 正式使用时请去掉文件名中的 \"_example\" 后缀) 供用户参考: { \"sample\": { \"measurement\": \"$topic\", \"tags\": { \"host\": [\"$payload\", \"data\", \"$0\", \"host\"], \"region\": [\"$payload\", \"data\", \"$0\", \"region\"], \"qos\": \"$qos\", \"clientid\": \"$clientid\" }, \"fields\": { \"temperature\": [\"$payload\", \"data\", \"$0\", \"temp\"] }, \"timestamp\": \"$timestamp\" } } 当 Template 中设置 timestamp 或插件配置 backend.influxdb.pool1.set_timestamp = true 时，请将 InfluxDB UDP 配置中的 precision 设为 \"ms\"。 当 Topic 为 \"sample\" 的 MQTT Message 拥有以下 Payload 时: { \"data\": [ { \"temp\": 1, \"host\": \"serverA\", \"region\": \"hangzhou\" }, { \"temp\": 2, \"host\": \"serverB\", \"region\": \"ningbo\" } ] } Backend 会将 MQTT Message 转换为: [ { \"measurement\": \"sample\", \"tags\": { \"clientid\": \"mqttjs_ebcc36079a\", \"host\": \"serverA\", \"qos\": \"0\", \"region\": \"hangzhou\", }, \"fields\": { \"temperature\": \"1\" }, \"timestamp\": \"1560743513626681000\" }, { \"measurement\": \"sample\", \"tags\": { \"clientid\": \"mqttjs_ebcc36079a\", \"host\": \"serverB\", \"qos\": \"0\", \"region\": \"ningbo\", }, \"fields\": { \"temperature\": \"2\" }, \"timestamp\": \"1560743513626681000\" } ] 最终编码为以下数据写入 InfluxDB: \"sample,clientid=mqttjs_6990f0e886,host=serverA,qos=0,region=hangzhou temperature=\\\"1\\\" 1560745505429670000\\nsample,clientid=mqttjs_6990f0e886,host=serverB,qos=0,region=ningbo temperature=\\\"2\\\" 1560745505429670000\\n\" 启用 InfluxDB 消息存储: ./bin/emqx_ctl plugins load emqx_backend_influxdb OpenTSDB 消息存储 配置 OpenTSDB 消息存储 配置文件：etc/plugins/emqx_backend_opentsdb.conf: ## OpenTSDB 服务地址 backend.opentsdb.pool1.server = 127.0.0.1:4242 ## OpenTSDB 连接池大小 backend.opentsdb.pool1.pool_size = 8 ## 是否返回 summary info ## ## Value: true | false backend.opentsdb.pool1.summary = true ## 是否返回 detailed info ## ## Value: true | false backend.opentsdb.pool1.details = false ## 是否同步写入 ## ## Value: true | false backend.opentsdb.pool1.sync = false ## 同步写入超时时间，单位毫秒 ## ## Value: Duration ## ## Default: 0 backend.opentsdb.pool1.sync_timeout = 0 ## 最大批量写条数 ## ## Value: Number >= 0 ## Default: 20 backend.opentsdb.pool1.max_batch_size = 20 ## 存储 PUBLISH 消息 backend.opentsdb.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} OpenTSDB Backend 消息存储规则参数: Option Description topic 配置哪些主题下的消息需要执行 hook action 配置 hook 具体动作, function 为 Backend 提供的内置函数, 实现通用功能 pool Pool Name, 实现连接多个 OpenTSDB Server 功能 示例: ## 存储主题为 \"sensor/#\" 的 PUBLISH 消息 backend.influxdb.hook.message.publish.1 = {\"topic\": \"sensor/#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} ## 存储主题为 \"stat/#\" 的 PUBLISH 消息 backend.influxdb.hook.message.publish.2 = {\"topic\": \"stat/#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} OpenTSDB Backend 支持 Hook 与 相应内置函数列表: Hook Function list message.publish on_message_publish 由于 MQTT Message 无法直接写入 OpenTSDB, OpenTSDB Backend 提供了 emqx_backend_opentsdb.tmpl 模板文件将 MQTT Message 转换为可写入 OpenTSDB 的 DataPoint。 模板文件采用 Json 格式, 组成部分: key - MQTT Topic, 字符串, 支持通配符主题 value - Template, Json 对象, 用于将 MQTT Message 转换成 OpenTSDB 的 DataPoint。 你可以为不同 Topic 定义不同的 Template, 也可以为同一个 Topic 定义多个 Template, 类似: { : , : } Template 格式如下: { \"measurement\": , \"tags\": { : }, \"value\": , \"timestamp\": } measurement 与 value 为必选项, tags 与 timestamp 为可选项。 所有的值 (例如 ) 你都可以直接在 Template 中配置为一个固定值, 它支持的数据类型依赖于你定义的数据表。当然更符合实际情况的是，你可以通过我们提供的占位符来获取 MQTT 消息中的数据。 目前我们支持的占位符如下: Placeholder Description $id MQTT 消息 UUID, 由 EMQ X 分配 $clientid 客户端使用的 Client ID $username 客户端使用的 Username $peerhost 客户端 IP $qos MQTT 消息的 QoS $topic MQTT 消息主题 $payload MQTT 消息载荷, 必须为合法的 Json $\\ 必须配合 $paylaod 使用, 用于从 Json Array 中获取数据 $timestamp EMQ X 准备转发消息时设置的时间戳, 精度: 毫秒 $payload 与 $\\: \b你可以直接使用 $payload 取得完整的消息载荷, 也可以通过 [\"$payload\", , ...] 取得消息载荷内部的数据。 例如 payload 为 {\"data\": {\"temperature\": 23.9}}, 你可以通过占位符 [\"$payload\", \"data\", \"temperature\"] 来获取其中的 23.9。 考虑到 Json 还有数组这一数据类型的情况, 我们引入了 $0 与 $, $0 表示获取数组内所有元素, $ 表示获取数组内第 个元素。 一个简单例子, [\"$payload\", \"$0\", \"temp\"] 将从 [{\"temp\": 20}, {\"temp\": 21}] 中取得 [20, 21], 而 [\"$payload\", \"$1\", \"temp\"] 将只取得 20。 值得注意的是, 当你使用 $0 时，我们希望你取得的数据个数都是相等的。因为我们需要将这些数组转换为多条记录写入 OpenTSDB, 而当你一个字段取得了 3 份数据, 另一个字段却取得了 2 份数据, 我们将无从判断应当怎样为你组合这些数据。 Example data/templates 目录下提供了一个示例模板 (emqx_backend_opentsdb_example.tmpl, 正式使用时请去掉文件名中的 \"_example\" 后缀) 供用户参考: { \"sample\": { \"measurement\": \"$topic\", \"tags\": { \"host\": [\"$payload\", \"data\", \"$0\", \"host\"], \"region\": [\"$payload\", \"data\", \"$0\", \"region\"], \"qos\": \"$qos\", \"clientid\": \"$clientid\" }, \"value\": [\"$payload\", \"data\", \"$0\", \"temp\"], \"timestamp\": \"$timestamp\" } } 当 Topic 为 \"sample\" 的 MQTT Message 拥有以下 Payload 时: { \"data\": [ { \"temp\": 1, \"host\": \"serverA\", \"region\": \"hangzhou\" }, { \"temp\": 2, \"host\": \"serverB\", \"region\": \"ningbo\" } ] } Backend 将 MQTT Message 转换为以下数据写入 OpenTSDB: [ { \"measurement\": \"sample\", \"tags\": { \"clientid\": \"mqttjs_ebcc36079a\", \"host\": \"serverA\", \"qos\": \"0\", \"region\": \"hangzhou\", }, \"value\": \"1\", \"timestamp\": \"1560743513626681000\" }, { \"measurement\": \"sample\", \"tags\": { \"clientid\": \"mqttjs_ebcc36079a\", \"host\": \"serverB\", \"qos\": \"0\", \"region\": \"ningbo\", }, \"value\": \"2\", \"timestamp\": \"1560743513626681000\" } ] 启用 OpenTSDB 消息存储: ./bin/emqx_ctl plugins load emqx_backend_opentsdb Timescale 消息存储 配置 Timescale 消息存储 etc/plugins/emqx_backend_timescale.conf: ## Timescale Server backend.timescale.pool1.server = 127.0.0.1:5432 ## Timescale Pool Size backend.timescale.pool1.pool_size = 8 ## Timescale Username backend.timescale.pool1.username = postgres ## Timescale Password backend.timescale.pool1.password = password ## Timescale Database backend.timescale.pool1.database = tutorial ## Timescale SSL backend.timescale.pool1.ssl = false ## SSL keyfile. ## ## Value: File ## backend.timescale.pool1.keyfile = ## SSL certfile. ## ## Value: File ## backend.timescale.pool1.certfile = ## SSL cacertfile. ## ## Value: File ## backend.timescale.pool1.cacertfile = ## Store Publish Message backend.timescale.hook.message.publish.1 = {\"topic\": \"#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} Timescale Backend 消息存储规则参数: Option Description topic 配置哪些主题下的消息需要执行 hook action 配置 hook 具体动作, function 为 Backend 提供的内置函数, 实现通用功能 pool Pool Name, 实现连接多个 Timescale Server 功能 Example: ## Store Publish message with \"sensor/#\" topic backend.timescale.hook.message.publish.1 = {\"topic\": \"sensor/#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} ## Store Publish message with \"stat/#\" topic backend.timescale.hook.message.publish.2 = {\"topic\": \"stat/#\", \"action\": {\"function\": \"on_message_publish\"}, \"pool\": \"pool1\"} Timescale Backend 支持 Hook 与 相应内置函数列表: Hook Function list message.publish on_message_publish Timescale Backend 提供 emqx_backend_timescale.tmpl 模板文件，用于从不同主题的 MQTT Message 中提取数据以写入 Timescale。 模板文件采用 Json 格式, 组成部分: key - MQTT Topic, 字符串, 支持通配符主题 value - Template, Json 对象, 用于将 MQTT Message 转换成 measurement,tag_key=tag_value,... field_key=field_value,... timestamp 的形式以写入 InfluxDB。 你可以为不同 Topic 定义不同的 Template, 也可以为同一个 Topic 定义多个 Template, 类似: { : , : } Template 格式如下: { \"name\": , \"sql\": , \"param_keys\": } name, sql 和 param_keys 都是必选项。 name 可以是任意的字符串，确保没有重复即可。 sql 为 Timescale 可用的 SQL INSERT INTO 语句，例如：insert into sensor_data(time, location, temperature, humidity) values (NOW(), $1, $2, $3)。 param_keys 是一个数组，它的第一个元素对应 sql 中出现的 $1，并以此类推。 数组中任意元素都可以是一个固定值, 它支持的数据类型依赖于你定义的数据表。当然更符合实际情况的是，你可以通过我们提供的占位符来获取 MQTT 消息中的数据。 目前我们支持的占位符如下: Placeholder Description $id MQTT 消息 UUID, 由 EMQ X 分配 $clientid 客户端使用的 Client ID $username 客户端使用的 Username $peerhost 客户端 IP $qos MQTT 消息的 QoS $topic MQTT 消息主题 $payload MQTT 消息载荷, 必须为合法的 Json $\\ 必须配合 $paylaod 使用, 用于从 Json Array 中获取数据 $timestamp EMQ X 准备转发消息时设置的时间戳, 精度: 毫秒 $payload 与 $\\: \b你可以直接使用 $payload 取得完整的消息载荷, 也可以通过 [\"$payload\", , ...] 取得消息载荷内部的数据。 例如 payload 为 {\"data\": {\"temperature\": 23.9}}, 你可以通过占位符 [\"$payload\", \"data\", \"temperature\"] 来获取其中的 23.9。 考虑到 Json 还有数组这一数据类型的情况, 我们引入了 $0 与 $, $0 表示获取数组内所有元素, $ 表示获取数组内第 个元素。 一个简单例子, [\"$payload\", \"$0\", \"temp\"] 将从 [{\"temp\": 20}, {\"temp\": 21}] 中取得 [20, 21], 而 [\"$payload\", \"$1\", \"temp\"] 将只取得 20。 值得注意的是, 当你使用 $0 时，我们希望你取得的数据个数都是相等的。因为我们需要将这些数组转换为多条记录写入 Timescale, 而当你一个字段取得了 3 份数据, 另一个字段却取得了 2 份数据, 我们将无从判断应当怎样为你组合这些数据。 Example data/templates 目录下提供了一个示例模板 (emqx_backend_timescale_example.tmpl, 正式使用时请去掉文件名中的 \"_example\" 后缀) 供用户参考: { \"sensor_data\": { \"name\": \"insert_sensor_data\", \"sql\": \"insert into sensor_data(time, location, temperature, humidity) values (NOW(), $1, $2, $3)\", \"param_keys\": [ [\"$payload\", \"data\", \"$0\", \"location\"], [\"$payload\", \"data\", \"$0\", \"temperature\"], [\"$payload\", \"data\", \"$0\", \"humidity\"] ] }, \"sensor_data2/#\": { \"name\": \"insert_sensor_data2\", \"sql\": \"insert into sensor_data(time, location, temperature, humidity) values (NOW(), $1, $2, $3)\", \"param_keys\": [ [\"$payload\", \"location\"], [\"$payload\", \"temperature\"], [\"$payload\", \"humidity\"] ] }, \"easy_data\": { \"name\": \"insert_easy_data\", \"sql\": \"insert into easy_data(time, data) values (NOW(), $1)\", \"param_keys\": [ \"$payload\" ] } } 当 Topic 为 \"sensor_data\" 的 MQTT Message 拥有以下 Payload 时: { \"data\":[ { \"location\":\"bedroom\", \"temperature\":21.3, \"humidity\":40.3 }, { \"location\":\"bathroom\", \"temperature\":22.3, \"humidity\":61.8 }, { \"location\":\"kitchen\", \"temperature\":29.5, \"humidity\":58.7 } ] } [\"$payload\", \"data\", \"$0\", \"location\"] 会先获取 MQTT Message 的 Payload，如果 Payload 为 json 格式，则继续尝试读取 data。data 的值是数组，这里我们用到了 \"$0\" 表示获取数组中所有的元素，因此 [\"$payload\", \"data\", \"$0\", \"location\"] 将帮我们获得 [\"bedroom\", \"bathroom\", \"kitchen\"]。相应的，如果将 \"$0\" 替换为 \"$1\"，将只获得 [\"bedroom\"]。相应的，如果将 那么在这个场景中，我们将得到以下 SQL 语句: insert into sensor_data(time, location, temperature, humidity) values (NOW(), 'bedroom', 21.3, 40.3) insert into sensor_data(time, location, temperature, humidity) values (NOW(), 'bathroom', 22.3, 61.8) insert into sensor_data(time, location, temperature, humidity) values (NOW(), 'kitchen', 29.5, 58.7) 最终 Timescale Backend 执行这些 SQL 语句将数据写入 Timescale。 .emqxee { display: none; }"},"bridge/bridge.html":{"url":"bridge/bridge.html","title":"MQTT 桥接","summary":null,"keywords":"","body":"桥接MQTT 桥接配置 MQTT 桥接的 Broker 地址配置 MQTT 桥接转发和订阅主题MQTT 桥接转发和订阅主题说明启用 bridge_mqtt 桥接插件桥接 CLI 命令列出全部 bridge 状态启动指定 bridge停止指定 bridge列出指定 bridge 的转发主题添加指定 bridge 的转发主题删除指定 bridge 的转发主题列出指定 bridge 的订阅添加指定 bridge 的订阅主题删除指定 bridge 的订阅主题RPC 桥接配置 RPC 桥接的 Broker 地址配置 MQTT 桥接转发和订阅主题MQTT 桥接转发和订阅主题说明桥接 CLI 命令Kafka 桥接配置 Kafka 集群地址配置 Kafka 桥接规则Kafka 桥接规则说明客户端上下线事件转发 Kafka客户端订阅主题事件转发 Kafka客户端取消订阅主题事件转发 KafkaMQTT 消息转发到 KafkaMQTT 消息派发 (Deliver) 事件转发 KafkaMQTT 消息确认 (Ack) 事件转发 KafkaKafka 消费示例启用 Kafka 桥接插件RabbitMQ 桥接配置 RabbitMQ 桥接地址配置 RabbitMQ 桥接规则客户端订阅主题事件转发 RabbitMQ客户端取消订阅事件转发 RabbitMQMQTT 消息转发 RabbitMQMQTT 消息确认 (Ack) 事件转发 RabbitMQRabbitMQ 订阅消费 MQTT 消息示例启用 RabbitMQ 桥接插件Pulsar 桥接配置 Pulsar 集群地址配置 Pulsar 桥接规则Pulsar 桥接规则说明客户端上下线事件转发 Pulsar客户端订阅主题事件转发 Pulsar客户端取消订阅主题事件转发 PulsarMQTT 消息转发到 PulsarMQTT 消息派发 (Deliver) 事件转发 PulsarMQTT 消息确认 (Ack) 事件转发 PulsarPulsar 消费示例启用 Pulsar 桥接插件RocketMQ 桥接配置 RocketMQ 集群地址配置 RocketMQ 桥接规则RocketMQ 桥接规则说明客户端上下线事件转发 RocketMQ客户端订阅主题事件转发 RocketMQ客户端取消订阅主题事件转发 RocketMQMQTT 消息转发到 RocketMQMQTT 消息派发 (Deliver) 事件转发 RocketMQMQTT 消息确认 (Ack) 事件转发 RocketMQRocketMQ 消费示例启用 RocketMQ 桥接插件桥接 EMQ X 企业版桥接转发 MQTT 消息到 Kafka、RabbitMQ、Pulsar、RocketMQ、MQTT Broker 或其他 EMQ X 节点。 桥接是一种连接多个 EMQ X 或者其他 MQTT 消息中间件的方式。不同于集群，工作在桥接模式下的节点之间不会复制主题树和路由表。桥接模式所做的是： 按照规则把消息转发至桥接节点； 从桥接节点订阅主题，并在收到消息后在本节点/集群中转发该消息。 --------- --------- --------- Publisher --> | Node1 | --Bridge Forward--> | Node2 | --Bridge Forward--> | Node3 | --> Subscriber --------- --------- --------- 工作在桥接模式下和工作在集群模式下有不同的应用场景，桥接可以完成一些单纯使用集群无法实现的功能： 跨 VPC 部署。由于桥接不需要复制主题树和路由表，对于网络稳定性和延迟的要求相对于集群更低，桥接模式下不同的节点可以部署在不同的 VPC 上，客户端可以选择物理上比较近的节点连接，提高整个应用的覆盖能力。 支持异构节点。由于桥接的本质是对消息的转发和订阅，所以理论上凡是支持 MQTT 协议的消息中间件都可以被桥接到 EMQ X，甚至一些使用其他协议的消息服务，如果有协议适配器，也可以通过桥接转发消息过去。 提高单个应用的服务上限。由于内部的系统开销，单个的 EMQ X 有节点数上限。如果将多个集群桥接起来，按照业务需求设计桥接规则，可以将应用的服务上限再提高一个等级。 在具体应用中，一个桥接的发起节点可以被近似的看作一个远程节点的客户端。 桥接插件列表 存储插件 配置文件 说明 emqx_bridge_mqtt emqx_bridge_mqtt.conf MQTT Broker 消息转发 emqx_bridge_kafka emqx_bridge_kafka.conf Kafka 消息队列 emqx_bridge_rabbit emqx_bridge_rabbit.conf RabbitMQ 消息队列 emqx_bridge_pulsar emqx_bridge_pulsar.conf Pulsar 消息队列 emqx_bridge_rocket emqx_bridge_rocket.conf RocketMQ 消息队列 EMQ X Broker 中仅适用以下操作： MQTT 桥接 RPC 桥接 其余均是 EMQ X Enterprise 专属功能，推荐使用规则引擎 以实现更灵活的桥接功能。 推荐使用规则引擎 以实现更灵活的桥接功能。 MQTT 桥接 EMQ X 桥接转发 MQTT 消息到 MQTT Broker，支持桥接至常见 MQTT 云服务: mqtt bridge 桥接插件配置文件: etc/plugins/emqx_bridge_mqtt.conf。 配置 MQTT 桥接的 Broker 地址 ## 桥接地址： 使用节点名则用于 rpc 桥接，使用 host:port 用于 mqtt 连接 bridge.mqtt.aws.address = 127.0.0.1:1883 ## 桥接的协议版本 ## 枚举值: mqttv3 | mqttv4 | mqttv5 bridge.mqtt.aws.proto_ver = mqttv4 ## mqtt 连接是否启用桥接模式 bridge.mqtt.aws.bridge_mode = true ## mqtt 客户端的 client_id bridge.mqtt.aws.client_id = bridge_aws ## mqtt 客户端的 clean_start 字段 ## 注: 有些 MQTT Broker 需要将 clean_start 值设成 `true` bridge.mqtt.aws.clean_start = true ## mqtt 客户端的 username 字段 bridge.mqtt.aws.username = user ## mqtt 客户端的 password 字段 bridge.mqtt.aws.password = passwd ## mqtt 客户端是否使用 ssl 来连接远程服务器 bridge.mqtt.aws.ssl = off ## 客户端 SSL 连接的 CA 证书 (PEM格式) bridge.mqtt.aws.cacertfile = etc/certs/cacert.pem ## 客户端 SSL 连接的 SSL 证书 bridge.mqtt.aws.certfile = etc/certs/client-cert.pem ## 客户端 SSL 连接的密钥文件 bridge.mqtt.aws.keyfile = etc/certs/client-key.pem ## SSL 加密算法 bridge.mqtt.aws.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384 ## TLS PSK 的加密算法 ## 注意 'listener.ssl.external.ciphers' 和 'listener.ssl.external.psk_ciphers' 不能同时配置 ## ## See 'https://tools.ietf.org/html/rfc4279#section-2'. bridge.mqtt.aws.psk_ciphers = PSK-AES128-CBC-SHA,PSK-AES256-CBC-SHA,PSK-3DES-EDE-CBC-SHA,PSK-RC4-SHA ## 客户端的心跳间隔 bridge.mqtt.aws.keepalive = 60s ## 支持的 TLS 版本 bridge.mqtt.aws.tls_versions = tlsv1.2,tlsv1.1,tlsv1 配置 MQTT 桥接转发和订阅主题 ## 桥接的 mountpoint(挂载点) bridge.mqtt.aws.mountpoint = bridge/aws/${node}/ ## 转发消息的主题 bridge.mqtt.aws.forwards = topic1/#,topic2/# ## 用于桥接的订阅主题 bridge.mqtt.aws.subscription.1.topic = cmd/topic1 ## 用于桥接的订阅 qos bridge.mqtt.aws.subscription.1.qos = 1 ## 用于桥接的订阅主题 bridge.mqtt.aws.subscription.2.topic = cmd/topic2 ## 用于桥接的订阅 qos bridge.mqtt.aws.subscription.2.qos = 1 MQTT 桥接转发和订阅主题说明 挂载点 Mountpoint: mountpoint 用于在转发消息时加上主题前缀，该配置选项须配合 forwards 使用，转发主题为 sensor1/hello 的消息, 到达远程节点时主题为 bridge/aws/emqx1@192.168.1.1/sensor1/hello。 转发主题 Forwards: 转发到本地 EMQX 指定 forwards 主题上的消息都会被转发到远程 MQTT Broker 上。 订阅主题 Subscription: 本地 EMQX 通过订阅远程 MQTT Broker 的主题来将远程 MQTT Broker 上的消息同步到本地。 启用 bridge_mqtt 桥接插件 ./bin/emqx_ctl plugins load emqx_bridge_mqtt 桥接 CLI 命令 $ cd emqx1/ && ./bin/emqx_ctl bridges bridges list # List bridges bridges start # Start a bridge bridges stop # Stop a bridge bridges forwards # Show a bridge forward topic bridges add-forward # Add bridge forward topic bridges del-forward # Delete bridge forward topic bridges subscriptions # Show a bridge subscriptions topic bridges add-subscription # Add bridge subscriptions topic 列出全部 bridge 状态 $ ./bin/emqx_ctl bridges list name: emqx status: Stopped 启动指定 bridge $ ./bin/emqx_ctl bridges start emqx Start bridge successfully. 停止指定 bridge $ ./bin/emqx_ctl bridges stop emqx Stop bridge successfully. 列出指定 bridge 的转发主题 $ ./bin/emqx_ctl bridges forwards emqx topic: topic1/# topic: topic2/# 添加指定 bridge 的转发主题 $ ./bin/emqx_ctl bridges add-forwards emqx topic3/# Add-forward topic successfully. 删除指定 bridge 的转发主题 $ ./bin/emqx_ctl bridges del-forwards emqx topic3/# Del-forward topic successfully. 列出指定 bridge 的订阅 $ ./bin/emqx_ctl bridges subscriptions emqx topic: cmd/topic1, qos: 1 topic: cmd/topic2, qos: 1 添加指定 bridge 的订阅主题 $ ./bin/emqx_ctl bridges add-subscription emqx cmd/topic3 1 Add-subscription topic successfully. 删除指定 bridge 的订阅主题 $ ./bin/emqx_ctl bridges del-subscription emqx cmd/topic3 Del-subscription topic successfully. RPC 桥接 EMQ X 桥接转发 MQTT 消息到远程 EMQ X: rpc bridge 桥接插件配置文件: etc/plugins/emqx_bridge_mqtt.conf 配置 RPC 桥接的 Broker 地址 bridge.mqtt.emqx.address = emqx2@192.168.1.2 配置 MQTT 桥接转发和订阅主题 ## 桥接的 mountpoint(挂载点) bridge.mqtt.emqx.mountpoint = bridge/emqx1/${node}/ ## 转发消息的主题 bridge.mqtt.emqx.forwards = topic1/#,topic2/# MQTT 桥接转发和订阅主题说明 挂载点 Mountpoint: mountpoint 用于在转发消息时加上主题前缀，该配置选项须配合 forwards 使用，转发主题为 sensor1/hello 的消息, 到达远程节点时主题为 bridge/aws/emqx1@192.168.1.1/sensor1/hello。 转发主题 Forwards: 转发到本地 EMQX 指定 forwards 主题上的消息都会被转发到远程 MQTT Broker 上。 桥接 CLI 命令 桥接 CLI 的使用方式与 mqtt bridge 相同。 Kafka 桥接 EMQ X 桥接转发 MQTT 消息到 Kafka 集群，Apache Kafka是一个快速、高可扩展、高吞吐的分布式日志系统，配合kafka Stream，在流式数据处理中非常常用。 Kafka 桥接插件配置文件: etc/plugins/emqx_bridge_kafka.conf。 配置 Kafka 集群地址 ## Kafka 服务器地址 ## bridge.kafka.servers = 127.0.0.1:9092,127.0.0.2:9092,127.0.0.3:9092 bridge.kafka.servers = 127.0.0.1:9092 ## Kafka 分区策略。可选值: per_partition | per_broker bridge.kafka.connection_strategy = per_partition bridge.kafka.min_metadata_refresh_interval = 5S ## Produce 写类型。可选值: sync | async bridge.kafka.produce = sync bridge.kafka.produce.sync_timeout = 3S ## 指定 replayq 在磁盘上存储消息的基本目录。 ## 如果该配置项缺失活着设置为 undefined, replayq 将以使用内存的 ## 的方式工作。也就是说，消息不在磁盘上排队 -- 在这种情况下，send ## 和 send_async API 的调用者负责处理在应用程序、网络或 kafka ## 干扰时可能丢失的消息。 ## bridge.kafka.replayq_dir = /tmp/emqx_bridge_kafka/ ## default=10MB, replayq 分段大小。 ## bridge.kafka.producer.replayq_seg_bytes = 10MB ## producer required_acks. 可选值: all_isr | leader_only | none. bridge.kafka.producer.required_acks = none ## default=10000. leader 在回复 producer 前等待副本的超时时间。 bridge.kafka.producer.ack_timeout = 10S ## 收集到一次 produce 请求中的最大字节数 bridge.kafka.producer.max_batch_bytes = 1024KB ## 收集到一次 produce 请求中的最少字节数 bridge.kafka.producer.min_batch_bytes = 0 ## 在没有接收到上次请求的 ack 的情况下，可以提前发送的 batch 数。 ## 如果消息必须严格按照顺序传递，则必须为0。 bridge.kafka.producer.max_send_ahead = 0 ## 默认为无压缩 ## bridge.kafka.producer.compression = no_compression ## 默认值为 base64, 可选值: base64 | plain ## bridge.kafka.encode_payload_type = base64 ## bridge.kafka.sock.buffer = 32KB ## bridge.kafka.sock.recbuf = 32KB bridge.kafka.sock.sndbuf = 1MB ## bridge.kafka.sock.read_packets = 20 配置 Kafka 桥接规则 ## Bridge Kafka Hooks ## ${topic}: the kafka topics to which the messages will be published. ## ${filter}: the mqtt topic (may contain wildcard) on which the action will be performed. ## Client Connected Record Hook bridge.kafka.hook.client.connected.1 = {\"topic\": \"client_connected\"} ## Client Disconnected Record Hook bridge.kafka.hook.client.disconnected.1 = {\"topic\": \"client_disconnected\"} ## Session Subscribed Record Hook bridge.kafka.hook.session.subscribed.1 = {\"filter\": \"#\", \"topic\": \"session_subscribed\"} ## Session Unsubscribed Record Hook bridge.kafka.hook.session.unsubscribed.1 = {\"filter\": \"#\", \"topic\": \"session_unsubscribed\"} ## Message Publish Record Hook bridge.kafka.hook.message.publish.1 = {\"filter\": \"#\", \"topic\": \"message_publish\"} ## Message Delivered Record Hook bridge.kafka.hook.message.delivered.1 = {\"filter\": \"#\", \"topic\": \"message_delivered\"} ## Message Acked Record Hook bridge.kafka.hook.message.acked.1 = {\"filter\": \"#\", \"topic\": \"message_acked\"} ## More Configures ## partitioner strategy: ## Option: random | roundrobin | first_key_dispatch ## Example: bridge.kafka.hook.message.publish.1 = {\"filter\":\"#\", \"topic\":\"message_publish\", \"strategy\":\"random\"} ## key: ## Option: ${clientid} | ${username} ## Example: bridge.kafka.hook.message.publish.1 = {\"filter\":\"#\", \"topic\":\"message_publish\", \"key\":\"${clientid}\"} ## format: ## Option: json | json ## Example: bridge.kafka.hook.message.publish.1 = {\"filter\":\"#\", \"topic\":\"message_publish\", \"format\":\"json\"} Kafka 桥接规则说明 事件 说明 bridge.kafka.hook.client.connected.1 客户端登录 bridge.kafka.hook.client.disconnected.1 客户端退出 bridge.kafka.hook.session.subscribed.1 订阅主题 bridge.kafka.hook.session.unsubscribed.1 取消订阅主题 bridge.kafka.hook.message.publish.1 发布消息 bridge.kafka.hook.message.delivered.1 delivered 消息 bridge.kafka.hook.message.acked.1 ACK 消息 客户端上下线事件转发 Kafka 设备上线 EMQ X 转发上线事件消息到 Kafka: topic = \"client_connected\", value = { \"client_id\": ${clientid}, \"username\": ${username}, \"node\": ${node}, \"ts\": ${ts} } 设备下线 EMQ X 转发下线事件消息到 Kafka: topic = \"client_disconnected\", value = { \"client_id\": ${clientid}, \"username\": ${username}, \"reason\": ${reason}, \"node\": ${node}, \"ts\": ${ts} } 客户端订阅主题事件转发 Kafka topic = session_subscribed value = { \"client_id\": ${clientid}, \"topic\": ${topic}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } 客户端取消订阅主题事件转发 Kafka topic = session_unsubscribed value = { \"client_id\": ${clientid}, \"topic\": ${topic}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息转发到 Kafka topic = message_publish value = { \"client_id\": ${clientid}, \"username\": ${username}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息派发 (Deliver) 事件转发 Kafka topic = message_delivered value = { \"client_id\": ${clientid}, \"username\": ${username}, \"from\": ${fromClientId}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息确认 (Ack) 事件转发 Kafka topic = message_acked value = { \"client_id\": ${clientid}, \"username\": ${username}, \"from\": ${fromClientId}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } Kafka 消费示例 Kafka 读取 MQTT 客户端上下线事件消息: kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic client_connected --from-beginning kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic client_disconnected --from-beginning Kafka 读取 MQTT 主题订阅事件消息: kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic session_subscribed --from-beginning kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic session_unsubscribed --from-beginning Kafka 读取 MQTT 发布消息: kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic message_publish --from-beginning Kafka 读取 MQTT 消息发布 (Deliver)、确认 (Ack)事件: kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic message_delivered --from-beginning kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic message_acked --from-beginning 默认 payload 被 base64 编码，可通过修改配置 bridge.kafka.encode_payload_type 指定 payload 数据格式。 启用 Kafka 桥接插件 ./bin/emqx_ctl plugins load emqx_bridge_kafka RabbitMQ 桥接 EMQ X 桥接转发 MQTT 消息到 RabbitMQ 集群: RabbitMQ 桥接插件配置文件: etc/plugins/emqx_bridge_rabbit.conf。 配置 RabbitMQ 桥接地址 ## RabbitMQ 的服务器地址 bridge.rabbit.1.server = 127.0.0.1:5672 ## RabbitMQ 的连接池大小 bridge.rabbit.1.pool_size = 4 ## RabbitMQ 的用户名 bridge.rabbit.1.username = guest ## RabbitMQ 的密码 bridge.rabbit.1.password = guest ## RabbitMQ 的虚拟 Host bridge.rabbit.1.virtual_host = / ## RabbitMQ 的心跳间隔 bridge.rabbit.1.heartbeat = 0 # bridge.rabbit.2.server = 127.0.0.1:5672 # bridge.rabbit.2.pool_size = 8 # bridge.rabbit.2.username = guest # bridge.rabbit.2.password = guest # bridge.rabbit.2.virtual_host = / # bridge.rabbit.2.heartbeat = 0 配置 RabbitMQ 桥接规则 ## Bridge Hooks bridge.rabbit.hook.client.subscribe.1 = {\"action\": \"on_client_subscribe\", \"rabbit\": 1, \"exchange\": \"direct:emq.subscription\"} bridge.rabbit.hook.client.unsubscribe.1 = {\"action\": \"on_client_unsubscribe\", \"rabbit\": 1, \"exchange\": \"direct:emq.unsubscription\"} bridge.rabbit.hook.message.publish.1 = {\"topic\": \"$SYS/#\", \"action\": \"on_message_publish\", \"rabbit\": 1, \"exchange\": \"topic:emq.$sys\"} bridge.rabbit.hook.message.publish.2 = {\"topic\": \"#\", \"action\": \"on_message_publish\", \"rabbit\": 1, \"exchange\": \"topic:emq.pub\"} bridge.rabbit.hook.message.acked.1 = {\"topic\": \"#\", \"action\": \"on_message_acked\", \"rabbit\": 1, \"exchange\": \"topic:emq.acked\"} 客户端订阅主题事件转发 RabbitMQ routing_key = subscribe exchange = emq.subscription headers = [{>, binary, ClientId}] payload = jsx:encode([{Topic, proplists:get_value(qos, Opts)} || {Topic, Opts} 客户端取消订阅事件转发 RabbitMQ routing_key = unsubscribe exchange = emq.unsubscription headers = [{>, binary, ClientId}] payload = jsx:encode([Topic || {Topic, _Opts} MQTT 消息转发 RabbitMQ routing_key = binary:replace(binary:replace(Topic, >, >, [global]),>, >, [global]) exchange = emq.$sys | emq.pub headers = [{>, byte, Qos}, {>, binary, pub_from(From)}, {>, binary, emqx_base62:encode(Id)}, {>, binary, Topic}] payload = Payload MQTT 消息确认 (Ack) 事件转发 RabbitMQ routing_key = puback exchange = emq.acked headers = [{>, binary, ClientId}], payload = emqx_base62:encode(Id) RabbitMQ 订阅消费 MQTT 消息示例 Python RabbitMQ消费者代码示例: #!/usr/bin/env python import pika import sys connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost')) channel = connection.channel() channel.exchange_declare(exchange='direct:emq.subscription', exchange_type='direct') result = channel.queue_declare(exclusive=True) queue_name = result.method.queue channel.queue_bind(exchange='direct:emq.subscription', queue=queue_name, routing_key= 'subscribe') def callback(ch, method, properties, body): print(\" [x] %r:%r\" % (method.routing_key, body)) channel.basic_consume(callback, queue=queue_name, no_ack=True) channel.start_consuming() 其他语言 RabbitMQ 客户端代码示例: [https://github.com/rabbitmq/rabbitmq-tutorials](https://github.com/rabbitmq/rabbitmq-tutorials) 启用 RabbitMQ 桥接插件 ./bin/emqx_ctl plugins load emqx_bridge_rabbit Pulsar 桥接 EMQ X 桥接转发 MQTT 消息到 Pulsar 集群: Pulsar 桥接插件配置文件: etc/plugins/emqx_bridge_pulsar.conf。 配置 Pulsar 集群地址 ## Pulsar 服务器集群配置 ## bridge.pulsar.servers = 127.0.0.1:6650,127.0.0.2:6650,127.0.0.3:6650 bridge.pulsar.servers = 127.0.0.1:6650 ## 分区生产者是同步/异步模式选择 bridge.pulsar.produce = sync ## 生产者同步模式下的超时时间 ## bridge.pulsar.produce.sync_timeout = 3s ## 生产者 batch 的消息数量 ## bridge.pulsar.producer.batch_size = 1000 ## 默认情况下不为生产者启用压缩选项 ## bridge.pulsar.producer.compression = no_compression ## 采用 base64 编码或不编码 ## bridge.pulsar.encode_payload_type = base64 ## bridge.pulsar.sock.buffer = 32KB ## bridge.pulsar.sock.recbuf = 32KB bridge.pulsar.sock.sndbuf = 1MB ## bridge.pulsar.sock.read_packets = 20 配置 Pulsar 桥接规则 ## Bridge Pulsar Hooks ## ${topic}: the pulsar topics to which the messages will be published. ## ${filter}: the mqtt topic (may contain wildcard) on which the action will be performed . ## Client Connected Record Hook bridge.pulsar.hook.client.connected.1 = {\"topic\": \"client_connected\"} ## Client Disconnected Record Hook bridge.pulsar.hook.client.disconnected.1 = {\"topic\": \"client_disconnected\"} ## Session Subscribed Record Hook bridge.pulsar.hook.session.subscribed.1 = {\"filter\": \"#\", \"topic\": \"session_subscribed\"} ## Session Unsubscribed Record Hook bridge.pulsar.hook.session.unsubscribed.1 = {\"filter\": \"#\", \"topic\": \"session_unsubscribed\"} ## Message Publish Record Hook bridge.pulsar.hook.message.publish.1 = {\"filter\": \"#\", \"topic\": \"message_publish\"} ## Message Delivered Record Hook bridge.pulsar.hook.message.delivered.1 = {\"filter\": \"#\", \"topic\": \"message_delivered\"} ## Message Acked Record Hook bridge.pulsar.hook.message.acked.1 = {\"filter\": \"#\", \"topic\": \"message_acked\"} ## More Configures ## partitioner strategy: ## Option: random | roundrobin | first_key_dispatch ## Example: bridge.pulsar.hook.message.publish.1 = {\"filter\":\"#\", \"topic\":\"message_publish\", \"strategy\":\"random\"} ## key: ## Option: ${clientid} | ${username} ## Example: bridge.pulsar.hook.message.publish.1 = {\"filter\":\"#\", \"topic\":\"message_publish\", \"key\":\"${clientid}\"} ## format: ## Option: json | json ## Example: bridge.pulsar.hook.message.publish.1 = {\"filter\":\"#\", \"topic\":\"message_publish\", \"format\":\"json\"} Pulsar 桥接规则说明 事件 说明 bridge.pulsar.hook.client.connected.1 客户端登录 bridge.pulsar.hook.client.disconnected.1 客户端退出 bridge.pulsar.hook.session.subscribed.1 订阅主题 bridge.pulsar.hook.session.unsubscribed.1 取消订阅主题 bridge.pulsar.hook.message.publish.1 发布消息 bridge.pulsar.hook.message.delivered.1 delivered 消息 bridge.pulsar.hook.message.acked.1 ACK 消息 客户端上下线事件转发 Pulsar 设备上线 EMQ X 转发上线事件消息到 Pulsar: topic = \"client_connected\", value = { \"client_id\": ${clientid}, \"username\": ${username}, \"node\": ${node}, \"ts\": ${ts} } 设备下线 EMQ X 转发下线事件消息到 Pulsar: topic = \"client_disconnected\", value = { \"client_id\": ${clientid}, \"username\": ${username}, \"reason\": ${reason}, \"node\": ${node}, \"ts\": ${ts} } 客户端订阅主题事件转发 Pulsar topic = session_subscribed value = { \"client_id\": ${clientid}, \"topic\": ${topic}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } 客户端取消订阅主题事件转发 Pulsar topic = session_unsubscribed value = { \"client_id\": ${clientid}, \"topic\": ${topic}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息转发到 Pulsar topic = message_publish value = { \"client_id\": ${clientid}, \"username\": ${username}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息派发 (Deliver) 事件转发 Pulsar topic = message_delivered value = { \"client_id\": ${clientid}, \"username\": ${username}, \"from\": ${fromClientId}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息确认 (Ack) 事件转发 Pulsar topic = message_acked value = { \"client_id\": ${clientid}, \"username\": ${username}, \"from\": ${fromClientId}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } Pulsar 消费示例 Pulsar 读取 MQTT 客户端上下线事件消息: pulsar-client consume client_connected -s \"client_connected\" -n 1000 pulsar-client consume client_disconnected -s \"client_disconnected\" -n 1000 Pulsar 读取 MQTT 主题订阅事件消息: pulsar-client consume session_subscribed -s \"session_subscribed\" -n 1000 pulsar-client consume session_unsubscribed -s \"session_unsubscribed\" -n 1000 Pulsar 读取 MQTT 发布消息: pulsar-client consume message_publish -s \"message_publish\" -n 1000 Pulsar 读取 MQTT 消息发布 (Deliver)、确认 (Ack)事件: pulsar-client consume message_delivered -s \"message_delivered\" -n 1000 pulsar-client consume message_acked -s \"message_acked\" -n 1000 默认 payload 被 base64 编码，可通过修改配置 bridge.pulsar.encode_payload_type 指定 payload 数据格式。 启用 Pulsar 桥接插件 ./bin/emqx_ctl plugins load emqx_bridge_pulsar RocketMQ 桥接 EMQ X 桥接转发 MQTT 消息到 RocketMQ 集群: RocketMQ 桥接插件配置文件: etc/plugins/emqx_bridge_rocket.conf。 配置 RocketMQ 集群地址 ## RocketMQ 服务器集群配置 ## bridge.rocket.servers = 127.0.0.1:9876,127.0.0.2:9876,127.0.0.3:9876 bridge.rocket.servers = 127.0.0.1:9876 bridge.rocket.refresh_topic_route_interval = 5S ## 分区生产者是同步/异步模式选择 bridge.rocket.produce = sync ## 生产者同步模式下的超时时间 ## bridge.rocket.produce.sync_timeout = 3s ## 生产者 batch 的消息数量 ## bridge.rocket.producer.batch_size = 100 ## 采用 base64 编码或不编码 ## bridge.rocket.encode_payload_type = base64 ## bridge.rocket.sock.buffer = 32KB ## bridge.rocket.sock.recbuf = 32KB bridge.rocket.sock.sndbuf = 1MB ## bridge.rocket.sock.read_packets = 20 配置 RocketMQ 桥接规则 ## Bridge RocketMQ Hooks ## ${topic}: the RocketMQ topics to which the messages will be published. ## ${filter}: the mqtt topic (may contain wildcard) on which the action will be performed . ## Client Connected Record Hook bridge.rocket.hook.client.connected.1 = {\"topic\": \"ClientConnected\"} ## Client Disconnected Record Hook bridge.rocket.hook.client.disconnected.1 = {\"topic\": \"ClientDisconnected\"} ## Session Subscribed Record Hook bridge.rocket.hook.session.subscribed.1 = {\"filter\": \"#\", \"topic\": \"SessionSubscribed\"} ## Session Unsubscribed Record Hook bridge.rocket.hook.session.unsubscribed.1 = {\"filter\": \"#\", \"topic\": \"SessionUnsubscribed\"} ## Message Publish Record Hook bridge.rocket.hook.message.publish.1 = {\"filter\": \"#\", \"topic\": \"MessagePublish\"} ## Message Delivered Record Hook bridge.rocket.hook.message.delivered.1 = {\"filter\": \"#\", \"topic\": \"MessageDeliver\"} ## Message Acked Record Hook bridge.rocket.hook.message.acked.1 = {\"filter\": \"#\", \"topic\": \"MessageAcked\"} RocketMQ 桥接规则说明 事件 说明 bridge.rocket.hook.client.connected.1 客户端登录 bridge.rocket.hook.client.disconnected.1 客户端退出 bridge.rocket.hook.session.subscribed.1 订阅主题 bridge.rocket.hook.session.unsubscribed.1 取消订阅主题 bridge.rocket.hook.message.publish.1 发布消息 bridge.rocket.hook.message.delivered.1 delivered 消息 bridge.rocket.hook.message.acked.1 ACK 消息 客户端上下线事件转发 RocketMQ 设备上线 EMQ X 转发上线事件消息到 RocketMQ: topic = \"ClientConnected\", value = { \"client_id\": ${clientid}, \"username\": ${username}, \"node\": ${node}, \"ts\": ${ts} } 设备下线 EMQ X 转发下线事件消息到 RocketMQ: topic = \"ClientDisconnected\", value = { \"client_id\": ${clientid}, \"username\": ${username}, \"reason\": ${reason}, \"node\": ${node}, \"ts\": ${ts} } 客户端订阅主题事件转发 RocketMQ topic = \"SessionSubscribed\" value = { \"client_id\": ${clientid}, \"topic\": ${topic}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } 客户端取消订阅主题事件转发 RocketMQ topic = \"SessionUnsubscribed\" value = { \"client_id\": ${clientid}, \"topic\": ${topic}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息转发到 RocketMQ topic = \"MessagePublish\" value = { \"client_id\": ${clientid}, \"username\": ${username}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息派发 (Deliver) 事件转发 RocketMQ topic = \"MessageDeliver\" value = { \"client_id\": ${clientid}, \"username\": ${username}, \"from\": ${fromClientId}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } MQTT 消息确认 (Ack) 事件转发 RocketMQ topic = \"MessageAcked\" value = { \"client_id\": ${clientid}, \"username\": ${username}, \"from\": ${fromClientId}, \"topic\": ${topic}, \"payload\": ${payload}, \"qos\": ${qos}, \"node\": ${node}, \"ts\": ${timestamp} } RocketMQ 消费示例 RocketMQ 读取 MQTT 客户端上下线事件消息: bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer ClientConnected bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer ClientDisconnected RocketMQ 读取 MQTT 主题订阅事件消息: bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer SessionSubscribed bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer SessionUnsubscribed RocketMQ 读取 MQTT 发布消息: bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer MessagePublish RocketMQ 读取 MQTT 消息发布 (Deliver)、确认 (Ack) 事件: bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer MessageDeliver bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer MessageAcked 默认 payload 被 base64 编码，可通过修改配置 bridge.rocket.encode_payload_type 指定 payload 数据格式。 启用 RocketMQ 桥接插件 ./bin/emqx_ctl plugins load emqx_bridge_rocket .emqxee { display: none; }"},"tutorial/device-management.html":{"url":"tutorial/device-management.html","title":"设备管理","summary":null,"keywords":"","body":"设备管理设备认证在线状态与连接历史管理发布订阅/ACL代理订阅HTTP 消息发布设备管理 借助 EMQ X 管理监控 API 提供的客户端管理及主题订阅、消息发布管理接口以及认证、ACL、WebHook 等插件，能够快速搭建设备与消息的管理系统，构建联网接入平台。 设备认证 使用 认证 功能，实现设备连接认证。 管理系统可以直接读写外部认证数据库或通过 API 更改 EMQ X 内置认证数据，实现设备连接认证动态管理。 在线状态与连接历史管理 设备连接、断开时 EMQ X 可以通过 Webhook 插件、规则引擎 向管理系统 HTTP API 发送上下线信息，实现设备在线状态改写、设备连接 / 断开历史记录等功能。 使用断开设备 API 可以实现在线设备踢出，会话清除操作。 发布订阅/ACL 使用 发布订阅 ACL 功能，实现设备发布订阅权限管理。 管理系统可以直接读写外部认证数据库，实现设备发布订阅权限动态管理。 代理订阅 管理系统可通过代理订阅功能为在线设备订阅/取消订阅指定主题，在业务 Topic 更改后无需重新重新设定设备程序，有较高的灵活性。 HTTP 消息发布 消息发布 API 管理系统可以向任意 Topic 发布消息而无需使用额外的客户端，实现了 HTTP-MQTT 的消息转换。 HTTP 消息发布解耦了用户与设备、管理系统与设备之间的通信，通过间接通信能够降低系统复杂度并进一步提升安全性。 .emqxee { display: none; }"},"tutorial/tune.html":{"url":"tutorial/tune.html","title":"系统调优","summary":null,"keywords":"","body":"系统调优Linux 操作系统参数/etc/sysctl.conf/etc/security/limits.confTCP 协议栈网络参数Erlang 虚拟机参数EMQ X 消息服务器参数测试客户端设置emqtt_bench系统调优 EMQ X 消息服务器 4.x 版本 MQTT 连接压力测试到 130 万，在一台 8 核心、32G 内存的 CentOS 服务器上。 100 万连接测试所需的 Linux 内核参数，网络协议栈参数，Erlang 虚拟机参数， EMQ X 消息服务器参数设置如下: Linux 操作系统参数 系统全局允许分配的最大文件句柄数: # 2 millions system-wide sysctl -w fs.file-max=2097152 sysctl -w fs.nr_open=2097152 echo 2097152 > /proc/sys/fs/nr_open 允许当前会话 / 进程打开文件句柄数: ulimit -n 1048576 /etc/sysctl.conf 持久化 'fs.file-max' 设置到 /etc/sysctl.conf 文件: fs.file-max = 1048576 /etc/systemd/system.conf 设置服务最大文件句柄数: DefaultLimitNOFILE=1048576 /etc/security/limits.conf /etc/security/limits.conf 持久化设置允许用户 / 进程打开文件句柄数: * soft nofile 1048576 * hard nofile 1048576 TCP 协议栈网络参数 并发连接 backlog 设置: sysctl -w net.core.somaxconn=32768 sysctl -w net.ipv4.tcp_max_syn_backlog=16384 sysctl -w net.core.netdev_max_backlog=16384 可用知名端口范围: sysctl -w net.ipv4.ip_local_port_range='1000 65535' TCP Socket 读写 Buffer 设置: sysctl -w net.core.rmem_default=262144 sysctl -w net.core.wmem_default=262144 sysctl -w net.core.rmem_max=16777216 sysctl -w net.core.wmem_max=16777216 sysctl -w net.core.optmem_max=16777216 #sysctl -w net.ipv4.tcp_mem='16777216 16777216 16777216' sysctl -w net.ipv4.tcp_rmem='1024 4096 16777216' sysctl -w net.ipv4.tcp_wmem='1024 4096 16777216' TCP 连接追踪设置: sysctl -w net.nf_conntrack_max=1000000 sysctl -w net.netfilter.nf_conntrack_max=1000000 sysctl -w net.netfilter.nf_conntrack_tcp_timeout_time_wait=30 TIME-WAIT Socket 最大数量、回收与重用设置: sysctl -w net.ipv4.tcp_max_tw_buckets=1048576 # 注意：不建议开启該设置，NAT 模式下可能引起连接 RST # sysctl -w net.ipv4.tcp_tw_recycle=1 # sysctl -w net.ipv4.tcp_tw_reuse=1 FIN-WAIT-2 Socket 超时设置: sysctl -w net.ipv4.tcp_fin_timeout=15 Erlang 虚拟机参数 优化设置 Erlang 虚拟机启动参数，配置文件 emqx/etc/emqx.conf: ## Erlang Process Limit node.process_limit = 2097152 ## Sets the maximum number of simultaneously existing ports for this system node.max_ports = 1048576 EMQ X 消息服务器参数 设置 TCP 监听器的 Acceptor 池大小，最大允许连接数。配置文件 emqx/etc/emqx.conf: ## TCP Listener listener.tcp.external = 0.0.0.0:1883 listener.tcp.external.acceptors = 64 listener.tcp.external.max_connections = 1024000 测试客户端设置 测试客户端服务器在一个接口上，最多只能创建 65000 连接: sysctl -w net.ipv4.ip_local_port_range=\"500 65535\" echo 1000000 > /proc/sys/fs/nr_open ulimit -n 100000 emqtt_bench 并发连接测试工具: http://github.com/emqx/emqtt_bench .emqxee { display: none; }"},"tutorial/deploy.html":{"url":"tutorial/deploy.html","title":"生产部署","summary":null,"keywords":"","body":"生产部署部署架构LB (负载均衡)EMQ X 集群青云 (QingCloud) 部署亚马逊 (AWS) 部署私有网络部署EMQ X 集群直连HAProxy 负载均衡Nginx 负载均衡生产部署 在开发时我们通常使用压缩包方式以单节点的形式启动服务，生产运行需要一个更加简单稳定的方式。本页主要从部署架构最佳实践讲解如何部署你的 EMQ X 服务。 部署架构 EMQ X 集群可作为物联网接入服务（IoT Hub）部署，目前 EMQ 在青云、阿里云、AWS 等云服务提供商上均提供开箱即用的免费软件镜像，对于特殊硬件平台和系统版本如树莓派、Linux ARM，可使用源码编译安装。 典型部署架构： LB (负载均衡) LB (负载均衡器) 负责分发设备的 MQTT 连接与消息到 EMQ X 集群，LB 提高 EMQ X 集群可用性、实现负载平衡以及动态扩容。 部署架构推荐在 LB 终结 SSL 连接。设备与 LB 之间 TLS 安全连接，LB 与 EMQ X 之间普通 TCP 连接。这种部署模式下 EMQ X 单集群可轻松支持 100 万设备。 公有云厂商 LB 产品: 云计算厂商 是否支持 TLS 终结 LB 产品介绍 青云 是 https://docs.qingcloud.com/guide/loadbalancer.html AWS 是 https://aws.amazon.com/cn/elasticloadbalancing/ 阿里云 否 https://www.aliyun.com/product/slb UCloud 未知 https://ucloud.cn/site/product/ulb.html QCloud 未知 https://www.qcloud.com/product/clb 私有部署 LB 服务器: 开源 LB 是否支持 TLS 终结 方案介绍 HAProxy 是 https://www.haproxy.com/solutions/load-balancing.html NGINX 是 https://www.nginx.com/solutions/load-balancing/ 国内公有云部署推荐青云 (EMQ X 合作伙伴)，国外部署推荐 AWS ，私有部署推荐使用 HAProxy 作为 LB。 EMQ X 集群 EMQ X 节点集群部署在 LB 之后，建议部署在 VPC 或私有网络内。公有云厂商青云、AWS、UCloud、QCloud 均支持 VPC 网络。 EMQ X 默认开启的 MQTT 服务 TCP 端口: 端口 说明 1883 MQTT 协议端口 8883 MQTT/SSL 端口 8083 MQTT/WebSocket 端口 8084 MQTT/WebSocket/SSL 端口 8081 管理 API 端口 18083 Dashboard 端口 防火墙根据使用的 MQTT 接入方式，开启上述端口的访问权限。 EMQ X 节点集群使用的 TCP 端口: 端口 说明 4369 集群节点发现端口 (EPMD) 4370 集群节点发现端口 5369 集群节点 PRC 通道 6369 集群节点控制通道 集群节点间如有防护墙，需开启上述 TCP 端口互访权限。 青云 (QingCloud) 部署 创建 VPC 网络。 VPC 网络内创建 EMQ X 集群 ' 私有网络 '，例如: 192.168.0.0/24 私有网络内创建两台 EMQ X 主机，例如: 节点 IP 地址 emqx1 192.168.0.2 emqx2 192.168.0.3 安装并集群 EMQ X 主机，具体配置请参考安装集群章节。 创建 LB (负载均衡器) 并指定公网 IP 地址。 在 LB 上创建 MQTT TCP 监听器: 或创建 SSL 监听器，并终结 SSL 在 LB : MQTT 客户端连接 LB 公网地址测试。 亚马逊 (AWS) 部署 创建 VPC 网络。 VPC 网络内创建 EMQ X 集群 ' 私有网络 '，例如: 192.168.0.0/24 私有网络内创建两台 EMQ X 主机，指定上面创建的 VPC 网络，例如: 节点 IP 地址 emqx1 192.168.0.2 emqx2 192.168.0.3 在安全组中，开放 MQTT 服务的 TCP 端口，比如 1883, 8883。 安装并集群 EMQ X 主机，具体配置请参考安装集群章节。 创建 ELB (Classic 负载均衡器)，指定 VPC 网络，并指定公网 IP 地址。 在 ELB 上创建 MQTT TCP 监听器: 或创建 SSL 监听器，并终结 SSL 在 LB : MQTT 客户端连接 LB 公网地址测试。 私有网络部署 EMQ X 集群直连 EMQ X 集群直接挂 DNS 轮询，设备通过域名或者 IP 地址列表访问: 部署 EMQ X 集群 EMQ X 节点防火墙开启外部 MQTT 访问端口，例如 1883, 8883 设备通过 IP 地址列表或域名访问 EMQ X 集群 产品部署不推荐这种部署方式。 HAProxy 负载均衡 HAProxy 作为 LB 部署 EMQ X 集群，并终结 SSL 连接: 创建 EMQ X 集群节点，例如: 节点 IP 地址 emqx1 192.168.0.2 emqx2 192.168.0.3 配置 /etc/haproxy/haproxy.cfg，示例： listen mqtt-ssl bind *:8883 ssl crt /etc/ssl/emqx/emq.pem no-sslv3 mode tcp maxconn 50000 timeout client 600s default_backend emqx_cluster backend emqx_cluster mode tcp balance source timeout server 50s timeout check 5000 server emqx1 192.168.0.2:1883 check inter 10000 fall 2 rise 5 weight 1 server emqx2 192.168.0.3:1883 check inter 10000 fall 2 rise 5 weight 1 Nginx 负载均衡 Nginx 产品作为 EMQ X 集群 LB，并终结 SSL 连接: 创建 EMQ X 节点集群，例如: 节点 IP 地址 emqx1 192.168.0.2 emqx2 192.168.0.3 配置 /etc/nginx/nginx.conf，示例: stream { upstream stream_backend { zone tcp_servers 64k; hash $remote_addr; server 192.168.0.2:1883 max_fails=2 fail_timeout=30s; server 192.168.0.3:1883 max_fails=2 fail_timeout=30s; } server { listen 8883 ssl; status_zone tcp_server; proxy_pass stream_backend; proxy_buffer_size 4k; ssl_handshake_timeout 15s; ssl_certificate /etc/emqx/certs/cert.pem; ssl_certificate_key /etc/emqx/certs/key.pem; } } .emqxee { display: none; }"},"tutorial/prometheus.html":{"url":"tutorial/prometheus.html","title":"Prometheus 监控告警","summary":null,"keywords":"","body":"Prometheus 监控告警配置Grafana 数据模板Prometheus 监控告警 EMQ X 提供 emqx_statsd 插件，用于将系统的监控数据输出到第三方的监控系统中。以 Prometheus 为例：emqx_statsd 支持将数据推送至 Pushgateway 中，然后再由 Promethues Server 拉取进行存储。注意：emqx_statsd 不支持 Prometheus 的 Pull 操作。配置emqx_statsd 插件内部会启动一个定时器，使其每间隔一段时间便采集 EMQ X 中的监控数据。emqx_statsd 推送的监控数据包含的具体字段和含义，参见：Metrics & Stats配置文件位于 etc/plugins/emqx_statsd.conf，其中： 配置项 类型 可取值 默认值 说明 push.gateway.server string - http://127.0.0.1:9091 Prometheus 的 PushGateway 地址 interval integer > 0 5000 推送间隔，单位：毫秒 Grafana 数据模板emqx_statsd 插件提供了 Grafana 的 Dashboard 的模板文件。这些模板包含了所有 EMQ X 监控数据的展示。用户可直接导入到 Grafana 中，进行显示 EMQ X 的监控状态的图标。模板文件位于：emqx_statsd/grafana_template。 .emqxee { display: none; }"},"tutorial/benchmark.html":{"url":"tutorial/benchmark.html","title":"性能测试","summary":null,"keywords":"","body":"性能测试编译安装使用发布订阅连接SSL 连接典型压测场景场景说明机器及部署拓扑图调优连接量测试吞吐测试性能测试 emqtt_bench 是基于 Erlang 编写的，一个简洁强大的 MQTT 协议性能测试工具，如需大规模场景、深度定制化的测试服务推荐使用 EMQ 合作伙伴 XMeter 测试服务。 编译安装 emqtt_bench 的运行依赖于 Erlang/OTP 21.2 以上版本运行环境，安装过程略过，详情请参考网上各个安装教程。 Erlang 环境安装完成后，下载 emqtt-bench 最新代码，并编译： git clone https://github.com/emqx/emqtt-bench cd emqtt-bench make 编译完成后，当前目录下会生成 一个名为emqtt_bench 的可执行脚本。执行以下命令，确认其能正常使用： ./emqtt_bench Usage: emqtt_bench pub | sub | conn [--help] 输出以上内容，则证明 emqtt_bench 已正确安装到主机。 使用 emqtt_bench 共三个子命令： pub：用于创建大量客户端执行发布消息的操作。 sub：用于创建大量客户端执行订阅主题，并接受消息的操作。 conn：用于创建大量的连接。 发布 执行 ./emqtt_bench pub --help 会得到可用的参数输出，此处整理： 参数 简写 可选值 默认值 说明 --host -h - localhost 要连接的 MQTT 服务器地址 --port -p - 1883 MQTT 服务端口 --version -V 345 5 使用的 MQTT 协议版本 --count -c - 200 客户端总数 --startnumber -n - 0 客户端数量起始值 --interval -i - 10 每间隔多少时间创建一个客户端；单位：毫秒 --interval_of_msg -I - 1000 每间隔多少时间发送一个消息 --username -u - 无；非必选 客户端用户名 --password -P - 无；非必选 客户端密码 --topic -t - 无；必选 发布的主题；支持站位符：%c：表示 ClientId%u：表示 Username%i：表示客户端的序列数 --szie -s - 256 消息 Payload 的大小；单位：字节 --qos -q - 0 Qos 等级 --retain -r truefalse false 消息是否设置 Retain 标志 --keepalive -k - 300 客户端心跳时间 --clean -C truefalse true 是否以清除会话的方式建立连接 --ssl -S truefalse false 是否启用 SSL --certfile - - 无 客户端 SSL 证书 --keyfile - - 无 客户端 SSL 秘钥文件 --ws - truefalse false 是否以 Websocket 的方式建立连接 --ifaddr - - 无 指定客户端连接使用的本地网卡 例如，我们启动 10 个连接，分别每秒向主题 t 发送 100 条 Qos0 消息，其中每个消息体的大小为 16 字节大小： ./emqtt_bench pub -t t -h emqx-server -s 16 -q 0 -c 10 -I 10 订阅 执行 ./emqtt_bench sub --help可得到该子命令的所有的可用参数。它们的解释已包含在上表中，此处略过。 例如，我们启动 500 个连接，每个都以 Qos0 订阅 t 主题： ./emqtt_bench sub -t t -h emqx-server -c 500 连接 执行 ./emqtt_bench conn --help 可得到该子命令所有可用的参数。它们的解释已包含在上表中，此处略过。 例如，我们启动 1000 个连接： ./emqtt_bench conn -h emqx-server -c 1000 SSL 连接 emqtt_bench 支持建立 SSL 的安全连接，并执行测试。 单向证书，例如： ./emqtt_bench sub -c 100 -i 10 -t bench/%i -p 8883 -S ./emqtt_bench pub -c 100 -I 10 -t bench/%i -p 8883 -s 256 -S 双向证书，例如： ./emqtt_bench sub -c 100 -i 10 -t bench/%i -p 8883 --certfile path/to/client-cert.pem --keyfile path/to/client-key.pem ./emqtt_bench pub -c 100 -i 10 -t bench/%i -s 256 -p 8883 --certfile path/to/client-cert.pem --keyfile path/to/client-key.pem 典型压测场景 场景说明 此处我们以 2 类最典型的场景来验证工具的使用： 连接量：使用 emqtt_bench 创建百万连接到 EMQ X Broker。 吞吐量：使用 emqtt_bench 在 EMQ X 中创建出 10W/s 的 Qos0 消息吞吐量。 机器及部署拓扑图 共需准备三台 8C16G 服务器，一台为 EMQX Broker，两台为 客户端压力机。其中： 系统: CentOS Linux release 7.7.1908 (Core) CPU: Intel Xeon Processor (Skylake) 主频: 2693.670 MHZ 服务端： emqx-centos7-v4.0.2.zip 压力机：emqtt-bench v0.3.1 每台压力机分别配置 10 张网卡，用于连接测试中建立大量的 MQTT 客户端连接 拓扑结构如下： +-----------------------+ | bench1: 192.168.0.100 | ------- +--------------------------+ +-----------------------+ \\-----> | EMQ X Broker | +-----------------------+ /-----> | 192.168.0.99 | | bench2: 192.168.0.200 | ------- +--------------------------+ +-----------------------+ 调优 客户端的压力机和服务端的机器都需要执行系统参数的调优，参见：系统调优 连接量测试 在执行完系统调优后，首先启动服务端： ./bin/emqx start 然后在 bench1 上的每张网卡上启动 5w 的连接数，共计 50w 的连接： ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.100 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.101 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.102 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.103 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.104 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.105 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.106 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.107 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.108 ./emqtt_bench -h 192.168.0.99 -c 50000 --ifaddr 192.168.0.109 在 bench2上也执行同样的操作。 在所有连接建立完成后，执行 ./bin/emqx_ctl listeners，并找到以下的内容， 查看 EMQ X 中连接数的信息： listener on mqtt:tcp:0.0.0.0:1883 acceptors : 8 max_conns : 1024000 current_conn : 1000000 shutdown_count : [] 吞吐测试 同样的，首先启动服务端： ./bin/emqx start 在 bench1 启动 500 个订阅客户端： ./emqtt_bench sub -t t -h 192.168.0.99 -c 500 然后再 bench2 上启动 20 个发布端，并且每秒发布 10 条消息： ./emqtt_bench pub -t t -h 192.168.0.99 -c 20 -I 100 然后，回到 bench1上的订阅客户端，可看到当前接收消息的速率，类似于： recv(28006): total=2102563, rate=99725(msg/sec) .emqxee { display: none; }"},"configuration/configuration.html":{"url":"configuration/configuration.html","title":"配置项","summary":null,"keywords":"","body":"配置项clustercluster.namecluster.proto_distcluster.discoverycluster.autohealcluster.autocleancluster.static.seedscluster.mcast.addrcluster.mcast.portscluster.mcast.ifacecluster.mcast.ttlcluster.mcast.loopcluster.dns.namecluster.dns.appcluster.etcd.servercluster.etcd.prefixcluster.etcd.node_ttlcluster.etcd.ssl.keyfilecluster.etcd.ssl.certfilecluster.etcd.ssl.cacertfilecluster.k8s.apiservercluster.k8s.service_namecluster.k8s.address_typecluster.k8s.app_namecluster.k8s.suffixcluster.k8s.namespacenodenode.namenode.cookienode.data_dirnode.heartbeatnode.async_threadsnode.process_limitnode.max_portsnode.dist_buffer_sizenode.max_ets_tablesnode.global_gc_intervalnode.fullsweep_afternode.crash_dumpnode.ssl_dist_optfilenode.dist_net_ticktimenode.dist_listen_minnode.dist_listen_maxrpcrpc.moderpc.async_batch_sizenode.tcp_server_portnode.tcp_client_portnode.tcp_client_numrpc.connect_timeoutrpc.send_timeoutrpc.authentication_timeoutrpc.call_receive_timeoutrpc.socket_keepalive_idlerpc.socket_keepalive_intervalrpc.socket_keepalive_countrpc.socket_sndbufrpc.socket_recbufrpc.socket_bufferloglog.tolog.levellog.dirlog.filelog.chars_limitlog.rotation.sizelog.rotation.countlog..fileauthaclallow_anonymousacl_nomatchacl_fileenable_acl_cacheacl_cache_max_sizeacl_cache_ttlacl_deny_actionmqttflapping_detect_policymqtt.max_packet_sizemqtt.max_clientid_lenmqtt.max_topic_levelsmqtt.max_qos_allowedmqtt.max_topic_aliasmqtt.retain_availablemqtt.wildcard_subscriptionmqtt.shared_subscriptionmqtt.ignore_loop_delivermqtt.strict_modezoneexternalzone.external.idle_timeoutzone.external.enable_aclzone.external.enable_banzone.external.enable_statszone.external.acl_deny_actionzone.external.force_gc_policyzone.external.force_shutdown_policyzone.external.max_packet_sizezone.external.max_clientid_lenzone.external.max_topic_levelszone.external.max_qos_allowedzone.external.max_topic_aliaszone.external.retain_availablezone.external.wildcard_subscriptionzone.external.shared_subscriptionzone.external.server_keepalivezone.external.keepalive_backoffzone.external.max_subscriptionszone.external.upgrade_qoszone.external.max_inflightzone.external.retry_intervalzone.external.max_awaiting_relzone.external.await_rel_timeoutzone.external.session_expiry_intervalzone.external.max_mqueue_lenzone.external.mqueue_prioritieszone.external.mqueue_default_priorityzone.external.mqueue_store_qos0zone.external.enable_flapping_detectzone.external.mountpointzone.external.use_username_as_clientidzone.external.ignore_loop_deliverzone.external.strict_modezoneinternalzone.internal.allow_anonymouszone.internal.enable_statszone.internal.enable_aclzone.internal.acl_deny_actionzone.internal.force_gc_policyzone.internal.wildcard_subscriptionzone.internal.shared_subscriptionzone.internal.max_subscriptionszone.internal.max_inflightzone.internal.max_awaiting_relzone.internal.max_mqueue_lenzone.internal.enable_flapping_detectzone.internal.force_shutdown_policyzone.internal.mountpointzone.internal.ignore_loop_deliverzone.internal.strict_modezone.internal.bypass_auth_pluginstcpexternallistener.tcp.externallistener.tcp.external.acceptorslistener.tcp.external.max_connectionslistener.tcp.external.max_conn_ratelistener.tcp.external.active_nlistener.tcp.external.zonelistener.tcp.external.rate_limitlistener.tcp.external.access.1listener.tcp.external.proxy_protocollistener.tcp.external.proxy_protocol_timeoutlistener.tcp.external.backloglistener.tcp.external.send_timeoutlistener.tcp.external.send_timeout_closelistener.tcp.external.recbuflistener.tcp.external.sndbuflistener.tcp.external.bufferlistener.tcp.external.tune_bufferlistener.tcp.external.nodelaylistener.tcp.external.reuseaddrtcpinternallistener.tcp.internallistener.tcp.internal.acceptorslistener.tcp.internal.max_connectionslistener.tcp.internal.max_conn_ratelistener.tcp.internal.active_nlistener.tcp.internal.zonelistener.tcp.internal.rate_limitlistener.tcp.internal.backloglistener.tcp.internal.send_timeoutlistener.tcp.internal.send_timeout_closelistener.tcp.internal.recbuflistener.tcp.internal.sndbuflistener.tcp.internal.bufferlistener.tcp.internal.tune_bufferlistener.tcp.internal.nodelaylistener.tcp.internal.reuseaddrtlsexternallistener.ssl.externallistener.ssl.external.acceptorslistener.ssl.external.max_connectionslistener.ssl.external.max_conn_ratelistener.ssl.external.active_nlistener.ssl.external.zonelistener.ssl.external.access.1listener.ssl.external.rate_limitlistener.ssl.external.proxy_protocollistener.ssl.external.proxy_protocol_timeoutlistener.ssl.external.tls_versionslistener.ssl.external.handshake_timeoutlistener.ssl.external.keyfilelistener.ssl.external.certfilelistener.ssl.external.cacertfilelistener.ssl.external.dhfilelistener.ssl.external.verifylistener.ssl.external.fail_if_no_peer_certlistener.ssl.external.cipherslistener.ssl.external.psk_cipherslistener.ssl.external.secure_renegotiatelistener.ssl.external.reuse_sessionslistener.ssl.external.honor_cipher_orderlistener.ssl.external.peer_cert_as_usernamelistener.ssl.external.backloglistener.ssl.external.send_timeoutlistener.ssl.external.recbuflistener.ssl.external.sndbuflistener.ssl.external.bufferlistener.ssl.external.tune_bufferlistener.ssl.external.nodelaylistener.ssl.external.reuseaddrwsexternallistener.ws.externallistener.ws.external.mqtt_pathlistener.ws.external.acceptorslistener.ws.external.max_connectionslistener.ws.external.max_conn_ratelistener.ws.external.active_nlistener.ws.external.rate_limitlistener.ws.external.zonelistener.ws.external.access.1listener.ws.external.verify_protocol_headerlistener.ws.external.proxy_address_headerlistener.ws.external.proxy_port_headerlistener.ws.external.proxy_protocollistener.ws.external.proxy_protocol_timeoutlistener.ws.external.backloglistener.ws.external.send_timeoutlistener.ws.external.send_timeout_closelistener.ws.external.recbuflistener.ws.external.sndbuflistener.ws.external.bufferlistener.ws.external.tune_bufferlistener.ws.external.nodelaylistener.ws.external.compresslistener.ws.external.deflate_opts.levellistener.ws.external.deflate_opts.mem_levellistener.ws.external.deflate_opts.strategylistener.ws.external.deflate_opts.server_context_takeoverlistener.ws.external.deflate_opts.client_context_takeoverlistener.ws.external.deflate_opts.server_max_window_bitslistener.ws.external.deflate_opts.client_max_window_bitslistener.ws.external.idle_timeoutlistener.ws.external.max_frame_sizewssexternallistener.wss.externallistener.wss.external.mqtt_pathlistener.wss.external.acceptorslistener.wss.external.max_connectionslistener.wss.external.max_conn_ratelistener.wss.external.active_nlistener.wss.external.rate_limitlistener.wss.external.zonelistener.wss.external.access.1listener.wss.external.verify_protocol_headerlistener.wss.external.proxy_address_headerlistener.wss.external.proxy_protocollistener.wss.external.proxy_protocol_timeoutlistener.wss.external.tls_versionslistener.wss.external.keyfilelistener.wss.external.certfilelistener.wss.external.cacertfilelistener.wss.external.dhfilelistener.wss.external.verifylistener.wss.external.fail_if_no_peer_certlistener.wss.external.cipherslistener.wss.external.psk_cipherslistener.wss.external.secure_renegotiatelistener.wss.external.reuse_sessionslistener.wss.external.honor_cipher_orderlistener.wss.external.peer_cert_as_usernamelistener.wss.external.backloglistener.wss.external.send_timeoutlistener.wss.external.recbuflistener.wss.external.sndbuflistener.wss.external.bufferlistener.wss.external.tune_bufferlistener.wss.external.nodelaylistener.wss.external.compresslistener.wss.external.deflate_opts.levellistener.wss.external.deflate_opts.mem_levellistener.wss.external.deflate_opts.strategylistener.wss.external.deflate_opts.server_context_takeoverlistener.wss.external.deflate_opts.client_context_takeoverlistener.wss.external.deflate_opts.server_max_window_bitslistener.wss.external.deflate_opts.client_max_window_bitslistener.wss.external.idle_timeoutlistener.wss.external.max_frame_sizepluginsplugins.etc_dirplugins.loaded_fileplugins.expand_plugins_dirbrokerbroker.sys_intervalbroker.sys_heartbeatbroker.enable_session_registrybroker.session_locking_strategybroker.shared_subscription_strategybroker.shared_dispatch_ack_enabledbroker.route_batch_cleanmonitorsysmon.long_gcsysmon.long_schedulesysmon.large_heapsysmon.busy_portsysmon.busy_dist_portos_mon.cpu_check_intervalos_mon.cpu_high_watermarkos_mon.cpu_low_watermarkos_mon.mem_check_intervalos_mon.sysmem_high_watermarkos_mon.procmem_high_watermarkvm_mon.check_intervalvm_mon.process_high_watermarkvm_mon.process_low_watermarkemqx-auth-clientidauth.client..clientid&auth.client..passwordauth.client.password_hashemqx-auth-httpauth.http.auth_reqauth.http.auth_req.methodauth.http.auth_req.paramsauth.http.super_reqauth.http.super_req.methodauth.http.super_req.paramsauth.http.acl_reqauth.http.acl_req.methodauth.http.acl_req.paramsauth.http.request.timeoutauth.http.request.connect_timeoutauth.http.request.retry_timesauth.http.request.retry_intervalauth.http.request.retry_backoffauth.http.header.auth.http.ssl.cacertfileauth.http.ssl.certfileauth.http.ssl.keyfileemqx-auth-jwtauth.jwt.secretauth.jwt.fromauth.jwt.pubkeyauth.jwt.verify_claimsauth.jwt.verify_claims.emqx-auth-ldapauth.ldap.serversauth.ldap.portauth.ldap.poolauth.ldap.bind_dnauth.ldap.bind_passwordauth.ldap.timeoutauth.ldap.device_dnauth.ldap.match_objectclassauth.ldap.username.attributetypeauth.ldap.password.attributetypeauth.ldap.sslauth.ldap.ssl.certfileauth.ldap.ssl.keyfileauth.ldap.ssl.cacertfileauth.ldap.ssl.verifyauth.ldap.ssl.fail_if_no_peer_certemqx-auth-mongoauth.mongo.typeauth.mongo.rs_set_nameauth.mongo.rs_set_nameauth.mongo.poolauth.mongo.loginauth.mongo.passwordauth.mongo.auth_sourceauth.mongo.databaseauth.mongo.query_timeoutauth.mongo.sslauth.mongo.ssl_opts.keyfileauth.mongo.ssl_opts.certfileauth.mongo.ssl_opts.cacertfileauth.mongo.w_modeauth.mongo.r_modeauth.mongo.auth_query.collectionauth.mongo.auth_query.password_fieldauth.mongo.auth_query.password_hashauth.mongo.auth_query.selectorauth.mongo.auth_query.super_queryauth.mongo.super_query.collectionauth.mongo.super_query.selectorauth.mongo.acl_queryauth.mongo.acl_query.collectionauth.mongo.acl_query.selectorauth.mongo.topology.pool_sizeauth.mongo.topology.max_overflowauth.mongo.topology.overflow_ttlauth.mongo.topology.overflow_check_periodauth.mongo.topology.local_threshold_msauth.mongo.topology.connect_timeout_msauth.mongo.topology.socket_timeout_msauth.mongo.topology.server_selection_timeout_msauth.mongo.topology.wait_queue_timeout_msauth.mongo.topology.heartbeat_frequency_msauth.mongo.topology.min_heartbeat_frequency_msemqx-auth-mysqlauth.mysql.serverauth.mysql.poolauth.mysql.usernameauth.mysql.passwordauth.mysql.databaseauth.mysql.query_timeoutauth.mysql.auth_queryauth.mysql.password_hashauth.mysql.super_queryauth.mysql.acl_queryemqx-auth-pgsqlauth.pgsql.serverauth.pgsql.poolauth.pgsql.usernameauth.pgsql.passwordauth.pgsql.databaseauth.pgsql.encodingauth.pgsql.sslauth.pgsql.ssl_opts.keyfileauth.pgsql.ssl_opts.certfileauth.pgsql.ssl_opts.cacertfileauth.pgsql.auth_queryauth.pgsql.password_hashauth.pgsql.super_queryauth.pgsql.acl_queryemqx-auth-redisauth.redis.typeauth.redis.serverauth.redis.sentinelauth.redis.poolauth.redis.databaseauth.redis.passwordauth.redis.query_timeoutauth.redis.auth_cmdauth.redis.password_hashauth.redis.super_cmdauth.redis.acl_cmdemqx-auth-usernameauth.user..username&auth.user..passwordauth.user.password_hashemqx-bridge-mqttbridge.mqtt.aws.addressbridge.mqtt.aws.proto_verbridge.mqtt.aws.start_typebridge.mqtt.aws.bridge_modebridge.mqtt.aws.clientidbridge.mqtt.aws.clean_startbridge.mqtt.aws.usernamebridge.mqtt.aws.passwordbridge.mqtt.aws.forwardsbridge.mqtt.aws.forward_mountpointbridge.mqtt.aws.subscription.1.topicbridge.mqtt.aws.subscription.1.qosbridge.mqtt.aws.receive_mountpointbridge.mqtt.aws.sslbridge.mqtt.aws.cacertfilebridge.mqtt.aws.certfilebridge.mqtt.aws.keyfilebridge.mqtt.aws.ciphersbridge.mqtt.aws.psk_ciphersbridge.mqtt.aws.keepalivebridge.mqtt.aws.tls_versionsbridge.mqtt.aws.reconnect_intervalbridge.mqtt.aws.retry_intervalbridge.mqtt.aws.batch_sizebridge.mqtt.aws.max_inflight_sizebridge.mqtt.aws.queue.replayq_dirbridge.mqtt.aws.queue.replayq_seg_bytesbridge.mqtt.aws.queue.max_total_sizeemqx-coapcoap.portcoap.enable_statscoap.dtls.portcoap.dtls.verifycoap.dtls.keyfilecoap.dtls.certfilecoap.dtls.cacertfilecoap.dtls.fail_if_no_peer_certcoap.dtls.ciphersemqx-dashboarddashboard.default_user.login&dashboard.default_user.passworddashboard.listener.httpdashboard.listener.http.acceptorsdashboard.listener.http.max_clientsdashboard.listener.http.inet6dashboard.listener.http.ipv6_v6onlydashboard.listener.httpsdashboard.listener.https.acceptorsdashboard.listener.https.max_clientsdashboard.listener.https.inet6dashboard.listener.https.ipv6_v6onlydashboard.listener.https.keyfiledashboard.listener.https.certfiledashboard.listener.https.cacertfiledashboard.listener.https.dhfiledashboard.listener.https.verifydashboard.listener.https.fail_if_no_peer_certdashboard.listener.https.tls_versionsdashboard.listener.https.ciphersdashboard.listener.https.secure_renegotiatedashboard.listener.https.reuse_sessionsdashboard.listener.https.honor_cipher_orderemqx-lwm2mlwm2m.portlwm2m.lifetime_minlwm2m.lifetime_maxlwm2m.qmode_time_windowlwm2m.lblwm2m.auto_observelwm2m.mountpointlwm2m.topics.commandlwm2m.topics.responselwm2m.topics.notifylwm2m.topics.registerlwm2m.topics.updatelwm2m.opts.bufferlwm2m.opts.recbuflwm2m.opts.sndbuflwm2m.opts.read_packetslwm2m.certfilelwm2m.keyfilelwm2m.xml_diremqx-managementmanagement.max_row_limitmanagement.default_application.idmanagement.default_application.secretmanagement.listener.httpmanagement.listener.http.acceptorsmanagement.listener.http.max_clientsmanagement.listener.http.backlogmanagement.listener.http.send_timeoutmanagement.listener.http.send_timeout_closemanagement.listener.http.inet6management.listener.http.ipv6_v6onlymanagement.listener.httpsmanagement.listener.https.acceptorsmanagement.listener.https.max_clientsmanagement.listener.https.backlogmanagement.listener.https.send_timeoutmanagement.listener.https.send_timeout_closemanagement.listener.https.keyfilemanagement.listener.https.certfilemanagement.listener.https.cacertfilemanagement.listener.https.verifymanagement.listener.https.fail_if_no_peer_certmanagement.listener.https.inet6management.listener.https.ipv6_v6onlyemqx-reloaderreloader.intervalreloader.logfileemqx-retainerretainer.storage_typeretainer.max_retained_messagesretainer.max_payload_sizeretainer.expiry_intervalemqx-rule-enginerule-engine.ignore_sys_messagerule-engine.events.emqx-snmqtt.sn.portmqtt.sn.advertise_durationmqtt.sn.gateway_idmqtt.sn.enable_statsmqtt.sn.enable_qos3mqtt.sn.idle_timeoutmqtt.sn.predefined.topic.0mqtt.sn.usernamemqtt.sn.passwordemqx-prometheusprometheus.push.gateway.serverprometheus.intervalprometheus.collector.emqx-stompstomp.listenerstomp.listener.acceptorsstomp.listener.max_connectionsstomp.listener.sslstomp.listener.keyfilestomp.listener.certfilestomp.listener.cacertfilestomp.listener.dhfilestomp.listener.verifystomp.listener.fail_if_no_peer_certstomp.listener.tls_versionsstomp.listener.handshake_timeoutstomp.listener.ciphersstomp.listener.secure_renegotiatestomp.listener.reuse_sessionsstomp.listener.honor_cipher_orderstomp.default_user.loginstomp.default_user.passcodestomp.allow_anonymousstomp.frame.max_headersstomp.frame.max_header_lengthstomp.frame.max_body_lengthemqx-web-hookweb.hook.api.urlweb.hook.encode_payloadweb.hook.rule.client.connect.1web.hook.rule.client.connack.1web.hook.rule.client.connected.1web.hook.rule.client.disconnected.1web.hook.rule.client.subscribe.1web.hook.rule.client.unsubscribe.1web.hook.rule.session.subscribed.1web.hook.rule.session.unsubscribed.1web.hook.rule.session.terminated.1web.hook.rule.message.publish.1web.hook.rule.message.delivered.1web.hook.rule.message.acked.1配置项 cluster cluster.name Type Default string emqxcl 说明 集群名称。 cluster.proto_dist Type Optional Value Default enum inet_tcp, inet6_tcp, inet_tls inet_tcp 说明 分布式 Erlang 集群协议类型。可选值为: inet_tcp: 使用 IPv4 inet6_tcp 使用 IPv6 inet_tls: 使用 TLS，需要与 node.ssl_dist_optfile 配置一起使用。 cluster.discovery Type Optional Value Default enum manual, static, mcast, dns, etcd, k8s manual 说明 集群节点发现方式。可选值为: manual: 手动加入集群 static: 配置静态节点。配置几个固定的节点，新节点通过连接固定节点中的某一个来加入集群。 mcast: 使用 UDP 多播的方式发现节点。 dns: 使用 DNS A 记录的方式发现节点。 etcd: 使用 etcd 发现节点。 k8s: 使用 Kubernetes 发现节点。 cluster.autoheal Type Optional Value Default enum on, off on 说明 启用或关闭集群脑裂自动恢复机制。 cluster.autoclean Type Default duration 5m 说明 指定多久之后从集群中删除短线节点。 cluster.static.seeds Type Default Example string - emqx1@192.168.0.100,emqx2@192.168.0.101 说明 当使用 static 方式集群时，指定固定的节点列表，多个节点间使用逗号 , 分隔。 cluster.mcast.addr Type Default ipaddr 239.192.0.1 说明 当使用 mcast 方式集群时，指定多播地址。 cluster.mcast.ports Type Default string 4369 说明 当使用 mcast 方式集群时，指定多播端口。如有多个端口使用逗号 , 分隔。 cluster.mcast.iface Type Default ipaddr 0.0.0.0 说明 当使用 mcast 方式集群时，指定节点发现服务需要绑定到本地哪个 IP 地址。 cluster.mcast.ttl Type Default integer 255 说明 当使用 mcast 方式集群时，指定多播的 Time-To-Live 值。 cluster.mcast.loop Type Optional Value Default enum on, off on 说明 当使用 mcast 方式集群时，设置多播的报文是否投递到本地回环地址。 cluster.dns.name Type Default Example string - mycluster.com 说明 当使用 dns 方式集群时，指定 DNS A 记录的名字。emqx 会通过访问这个 DNS A 记录来获取 IP 地址列表，然后拼接 cluster.dns.app 里指定的 APP 名得到集群中所有节点的列表。 示例 设置 cluster.dns.app = emqx，并且配置了一个 DNS: mycluster.com，其指向 3 个 IP 地址: 192.168.0.100 192.168.0.101 192.168.0.102 则得到集群节点列表如下： emqx@192.168.0.100 emqx@192.168.0.101 emqx@192.168.0.102 cluster.dns.app Type Default Example string - emqx 说明 当使用 dns 方式集群时，用来与从 cluster.dns.name 获取的 IP 列表拼接得到节点名列表。 cluster.etcd.server Type Default Example string - http://127.0.0.1:2379 说明 当使用 etcd 方式集群时，指定 etcd 服务的地址。如有多个服务使用逗号 , 分隔。 cluster.etcd.prefix Type Default Example string - emqxcl 说明 当使用 etcd 方式集群时，指定 etcd 路径的前缀。每个节点在 etcd 中都会创建一个路径: v2/keys/// cluster.etcd.node_ttl Type Default Example duration - 1m 说明 当使用 etcd 方式集群时，指定 etcd 中节点路径的过期时间。 cluster.etcd.ssl.keyfile Type Default Example string - etc/certs/client-key.pem 说明 当使用 SSL 连接 etcd 时，指定客户端的私有 Key 文件。 cluster.etcd.ssl.certfile Type Default Example string - etc/certs/client.pem 说明 当使用 SSL 连接 etcd 时，指定 SSL 客户端的证书文件。 cluster.etcd.ssl.cacertfile Type Default Example string - etc/certs/ca.pem 说明 当使用 SSL 连接 etcd 时，指定 SSL 的 CA 证书文件。 cluster.k8s.apiserver Type Default Example string - http://10.110.111.204:8080 说明 当使用 k8s 方式集群时，指定 Kubernetes API Server。如有多个 Server 使用逗号 , 分隔。 cluster.k8s.service_name Type Default Example string - emqx 说明 当使用 k8s 方式集群时，指定 Kubernetes 中 EMQ X 的服务名。 cluster.k8s.address_type Type Optional Value Default enum ip, dns, hostname ip 说明 当使用 k8s 方式集群时，address_type 用来从 Kubernetes 接口的应答里获取什么形式的 Host 列表。 示例 指定 cluster.k8s.address_type 为 ip，则将从 Kubernetes 接口中获取 emqx 服务的 IP 地址列表: 172.16.122.31 172.16.122.32 172.16.122.33 然后与 cluster.k8s.app_name 配置指定的 app name 拼接，得到 emqx 节点列表: emqx@172.16.122.31 emqx@172.16.122.32 emqx@172.16.122.33 cluster.k8s.app_name Type Default Example string - emqx 说明 当使用 k8s 方式集群时，app_name 用来跟获取的 Host 列表拼接，得到节点列表。 cluster.k8s.suffix Type Default Example string - pod.cluster.local 说明 当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，可设置 emqx 节点名的后缀。与 cluster.k8s.namespace 一起使用用以拼接得到节点名列表。 cluster.k8s.namespace Type Default Example string - default 说明 当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，可设置 emqx 节点名的命名空间。与 cluster.k8s.suffix 一起使用用以拼接得到节点名列表。 示例 设置 cluster.k8s.address_type 为 dns，则将从 Kubernetes 接口中获取 emqx 服务的 dns 列表: 172-16-122-31 172-16-122-32 172-16-122-33 然后拼接上 cluster.k8s.app_name = emqx，cluster.k8s.suffix = pod.cluster.local，cluster.k8s.namespace = default 得到 dns 形式的 emqx 节点名列表: emqx@172-16-122-31.default.pod.cluster.local emqx@172-16-122-32.default.pod.cluster.local emqx@172-16-122-33.default.pod.cluster.local node node.name Type Default string emqx@127.0.0.1 说明 节点名。格式为 @。其中 可以是 IP 地址，也可以是 FQDN。详见 http://erlang.org/doc/reference_manual/distributed.html。 node.cookie Type Default string emqxsecretcookie 说明 分布式 Erlang 集群使用的 cookie 值。 node.data_dir Type Default folder ./data 说明 节点的 data 目录，用于存放 Mnesia 数据文件等。 node.heartbeat Type Optional Value Default enum on, off off 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 -heart 参数。 启用或关闭 Erlang 运行时检测机制，并在运行时终止时自动重启。需小心使用，以免手动关闭 emqx 时被监控进程重新启动。 node.async_threads Type Optional Value Default integer 0 - 1024 4 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 +A 参数。 设置 Erlang 运行时异步线程池中的线程数量。详情请参见 http://erlang.org/doc/man/erl.html。 node.process_limit Type Optional Value Default integer 1024 - 134217727 2097152 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 +P 参数。 设置 Erlang 允许的最大进程数，这将影响 emqx 节点能处理的连接数。详情请参见 http://erlang.org/doc/man/erl.html。 node.max_ports Type Optional Value Default integer 1024 - 134217727 1048576 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 +Q 参数。 设置 Erlang 允许的最大 Ports 数量。详情请参见 http://erlang.org/doc/man/erl.html。 node.dist_buffer_size Type Optional Value Default bytesize 1KB - 2GB 8MB 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 +zdbbl 参数。 设置 Erlang 分布式通信使用的最大缓存大小。详情请参见 http://erlang.org/doc/man/erl.html。 node.max_ets_tables Type Default integer 262144 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 +e 参数。 设置 Erlang 运行时允许的最大 ETS 表数量。详情请参见 http://erlang.org/doc/man/erl.html。 node.global_gc_interval Type Default duration 15m 说明 系统调优参数，设置 Erlang 运行多久强制进行一次全局垃圾回收。 node.fullsweep_after Type Optional Value Default integer 0 - 65535 1000 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 -env ERL_FULLSWEEP_AFTER 参数。 设置 Erlang 运行时多少次 generational GC 之后才进行一次 fullsweep GC。详情请参见 http://erlang.org/doc/man/erlang.html#spawn_opt-4。 node.crash_dump Type Default string log/crash.dump 说明 设置 Erlang crash_dump 文件的存储路径和文件名。 node.ssl_dist_optfile Type Default string etc/ssl_dist.conf 说明 此配置将覆盖 vm.args 文件里的 -ssl_dist_optfile 参数。 如使用 SSL 方式建立 emqx 集群，需指定 SSL 分布式协议的配置文件。需要与 cluster.proto_dist = inet_tls 一起使用。 node.dist_net_ticktime Type Default integer 120 说明 系统调优参数，此配置将覆盖 vm.args 文件里的 -kernel net_ticktime 参数。 当一个节点持续无响应多久之后，认为其已经宕机并断开连接。详情请参见 http://www.erlang.org/doc/man/kernel_app.html#net_ticktime。 node.dist_listen_min Type Optional Value Default integer 1024 - 65535 6369 说明 与 node.dist_listen_max 一起设定一个 TCP 端口段，此端口段用于分配给分布式 Erlang，作为分布式通道的监听端口。注意如果在节点之间设置了防火墙，需要将此端口段放进防火墙的端口白名单里。 node.dist_listen_max Type Optional Value Default integer 1024 - 65535 6369 说明 与 node.dist_listen_min 一起设定一个 TCP 端口段，此端口段用于分配给分布式 Erlang，作为分布式通道的监听端口。注意如果在节点之间设置了防火墙，需要将此端口段放进防火墙的端口白名单里。 rpc rpc.mode Type Optional Value Default enum sync, async async 说明 RPC 模式。可选同步或异步模式。 rpc.async_batch_size Type Default integer 256 说明 异步模式下最大的批量发送消息数。注意此配置在同步模式下不起作用。 node.tcp_server_port Type Optional Value Default integer 1024 - 65535 5369 说明 设置 RPC 本地服务使用的监听 port。 node.tcp_client_port Type Optional Value Default integer 1024-65535 5369 说明 设置远程 RPC 服务的端口。 node.tcp_client_num Type Optional Value Default integer 1 - 256 CPU 核心数 / 2 说明 设置由本节点发起，通往每个远程节点的 RPC 通信通道数量。设置为 1 可保证消息顺序。保持默认值（CPU 核心数的一半）可提高 RPC 的吞吐能力。 rpc.connect_timeout Type Default duration 5s 说明 建立 RPC 连接超时时间。建立连接时若远程节点无响应，多久之后放弃尝试。 rpc.send_timeout Type Default duration 5s 说明 发送超时时间。发送消息多久之后放弃。 rpc.authentication_timeout Type Default duration 5s 说明 RPC 认证超时时间。尝试认证若远程节点无响应，多久之后放弃。 rpc.call_receive_timeout Type Default duration 15s 说明 RPC 同步模式的超时时间。RPC 同步调用若收不到回复，用多久之后放弃。 rpc.socket_keepalive_idle Type Default duration 900s 说明 在最近一次数据包发送多久之后，发送 keepalive 探测报文。 rpc.socket_keepalive_interval Type Default duration 75s 说明 发送 keepalive 探测报文的间隔。 rpc.socket_keepalive_count Type Default integer 9 说明 连续多少次 keepalive 探测报文都收不到回复的情况下，认为 RPC 连接已丢失。 rpc.socket_sndbuf Type Default bytesize 1MB 说明 TCP 调优参数。TCP 发送缓冲区大小。 rpc.socket_recbuf Type Default bytesize 1MB 说明 TCP 调优参数。TCP 接收缓冲区大小。 rpc.socket_buffer Type Default bytesize 1MB 说明 TCP 调优参数。用户态的 Socket 缓冲区大小。 log log.to Type Optional Value Default enum off, file, console, both both 说明 将日志输出到什么地方。可选值为: off: 完全关闭日志功能 file: 仅将日志输出到文件 console: 仅将日志输出到标准输出(emqx 控制台) both: 同时将日志输出到文件和标准输出(emqx 控制台) log.level Type Optional Value Default enum debug, info, notice, warningerror, critical, alert, emergency warning 说明 全局的日志级别。这包括 primary log level 以及所有的 log handlers。详情请参见 日志级别和 log handlers。 log.dir Type Default dir ./log 说明 日志文件目录。 log.file Type Default string emqx.log 说明 日志文件的前缀。例如，若使用默认值 (log.file = emqx.log)，日志文件名将为 emqx.log.1，emqx.log.2，...。 log.chars_limit Type Default integer -1 说明 设置单个日志消息的最大长度。如超过此长度，日志消息将被截断。-1 表示无限制。 log.rotation.size Type Default bytesize 10MB 说明 设置单个日志文件大小。如超过此大小，则进行日志文件滚动，创建新的日志文件。 log.rotation.count Type Default integer 5 说明 设置日志文件总个数。如超过此文件个数，则下一次日志文件滚动将会覆盖第一个文件。 log..file Type Default string - 说明 针对某日志级别设置单独的日志文件。 示例 将 info 及 info 以上的日志单独输出到 info.log.N 文件中： log.info.file = info.log 将 error 及 error 以上的日志单独输出到 error.log.N 文件中 log.error.file = error.log authacl allow_anonymous Type Optional Value Default enum true, false true 说明 是否允许匿名用户登录系统。 注：生产环境建议关闭此选项。 acl_nomatch Type Optional Value Default enum allow, deny allow 说明 ACL 未命中时，允许或者拒绝 发布/订阅 操作。 acl_file Type Default string etc/acl.conf 说明 默认 ACL 文件的路径。 enable_acl_cache Type Optional Value Default enum on, off on 说明 是否启用 ACL 缓存。 acl_cache_max_size Type Default integer 32 说明 ACL 规则最大缓存条数。 acl_cache_ttl Type Default duration 1m 说明 ACL 规则最大缓存时间。 acl_deny_action Type Optional Value Default enum ignore, disconnect ignore 说明 ACL 检查失败后，执行的操作。 ignore：不做任何操作。 disconnect：断开连接。 mqtt flapping_detect_policy Type Default string 30, 1m, 5m 说明 指定 Flapping 检查策略。 格式：,,。 例如，30, 1m, 5m，它表示如果客户端在 1 分钟内断开连接 30 次，那么在后续 5 分钟内禁止登录。 mqtt.max_packet_size Type Default bytesize 1MB 说明 允许的 MQTT 报文最大长度。 mqtt.max_clientid_len Type Default integer 65535 说明 允许的 Client ID 串的最大长度。 mqtt.max_topic_levels Type Default integer 0 说明 允许客户端订阅主题的最大层级。0 表示不限制。 mqtt.max_qos_allowed Type Optional Value Default enum 0, 1, 2 2 说明 允许客户端发布的最大 QoS 等级。 mqtt.max_topic_alias Type Default integer 65535 说明 允许最大的主题别名数。0 表示不支持主题别名。 mqtt.retain_available Type Optional Value Default enum true, false true 说明 是否支持 Retain 消息。 mqtt.wildcard_subscription Type Optional Value Default enum true, false true 说明 是否支持订阅通配主题。 mqtt.shared_subscription Type Optional Value Default enum true, false true 说明 是否支持共享订阅。 mqtt.ignore_loop_deliver Type Optional Value Default enum true, false false 说明 是否忽略自己发送的消息。如果忽略，则表明 EMQ X 不会向消息的发送端投递此消息。 mqtt.strict_mode Type Optional Value Default enum true, false false 说明 是否开启严格检查模式。严格检查模式会更细致的检查 MQTT 报文的正确性。 zoneexternal zone.external.idle_timeout Type Default duration 15s 说明 TCP 连接建立后的发呆时间，如果这段时间内未收到任何报文，则会关闭该连接。 zone.external.enable_acl Type Optional Value Default enum on, off on 说明 是否开启 ACL 检查。 zone.external.enable_ban Type Optional Value Default enum on, off on 说明 是否开启黑名单。 zone.external.enable_stats Type Optional Value Default enum on, off on 说明 是否开启客户端状态统计。 zone.external.acl_deny_action Type Optional Value Default enum ignore, disconnect ignore 说明 ACL 检查失败后，执行的操作。 ignore：不做任何操作。 disconnect：断开连接。 zone.external.force_gc_policy Type Default string `16000 16MB` 说明 当收到一定数量的消息，或字节，就强制执行一次垃圾回收。 格式：|。 例如，16000|16MB 表示当收到 16000 条消息，或 16MB 的字节流入就强制执行一次垃圾回收。 zone.external.force_shutdown_policy Type Default string - 说明 当进程消息队列长度，或占用的内存字节到达某值，就强制关闭该进程。 这里的 消息队列 指的是 Erlang 进程的 消息邮箱，并非 QoS 1 和 QoS 2 的 mqueue。 格式：|。 例如，32000|32MB 表示当进程堆积了 32000 条消息，或进程占用内存达到 32MB 则关闭该进程。 zone.external.max_packet_size Type Default bytesize - 说明 允许的 MQTT 报文最大长度。 zone.external.max_clientid_len Type Default integer - 说明 允许的 Client ID 串的最大长度。 zone.external.max_topic_levels Type Default integer - 说明 允许客户端订阅主题的最大层级。0 表示不限制。 zone.external.max_qos_allowed Type Optional Value Default enum 0, 1, 2 - 说明 允许客户端发布的最大 QoS 等级。 zone.external.max_topic_alias Type Default integer - 说明 允许最大的主题别名数。0 表示不支持主题别名。 zone.external.retain_available Type Optional Value Default enum true, false - 说明 是否支持 Retain 消息。 zone.external.wildcard_subscription Type Optional Value Default enum true, false - 说明 是否支持订阅通配主题。 zone.external.shared_subscription Type Optional Value Default enum true, false - 说明 是否支持共享订阅。 zone.external.server_keepalive Type Default integer - 说明 服务端指定的 Keepalive 时间。用于 MQTT v5.0 协议的 CONNACK 报文。 zone.external.keepalive_backoff Type Optional Value Default float > 0.5 0.75 说明 Keepalive 退避指数。EMQ X 如果在 Keepalive * backoff * 2 的时间内未收到客户端的任何数据报文，则认为客户端已心跳超时。 zone.external.max_subscriptions Type Default integer 0 说明 单个客户端允许订阅的最大主题数。0 表示不限制。 zone.external.upgrade_qos Type Optional Value Default enum on, off off 说明 允许 EMQ X 在投递消息时，强制升级消息的 QoS 等级为订阅的 QoS 等级。 zone.external.max_inflight Type Default integer 32 说明 飞行窗口大小。飞行窗口用于存储未被应答的 QoS 1 和 QoS 2 消息。 zone.external.retry_interval Type Default duration 30s 说明 消息重发间隔。EMQ X 在每个间隔检查是否需要进行消息重发。 zone.external.max_awaiting_rel Type Default integer 100 说明 QoS 2 消息的最大接收窗口，配置 EMQ X 能够同时处理多少从客户端发来的 QoS 2 消息。0 表示不限制。 zone.external.await_rel_timeout Type Default duration 300s 说明 QoS 2 消息处理超时时间，在超时后若还未收到 QoS 的 PUBREL 报文，则将消息从接收窗口中丢弃。 zone.external.session_expiry_interval Type Default duration 2h 说明 会话默认超时时间，主要用于 MQTT v3.1 和 v3.1.1 协议。在 MQTT v5.0 中，该值通常会携带在客户端的连接报文中。 zone.external.max_mqueue_len Type Default integer 1000 说明 消息队列最大长度。当飞行窗口满，或客户端离线后，消息会被存储至该队列中。0 表示不限制。 zone.external.mqueue_priorities Type Optional Value Default string none, none 说明 队列消息优先级配置： none：表示无优先级区分。 ：表示为一个消息优先表，它配置了某主题下消息的优先级。例如： topic/1=10：表示主题 topic/1 的消息优先级为 10。 topic/1=10,topic/2=8：表示配置了两个主题的优先级，其分别为 10 和 8。 其中，优先级数值越高，优先等级越高。 当消息队列长度有限时，会优先丢弃低优先级的消息。 zone.external.mqueue_default_priority Type Optional Value Default enum highest, lowest highest 说明 消息默认的优先等级。 zone.external.mqueue_store_qos0 Type Optional Value Default enum true, false true 说明 消息队列是否存储 QoS 0 消息。 zone.external.enable_flapping_detect Type Optional Value Default enum on, off off 说明 是否开启 Flapping 检查。 zone.external.mountpoint Type Default string - 说明 主题挂载点。配置后，所有订阅和发布的主题在 EMQ X 都会为其增加一个前缀。 其中可用的占位符有： %c：表示客户端的 Client ID。 %u：表示客户端的 Username。 例如，配置挂载点为 user/%c/。那么 Client ID 为 tom 的客户端在发布主题 open 消息时，实际在 EMQ X 中路由的主题是 user/tom/open。 zone.external.use_username_as_clientid Type Optional Value Default enum true, false false 说明 是否用客户端的 Username 作为其 Client ID。 zone.external.ignore_loop_deliver Type Optional Value Default enum true, false false 说明 是否忽略自己发送的消息。如果忽略，则表明 EMQ X 不会向消息的发送端投递此消息。 zone.external.strict_mode Type Optional Value Default enum true, false false 说明 是否开启严格检查模式。严格检查模式会更细致的检查 MQTT 报文的正确性。 zoneinternal zone.internal.allow_anonymous Type Optional Value Default enum true, false true 说明 是否允许匿名用户登录系统。 zone.internal.enable_stats Type Optional Value Default enum on, off on 说明 是否开启客户端状态统计。 zone.internal.enable_acl Type Optional Value Default enum on, off off 说明 是否开启 ACL 检查。 zone.internal.acl_deny_action Type Optional Value Default enum ignore, disconnect ignore 说明 ACL 检查失败后，执行的操作。 ignore：不做任何操作。 disconnect：断开连接。 zone.internal.force_gc_policy Type Default string - 说明 当收到一定数量的消息，或字节，就强制执行一次垃圾回收。 格式：|。 例如，16000|16MB 表示当收到 16000 条消息，或 16MB 的字节流入就强制执行一次垃圾回收。 zone.internal.wildcard_subscription Type Optional Value Default enum true, false - 说明 是否支持订阅通配主题。 zone.internal.shared_subscription Type Optional Value Default enum true, false - 说明 是否支持共享订阅。 zone.internal.max_subscriptions Type Default integer 0 说明 单个客户端允许订阅的最大主题数。0 表示不限制。 zone.internal.max_inflight Type Default integer 128 说明 飞行窗口大小。飞行窗口用于存储未被应答的 QoS 1 和 QoS 2 消息。 zone.internal.max_awaiting_rel Type Default integer 1000 说明 QoS 2 消息的最大接收窗口，配置 EMQ X 能够同时处理多少从客户端发来的 QoS 2 消息。0 表示不限制。 zone.internal.max_mqueue_len Type Default integer 10000 说明 消息队列最大长度。当飞行窗口满，或客户端离线后，消息会被存储至该队列中。0 表示不限制。 ``zone.internal.mqueue_store_qos0 Type Optional Value Default enum true, false true 说明 消息队列是否存储 QoS 0 消息。 zone.internal.enable_flapping_detect Type Optional Value Default enum on, off off 说明 是否开启 Flapping 检查。 zone.internal.force_shutdown_policy Type Default string - 说明 当进程消息队列长度，或占用的内存字节到达某值，就强制关闭该进程。 这里的 消息队列 指的是 Erlang 进程的 消息邮箱，并非 QoS 1 和 QoS 2 的 mqueue。 格式：|。 例如，32000|32MB 表示当进程堆积了 32000 条消息，或进程占用内存达到 32MB 则关闭该进程。 zone.internal.mountpoint Type Default string - 说明 主题挂载点。配置后，所有订阅和发布的主题在 EMQ X 都会为其增加一个前缀。 其中可用的占位符有： %c：表示客户端的 Client ID。 %u：表示客户端的 Username。 例如，配置挂载点为 user/%c/。那么 Client ID 为 tom 的客户端在发布主题 open 消息时，实际在 EMQ X 中路由的主题是 user/tom/open。 zone.internal.ignore_loop_deliver Type Optional Value Default enum true, false false 说明 是否忽略自己发送的消息。如果忽略，则表明 EMQ X 不会向消息的发送端投递此消息。 zone.internal.strict_mode Type Optional Value Default enum true, false false 说明 是否开启严格检查模式。严格检查模式会更细致的检查 MQTT 报文的正确性。 zone.internal.bypass_auth_plugins Type Optional Value Default enum true, false true 说明 是否允许该 Zone 下的客户端绕过认证插件的认证步骤。 tcpexternal listener.tcp.external Type Default string 0.0.0.0:1883 说明 配置名称为 external 的 MQTT/TCP 监听器的监听地址。 示例 1883：表监听 IPv4 的 0.0.0.0:1883。 127.0.0.1:1883：表监听地址为 127.0.0.1 网卡上的 1883 端口。 ::1:1883：表监听 IPv6 地址为 ::1 网卡上的 1883 端口。 listener.tcp.external.acceptors Type Default integer 8 说明 监听器的接收池大小。 listener.tcp.external.max_connections Type Default integer 1024000 说明 监听器允许的最大并发连接数量。 listener.tcp.external.max_conn_rate Type Default integer 1000 说明 监听器允许的最大接入速率。单位：个/秒 listener.tcp.external.active_n Type Default integer 100 说明 监听器持续接收 TCP 报文的次数。 listener.tcp.external.zone Type Default string external 说明 监听器所属的配置域 (Zone)。 listener.tcp.external.rate_limit Type Default string - 说明 监听器的速率限制。格式为 ,。 示例 100KB,10s：表 限制 10 秒内的流入字节数不超过 100 KB。 listener.tcp.external.access.1 Type Default string allow all 说明 监听器的 ACL 规则列表。它用于设置连接层的白/黑名单。 示例 allow all：表允许所有的 TCP 连接接入。 allow 192.168.0.0/24：表允许网络地址为 192.168.0.0/24 的 TCP 连接接入。 同时，该配置可配置多条规则： listener.tcp.external.access.1 = deny 192.168.0.1 listener.tcp.external.access.2 = allow all 它表示，除 192.168.0.1 外的 TCP 连接都允许接入。 listener.tcp.external.proxy_protocol Type Optional Value Default enum on, off - 说明 监听器是否开启 Proxy Protocol 的支持。 如果 EMQ X 集群部署在 HAProxy 或 Nginx 后，且需要拿到客户端真实的源 IP 地址与端口，则需打开此配置。 Proxy Protcol 参考: https://www.haproxy.com/blog/haproxy/proxy-protocol。 listener.tcp.external.proxy_protocol_timeout Type Default duration - 说明 设置 Proxy Protocol 解析的超时时间。如果该时间内没收到 Proxy Protocol 的报文，EMQ X 会关闭其连接。 listener.tcp.external.backlog Type Default integer 1024 说明 TCP 连接队列的最大长度。它表明了系统中允许的正在三次握手的 TCP 连接队列最大个数。 listener.tcp.external.send_timeout Type Default duration 15s 说明 TCP 报文发送超时时间。 listener.tcp.external.send_timeout_close Type Optional Value Default enum on, off on 说明 TCP 报文发送超时后，是否关闭该连接。 listener.tcp.external.recbuf Type Default bytesize - 说明 TCP 接收缓存区大小（操作系统内核级参数） 参见：http://erlang.org/doc/man/inet.html listener.tcp.external.sndbuf Type Default bytesize - 说明 TCP 发送缓存区大小（操作系统内核级参数）。 参见：http://erlang.org/doc/man/inet.html。 listener.tcp.external.buffer Type Default bytesize - 说明 TCP 缓冲区大小 (用户级)。 该值建议大于等于 sndbuff 和 recbuff 的最大值，以避免一些性能问题。在不配置的情况下，它默认等于 sndbuff 和 recbuff 的最大值。 参见：http://erlang.org/doc/man/inet.html。 listener.tcp.external.tune_buffer Type Optional Value Default enum on, off - 说明 如果打开此配置，请设置该值等于 sndbuff 与 recbuff 的最大值。 listener.tcp.external.nodelay Type Optional Value Default enum true, false true 说明 即 TCP_NODELAY 参数。开启该选项即允许小的 TCP 数据报文将会立即发送。 listener.tcp.external.reuseaddr Type Optional Value Default enum true, false true 说明 即 SO_REUSEADDR 参数。开启该选项即允许本地重用端口，无需等待 TIME_WAIT 状态结束。 tcpinternal listener.tcp.internal Type Default string 127.0.0.1:11883 说明 配置名称为 internal 的 MQTT/TCP 监听器的监听地址。 示例 11883：表监听 IPv4 的 0.0.0.0:11883。 127.0.0.1:11883：表监听地址为 127.0.0.1 网卡上的 11883 端口。 ::1:11883：表监听 IPv6 地址为 ::1 网卡上的 11883 端口。 listener.tcp.internal.acceptors Type Default integer 4 说明 监听器的接收池大小。 listener.tcp.internal.max_connections Type Default integer 1024000 说明 监听器允许的最大并发连接数量。 listener.tcp.internal.max_conn_rate Type Default integer 1000 说明 监听器允许的最大接入速率。单位：个/秒 listener.tcp.internal.active_n Type Default integer 1000 说明 监听器持续接收 TCP 报文的次数。 listener.tcp.internal.zone Type Default string internal 说明 监听器所属的配置域 (Zone)。 listener.tcp.internal.rate_limit Type Default string - 说明 监听器的速率限制。格式为 ,。 示例 100KB,10s：表 限制 10 秒内的流入字节数不超过 100 KB。 listener.tcp.internal.backlog Type Default integer 512 说明 TCP 连接队列的最大长度。它表明了系统中允许的正在三次握手的 TCP 连接队列最大个数。 listener.tcp.internal.send_timeout Type Default duration 5s 说明 TCP 报文发送超时时间。 listener.tcp.internal.send_timeout_close Type Optional Value Default enum on, off on 说明 TCP 报文发送超时后，是否关闭该连接。 listener.tcp.internal.recbuf Type Default bytesize 64KB 说明 TCP 接收缓存区大小（操作系统内核级参数） listener.tcp.internal.sndbuf Type Default bytesize 64KB 说明 TCP 发送缓存区大小（操作系统内核级参数） listener.tcp.internal.buffer Type Default bytesize - 说明 TCP 缓冲区大小 (用户级)。 listener.tcp.internal.tune_buffer Type Optional Value Default enum on, off - 说明 如果打开此配置，请设置该值等于 sndbuff 与 recbuff 的最大值。 listener.tcp.internal.nodelay Type Optional Value Default enum true, false false 说明 即 TCP_NODELAY 参数。开启该选项即允许小的 TCP 数据报文将会立即发送。 listener.tcp.internal.reuseaddr Type Optional Value Default enum true, false true 说明 即 SO_REUSEADDR 参数。开启该选项即允许本地重用端口，无需等待 TIME_WAIT 状态结束。 tlsexternal listener.ssl.external Type Default string 0.0.0.0:8883 说明 配置名称为 external 的 SSL 监听器。 listener.ssl.external.acceptors Type Default integer 16 说明 监听器的接收池大小。 listener.ssl.external.max_connections Type Default integer 102400 说明 监听器允许的最大并发连接数量。 listener.ssl.external.max_conn_rate Type Default integer 500 说明 监听器允许的最大接入速率。单位：个/秒。 listener.ssl.external.active_n Type Default integer 100 说明 监听器持续接收 TCP 报文的次数。 listener.ssl.external.zone Type Default string external 说明 监听器所属的配置组 (Zone)。 listener.ssl.external.access.1 Type Default string allow all 说明 监听器的 ACL 规则列表。它用于设置连接层的白/黑名单。 例如: allow all：表允许所有的 TCP 连接接入。 allow 192.168.0.0/24：表允许网络地址为 192.168.0.0/24 的 TCP 连接接入。 同时，该配置可配置多条规则: listener.ssl.external.access.1 = deny 192.168.0.1 listener.ssl.external.access.2 = allow all listener.ssl.external.rate_limit Type Default string - 说明 监听器的速率限制。格式为 ,。 listener.ssl.external.proxy_protocol Type Optional Value Default enum on, off - 说明 监听器是否开启 Proxy Protocol 的支持。 如果 EMQ X 集群部署在 HAProxy 或 Nginx 后，且需要拿到客户端真实的源 IP 地址与端口，则需打开此配置。 Proxy Protcol 参考: https://www.haproxy.com/blog/haproxy/proxy-protocol。 listener.ssl.external.proxy_protocol_timeout Type Default duration - 说明 设置 Proxy Protocol 解析的超时时间。如果该时间内没收到 Proxy Protocol 的报文，EMQ X 会关闭其连接。 listener.ssl.external.tls_versions Type Default string tlsv1.2,tlsv1.1,tlsv1 说明 指定服务端支持的 SSL 的版本列表。详情请参见 http://erlang.org/doc/man/ssl.html。 listener.ssl.external.handshake_timeout Type Default duration 15s 说明 指定 SSL 握手过程的超时时间。 listener.ssl.external.keyfile Type Default string etc/certs/key.pem 说明 指定 SSL 的私钥文件 (PEM)。 listener.ssl.external.certfile Type Default string etc/certs/cert.pem 说明 指定 SSL 的证书文件 (PEM)。 listener.ssl.external.cacertfile Type Default string etc/certs/cacert.pem 说明 指定 SSL 的 CA 证书文件 (PEM)。 listener.ssl.external.dhfile Type Default string etc/certs/dh-params.pem 说明 若使用 Ephemeral Diffie-Helman 算法，指定算法使用的 key 文件。 listener.ssl.external.verify Type Optional Value Default enum verify_peer, verify_none verify_peer 说明 指定握手过程中是否校验客户端。 listener.ssl.external.fail_if_no_peer_cert Type Optional Value Default enum true, false false 说明 SSL 握手过程中若客户端没有证书，是否让握手失败。 listener.ssl.external.ciphers Type Default string ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA 说明 指定服务端支持的密码套件。 listener.ssl.external.psk_ciphers Type Default string PSK-AES128-CBC-SHA,PSK-AES256-CBC-SHA,PSK-3DES-EDE-CBC-SHA,PSK-RC4-SHA 说明 若使用 PSK 算法，指定服务端支持的 PSK Cipher 列表。注意 'listener.ssl.external.ciphers' 和 'listener.ssl.external.psk_ciphers' 只能配置一个。 listener.ssl.external.secure_renegotiate Type Optional Value Default enum on, off off 说明 指定在客户端不遵循 RFC 5746 的情况下，是否拒绝 renegotiation 请求。 listener.ssl.external.reuse_sessions Type Optional Value Default enum on, off on 说明 指定是否支持 SSL session 重用。详情见 http://erlang.org/doc/man/ssl.html。 listener.ssl.external.honor_cipher_order Type Optional Value Default enum on, off on 说明 指定是否使用服务端的偏好设置选择 Ciphers。 listener.ssl.external.peer_cert_as_username Type Optional Value Default enum cn, dn, crt cn 说明 使用客户端证书中的 CN、DN 或者 CRT 字段的值作为 MQTT CONNECT 报文中的 Username 字段的值。 注意 listener.ssl.external.verify 应当设置为 verify_peer。 listener.ssl.external.backlog Type Default integer 1024 说明 TCP 连接队列的最大长度。它表明了系统中允许的正在三次握手的 TCP 连接队列最大个数。 listener.ssl.external.send_timeout Type Default duration 15s 说明 TCP 报文发送超时时间。 listener.ssl.external.send_timeout_close* Type Optional Value Default enum on, off on 说明 TCP 报文发送超时后，是否关闭该连接。 listener.ssl.external.recbuf Type Default bytesize - 说明 TCP 接收缓存区大小（操作系统内核级参数）。 参见：http://erlang.org/doc/man/inet.html。 listener.ssl.external.sndbuf Type Default bytesize - 说明 TCP 发送缓存区大小（操作系统内核级参数）。 参见：http://erlang.org/doc/man/inet.html。 listener.ssl.external.buffer Type Default bytesize - 说明 TCP 缓冲区大小 (用户级)。 该值建议大于等于 sndbuff 和 recbuff 的最大值，以避免一些性能问题。在不配置的情况下，它默认等于 sndbuff 和 recbuff 的最大值。 参见：http://erlang.org/doc/man/inet.html。 listener.ssl.external.tune_buffer Type Optional Value Default enum on, off - 说明 如果打开此配置，请设置该值等于 sndbuff 与 recbuff 的最大值。 listener.ssl.external.nodelay Type Optional Value Default enum true, false true 说明 即 TCP_NODELAY 参数。开启该选项即表示禁用 Nagle 算法，小包将被立即发送。 listener.ssl.external.reuseaddr Type Optional Value Default enum true, false true 说明 即 SO_REUSEADDR 参数。开启该选项即允许本地重用端口，无需等待 TIME_WAIT 状态结束。 wsexternal listener.ws.external Type Default string 8083 说明 配置名称为 external 的 MQTT/WS 监听器的监听地址。 示例 8083：表监听 IPv4 的 0.0.0.0:8083。 127.0.0.1:8083：表监听地址为 127.0.0.1 网卡上的 8083 端口。 ::1:8083：表监听 IPv6 地址为 ::1 网卡上的 8083 端口。 listener.ws.external.mqtt_path Type Default string /mqtt 说明 WebSocket 的 MQTT 协议路径。因此 EMQ X 的 WebSocket 的地址是： ws://:/mqtt。 listener.ws.external.acceptors Type Default integer 4 说明 监听器的接收池大小。 listener.ws.external.max_connections Type Default integer 102400 说明 监听器允许的最大并发连接数量。 listener.ws.external.max_conn_rate Type Default integer 1000 说明 监听器允许的最大接入速率。单位：个/秒 listener.ws.external.active_n Type Default integer 100 说明 监听器持续接收 TCP 报文的次数。 listener.ws.external.rate_limit Type Default string 100KB,10s 说明 监听器的速率限制。格式为 ,。 示例 100KB,10s：表 限制 10 秒内的流入字节数不超过 100 KB。 listener.ws.external.zone Type Default string external 说明 监听器所属的配置域 (Zone)。 listener.ws.external.access.1 Type Default string allow all 说明 监听器的 ACL 规则列表。它用于设置连接层的白/黑名单。 listener.ws.external.verify_protocol_header Type Optional Value Default enum on, off on 说明 是否验证 WebSocket 携带的 HTTP 头部是否正确。微信小程序需关闭该验证。 listener.ws.external.proxy_address_header Type Optional Value Default string X-Forwarded-For - 说明 如果 EMQ X 集群部署在 HAProxy 或 Nginx 后，则可打开该配置获取客户端真实的 IP 地址。 listener.ws.external.proxy_port_header Type Optional Value Default string X-Forwarded-Port - 说明 如果 EMQ X 集群部署在 HAProxy 或 Nginx 后，则可打开该配置获取客户端真实的端口。 listener.ws.external.proxy_protocol Type Optional Value Default enum on, off - 说明 监听器是否开启 Proxy Protocol 的支持。 如果 EMQ X 集群部署在 HAProxy 或 Nginx 后，且需要拿到客户端真实的源 IP 地址与端口，则需打开此配置。 Proxy Protcol 参考: https://www.haproxy.com/blog/haproxy/proxy-protocol。 listener.ws.external.proxy_protocol_timeout Type Default duration - 说明 设置 Proxy Protocol 解析的超时时间。如果该时间内没收到 Proxy Protocol 的报文，EMQ X 会关闭其连接。 listener.ws.external.backlog Type Default integer 1024 说明 TCP 连接队列的最大长度。它表明了系统中允许的正在三次握手的 TCP 连接队列最大个数。 listener.ws.external.send_timeout Type Default duration 15s 说明 TCP 报文发送超时时间。 listener.ws.external.send_timeout_close Type Optional Value Default enum on, off on 说明 TCP 报文发送超时后，是否关闭该连接。 listener.ws.external.recbuf Type Default bytesize - 说明 TCP 接收缓存区大小（操作系统内核级参数） listener.ws.external.sndbuf Type Default bytesize - 说明 TCP 发送缓存区大小（操作系统内核级参数） listener.ws.external.buffer Type Default bytesize - 说明 TCP 缓冲区大小 (用户级)。 listener.ws.external.tune_buffer Type Optional Value Default enum on, off - 说明 如果打开此配置，请设置该值等于 sndbuff 与 recbuff 的最大值。 listener.ws.external.nodelay Type Optional Value Default enum true, false true 说明 即 TCP_NODELAY 参数。开启该选项即允许小的 TCP 数据报文将会立即发送。 listener.ws.external.compress Type Optional Value Default enum true, false - 说明 是否压缩 WebSocket 消息。压缩的实现依赖 zlib。 defalte_opts 下的配置项，都属于压缩相关的参数配置，如无必要请不需要修改它。 listener.ws.external.deflate_opts.level Type Optional Value Default enum none, default, best_compression, best_speed - 说明 压缩等级。 listener.ws.external.deflate_opts.mem_level Type Optional Value Default integer 1 - 9 - 说明 压缩参数。内存使用限制等级，配置可开辟多少内存来参与压缩过程。 1：最少的内存，但会降低压缩率。 9：最多的内存，会提高计算速度和压缩率。 不配置，则默认为 8。 listener.ws.external.deflate_opts.strategy Type Optional Value Default enum default, filtered, huffman_only, rle - 说明 压缩策略，用于调优压缩率： default：针对普通数据。 filtered：由过滤器或预测器产生的数据，适用于分布随机性强的内容。 huffman_only：强制使用 Huffman 算法。优于 filtered。 rle：将匹配距离限制为 1 (Run-Lenght Encoding)，比 huffman_only 要快，但主要用于 PNG 图片。 这些策略仅影响压缩率，不会对正确性带来任何影响。 listener.ws.external.deflate_opts.server_context_takeover Type Optional Value Default enum takeover, no_takeover - 说明 是否允许服务端的压缩上下文在帧之间传递。 listener.ws.external.deflate_opts.client_context_takeover Type Optional Value Default enum takeover, no_takeover - 说明 是否允许客户端的压缩上下文在帧之间传递。 listener.ws.external.deflate_opts.server_max_window_bits Type Optional Value Default integer 8 - 15 - 说明 服务端最大窗口值。设置一个较大的值会有更好的压缩率，但会额外的消耗内存。 listener.ws.external.deflate_opts.client_max_window_bits Type Optional Value Default integer 8 - 15 - 说明 客户端最大窗口值。设置一个较大的值会有更好的压缩率，但会额外的消耗内存。 listener.ws.external.idle_timeout Type Default duration - 说明 TCP 连接建立后的发呆时间，如果这段时间内未收到任何报文，则会关闭该连接。 listener.ws.external.max_frame_size Type Default integer - 说明 允许的单个 MQTT 报文长度的最大值。 wssexternal listener.wss.external Type Default string 0.0.0.0:8084 说明 配置名称为 external 的 WSS (MQTT/WebSocket/SSL) 监听器。 listener.wss.external.mqtt_path Type Default string /mqtt 说明 WebSocket 的 URL Path。 listener.wss.external.acceptors Type Default integer 4 说明 监听器的接收池大小。 listener.wss.external.max_connections Type Default integer 16 说明 监听器允许的最大并发连接数量。 listener.wss.external.max_conn_rate Type Default integer 1000 说明 监听器允许的最大接入速率。单位：个/秒。 listener.wss.external.active_n Type Default integer 100 说明 监听器持续接收 TCP 报文的次数。 listener.wss.external.rate_limit Type Default string - 说明 监听器的速率限制。格式为 ,。 listener.wss.external.zone Type Default string external 说明 监听器所属的配置组 (Zone)。 listener.wss.external.access.1 Type Default string allow all 说明 监听器的 ACL 规则列表。它用于设置连接层的白/黑名单。 例如: allow all：表允许所有的 TCP 连接接入。 allow 192.168.0.0/24：表允许网络地址为 192.168.0.0/24 的 TCP 连接接入。 同时，该配置可配置多条规则: listener.wss.external.access.1 = deny 192.168.0.1 listener.wss.external.access.2 = allow all listener.wss.external.verify_protocol_header Type Optional Value Default enum on, off on 说明 是否验证 WebSocket 携带的 HTTP 头部是否正确。微信小程序需关闭该验证。 listener.wss.external.proxy_address_header Type Default string X-Forwarded-For 说明 如果 EMQ X 集群部署在 HAProxy 或 Nginx，则可打开该配置获取客户端真实的 IP 地址。 listener.wss.external.proxy_protocol Type Optional Value Default enum on, off - 说明 监听器是否开启 Proxy Protocol 的支持。 如果 EMQ X 集群部署在 HAProxy 或 Nginx 后，且需要拿到客户端真实的源 IP 地址与端口，则需打开此配置。 Proxy Protcol 参考：https://www.haproxy.com/blog/haproxy/proxy-protocol。 listener.wss.external.proxy_protocol_timeout Type Default duration - 说明 设置 Proxy Protocol 解析的超时时间。如果该时间内没收到 Proxy Protocol 的报文，EMQ X 会关闭其连接。 listener.wss.external.tls_versions Type Default string tlsv1.2,tlsv1.1,tlsv1 说明 指定服务端支持的 SSL 的版本列表。详情请参见 http://erlang.org/doc/man/ssl.html。 listener.wss.external.keyfile Type Default string etc/certs/key.pem 说明 指定 SSL 的私钥文件 (PEM)。 listener.wss.external.certfile Type Default string etc/certs/cert.pem 说明 指定 SSL 的证书文件 (PEM)。 listener.wss.external.cacertfile Type Default string etc/certs/cacert.pem 说明 若使用 SSL，指定 SSL 的 CA 证书文件 (PEM)。 listener.wss.external.dhfile Type Default string etc/certs/dh-params.pem 说明 若使用 Ephemeral Diffie-Helman 算法，指定算法使用的 key 文件。 listener.wss.external.verify Type Optional Value Default enum verify_peer, verify_none verify_peer 说明 指定握手过程中是否校验客户端。 listener.wss.external.fail_if_no_peer_cert Type Optional Value Default enum true, false false 说明 SSL 握手过程中若客户端没有证书，是否让握手失败。 listener.wss.external.ciphers Type Default string ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA 说明 指定服务器支持的密码套件。 listener.wss.external.psk_ciphers Type Default string PSK-AES128-CBC-SHA,PSK-AES256-CBC-SHA,PSK-3DES-EDE-CBC-SHA,PSK-RC4-SHA 说明 若使用 PSK 算法，指定服务端支持的 PSK Cipher 列表。注意 'listener.wss.external.ciphers' 和 'listener.wss.external.psk_ciphers' 只能配置一个。 listener.wss.external.secure_renegotiate Type Optional Value Default enum on, off off 说明 指定在客户端不遵循 RFC 5746 的情况下，是否拒绝 renegotiation 请求。 listener.wss.external.reuse_sessions Type Optional Value Default enum on, off on 说明 指定是否支持 SSL session 重用。详情见 http://erlang.org/doc/man/ssl.html。 listener.wss.external.honor_cipher_order Type Optional Value Default enum on, off on 说明 指定是否使用服务端的偏好设置选择 Ciphers。 listener.wss.external.peer_cert_as_username Type Optional Value Default enum cn, dn, crt cn 说明 使用客户端证书中的 CN、DN 或者 CRT 字段的值作为 MQTT CONNECT 报文中的 Username 字段的值。 注意 listener.wss.external.verify 应当设置为 verify_peer。 listener.wss.external.backlog Type Default integer 1024 说明 TCP 连接队列的最大长度。它表明了系统中允许的正在三次握手的 TCP 连接队列最大个数。 listener.wss.external.send_timeout Type Default duration 15s 说明 TCP 报文发送超时时间。 listener.wss.external.send_timeout_close* Type Optional Value Default enum on, off on 说明 TCP 报文发送超时后，是否关闭该连接。 listener.wss.external.recbuf Type Default bytesize - 说明 TCP 接收缓存区大小（操作系统内核级参数） 参见：http://erlang.org/doc/man/inet.html listener.wss.external.sndbuf Type Default bytesize - 说明 TCP 发送缓存区大小（操作系统内核级参数） 参见：http://erlang.org/doc/man/inet.html listener.wss.external.buffer Type Default bytesize - 说明 TCP 缓冲区大小 (用户级)。 该值建议大于等于 sndbuff 和 recbuff 的最大值，以避免一些性能问题。在不配置的情况下，它默认等于 sndbuff 和 recbuff 的最大值 参见：http://erlang.org/doc/man/inet.html listener.wss.external.tune_buffer Type Optional Value Default enum on, off - 说明 如果打开此配置，请设置该值等于 sndbuff 与 recbuff 的最大值。 listener.wss.external.nodelay Type Optional Value Default enum true, false true 说明 即 TCP_NODELAY 参数。开启该选项即允许小的 TCP 数据报文将会立即发送。 listener.wss.external.compress Type Optional Value Default enum true, false false 说明 该选项若设置为 true，Websocket 消息将会被压缩。 listener.wss.external.deflate_opts.level Type Optional Value Default enum none, default, best_compression, best_speed default 说明 压缩等级。 listener.wss.external.deflate_opts.mem_level Type Optional Value Default integer 1 - 9 - 说明 压缩参数。内存使用限制等级，配置可开辟多少内存来参与压缩过程。 1：最少的内存，但会降低压缩率。 9：最多的内存，会提高计算速度和压缩率。 不配置，则默认为 8。 listener.wss.external.deflate_opts.strategy Type Optional Value Default enum default, filtered, huffman_only, rle - 说明 压缩策略，用于调优压缩率： default：针对普通数据。 filtered：由过滤器或预测器产生的数据，适用于分布随机性强的内容。 huffman_only：强制使用 Huffman 算法。优于 filtered。 rle：将匹配距离限制为 1 (Run-Lenght Encoding)，比 huffman_only 要快，但主要用于 PNG 图片。 这些策略仅影响压缩率，不会对正确性带来任何影响。 listener.wss.external.deflate_opts.server_context_takeover Type Optional Value Default enum takeover, no_takeover - 说明 是否允许服务端的压缩上下文在帧之间传递。 listener.wss.external.deflate_opts.client_context_takeover Type Optional Value Default enum takeover, no_takeover - 说明 是否允许客户端的压缩上下文在帧之间传递。 listener.wss.external.deflate_opts.server_max_window_bits Type Optional Value Default integer 8 - 15 - 说明 服务端最大窗口值。设置一个较大的值会有更好的压缩率，但会额外的消耗内存。 listener.wss.external.deflate_opts.client_max_window_bits Type Optional Value Default integer 8 - 15 - 说明 客户端最大窗口值。设置一个较大的值会有更好的压缩率，但会额外的消耗内存。 listener.wss.external.idle_timeout Type Default duration - 说明 TCP 连接建立后的发呆时间，如果这段时间内未收到任何报文，则会关闭该连接。 listener.wss.external.max_frame_size Type Default integer - 说明 允许的单个 MQTT 报文长度的最大值。 plugins plugins.etc_dir Type Default string etc/plugins 说明 插件的配置目录。 plugins.loaded_file Type Default string etc/loaded_plugins 说明 插件启动列表的配置文件路径。 plugins.expand_plugins_dir Type Default string plugins/ 说明 外部插件存放目录。 broker broker.sys_interval Type Default duration 1m 说明 设置系统主题 ($SYS) 消息的发布间隔。 broker.sys_heartbeat Type Default duration 30s 说明 设置系统心跳消息的发布间隔。系统心跳消息包括下面两个主题： \"$SYS/brokers//uptime\" \"$SYS/brokers//datetime\" broker.enable_session_registry Type Optional Value Default enum on, off on 说明 启用或关闭全局会话注册。 broker.session_locking_strategy Type Optional Value Default enum local, one, quorum, all quorum 说明 设置会话集群锁的类型。会话的集群锁用来防止同一个客户端在多个不同节点上创建多个会话，常见于客户端频繁切换节点登录的情况。 broker.shared_subscription_strategy Type Optional Value Default enum random, round_robin, sticky, hash random 说明 设置共享订阅的分发策略。可选值为: random: 在所有订阅者中随机选择 round_robin: 按照订阅顺序 sticky: 一直发往上次选取的订阅者 hash: 按照发布者 ClientID 的哈希值 broker.shared_dispatch_ack_enabled Type Optional Value Default enum true, false false 说明 开启或关闭共享订阅对于 qos1/qos2 消息的 ACK 检查功能。开启后，如果投递到某个订阅者但收不到ACK，将尝试投递给订阅组里的下一个订阅者。 broker.route_batch_clean Type Optional Value Default enum on, off off 说明 开启或关闭批量清理路由信息。批量清理路由可用在短时间内大量客户端掉线的情况，以提高清理效率。 monitor sysmon.long_gc Type Default duration 0ms 说明 启用垃圾回收时间监控并在回收时间超过设定值时触发告警，0 表示禁用此监控。 sysmon.long_schedule Type Default duration 240ms 说明 启用进程调度时间监控并在调度时间超过设定值时触发告警，0 表示禁用此监控。 sysmon.large_heap Type Default bytesize 8MB 说明 启用堆栈大小监控并在进程执行垃圾回收后堆栈大小仍大于设定值时触发告警，0 表示禁用此监控。 sysmon.busy_port Type Optional Value Default enum true, false false 说明 指定是否启用进程间消息通道拥塞监控。 sysmon.busy_dist_port Type Optional Value Default enum true, false true 说明 指定是否启用集群 RPC 通道拥塞监控。 os_mon.cpu_check_interval Type Default duration 60s 说明 CPU 占用率检查周期。 os_mon.cpu_high_watermark Type Default percent 80% 说明 CPU 占用率超过 os_mon.cpu_high_watermark 时将触发告警。 os_mon.cpu_low_watermark Type Default percent 60% 说明 CPU 占用率回落到 os_mon.cpu_low_watermark 以下时将清除告警。 os_mon.mem_check_interval Type Default duration 60s 说明 内存占用率检查周期。 os_mon.sysmem_high_watermark Type Default percent 70% 说明 EMQ X 为所有进程分配的内存占系统内存的百分比超过 os_mon.sysmem_high_watermark 时将触发告警。 os_mon.procmem_high_watermark Type Default percent 5% 说明 EMQ X 为单个进程分配的内存占系统内存的百分比超过 os_mon.procmem_high_watermark 时将触发告警。 vm_mon.check_interval Type Default duration 30s 说明 进程数量检查周期。 vm_mon.process_high_watermark Type Default percent 80% 说明 当前进程数量占进程最大数量的百分比超过 vm_mon.process_high_watermark 时将触发告警。进程最大数量由 node.process_limit 配置项决定。 vm_mon.process_low_watermark Type Default percent 60% 说明 当前进程数量占进程最大数量的百分比回落到 vm_mon.process_low_watermark 以下时将触发告警。进程最大数量由 node.process_limit 配置项决定。 emqx-auth-clientid auth.client..clientid&auth.client..password Type Default string - 说明 客户端的认证数据，其中 auth.client..password 为明文密码。 相同的 auth.client..clientid 与 auth.client..password 必须成对出现。 是一个整型数字，用于区分多个客户端的认证数据。 auth.client.password_hash Type Optional Value Default enum plain, md5, sha, sha256 sha256 说明 密码存储至数据库时使用的 Hash 算法。以下选项可用： plain 密码以明文形式存储。 md5 密码使用 MD5 算法加密后存储。 sha 密码使用 SHA-1 算法加密后存储。 sha256 密码使用 SHA-256 算法加密后存储。 emqx-auth-http auth.http.auth_req Type Default string http://127.0.0.1:8991/mqtt/auth 说明 指定认证请求的目标 URL。 auth.http.auth_req.method Type Optional Value Default enum get, post post 说明 指定认证请求的请求方法。 auth.http.auth_req.params Type Format Default string 以 , 分隔的 k=v 键值对，v 可以是固定内容，也可以是占位符 clientid=%c,username=%u,password=%P 说明 指定认证请求中携带的数据。使用 GET 方法时 auth.http.auth_req.params 的值将被转换为以 & 分隔的 k=v 键值对以查询字符串参数的形式发送。使用 POST 方法时 auth.http.auth_req.params 的值将被转换为以 & 分隔的 k=v 键值对以 Request Body 的形式发送。所有的占位符都会被运行时数据所替换，可用的占位符如下： 占位符 替换内容 %u 用户名 %c MQTT Client ID %a 客户端的网络 IP 地址 %r 客户端使用的协议，可以是：mqtt, mqtt-sn, coap, lwm2m 以及 stomp %P 密码 %p 客户端连接的服务端端口 %c 客户端证书中的 Common Name %d 客户端证书中的 Subject auth.http.super_req Type Default string http://127.0.0.1:8991/mqtt/superuser 说明 指定超级用户认证请求的目标 URL。 auth.http.super_req.method Type Optional Value Default enum get, post post 说明 指定超级用户认证请求的请求方法。 auth.http.super_req.params Type Format Default string 以 , 分隔的 k=v 键值对，v 可以是固定内容，也可以是占位符 clientid=%c,username=%u 说明 指定超级用户认证请求中携带的数据。使用 GET 方法时 auth.http.super_req.params 的值将被转换为以 & 分隔的 k=v 键值对以查询字符串参数的形式发送。使用 POST 方法时 auth.http.super_req.params 的值将被转换为以 & 分隔的 k=v 键值对以 Request Body 的形式发送。所有的占位符都会被运行时数据所替换，可用的占位符同 auth.http.auth_req.params。 auth.http.acl_req Type Default string http://127.0.0.1:8991/mqtt/acl 说明 指定 ACL 验证请求的目标 URL。 auth.http.acl_req.method Type Optional Value Default enum get, post post 说明 指定 ACL 验证请求的请求方法。 auth.http.acl_req.params Type Format Default string 以 , 分隔的 k=v 键值对，v 可以是固定内容，也可以是占位符 access=%A,username=%u,clientid=%c,ipaddr=%a,topic=%t,mountpoint=%m 说明 指定 ACL 验证请求中携带的数据。使用 GET 方法时 auth.http.acl_req.params 的值将被转换为以 & 分隔的 k=v 键值对以查询字符串参数的形式发送。使用 POST 方法时 auth.http.acl_req.params 的值将被转换为以 & 分隔的 k=v 键值对以 Request Body 的形式发送。所有的占位符都会被运行时数据所替换，可用的占位符如下： 占位符 替换内容 %A 需要验证的权限，1 表示订阅，2 表示发布 %u MQTT Client ID %c 客户端标识符 %a 客户端的网络 IP 地址 %r 客户端使用的协议，可以是：mqtt, mqtt-sn, coap, lwm2m 以及 stomp %m 挂载点 %t 主题 auth.http.request.timeout Type Default duration 0s 说明 HTTP 请求超时时间。任何等价于 0s 的设定值都表示永不超时。 auth.http.request.connect_timeout Type Default duration 0s 说明 HTTP 请求的连接超时时间。任何等价于 0s 的设定值都表示永不超时。 auth.http.request.retry_times Type Default integer 3 说明 HTTP 请求失败时的重试次数。 auth.http.request.retry_interval Type Default duration 1s 说明 HTTP 请求失败时的重试间隔。 auth.http.request.retry_backoff Type Default float 2.0 说明 HTTP 请求失败时的重试间隔使用了指数退避算法，此配置项用于指定指数退避算法的退避系数。 auth.http.header. Type Default string - 说明 指定 HTTP 请求头部中的数据。 指定 HTTP 请求头部中的字段名，此配置项的值为相应的字段值。 可以是标准的 HTTP 请求头部字段，也可以自定义的字段，可以配置多个不同的请求头部字段。 示例 auth.http.header.Accept = */* auth.http.header.Accept-Encoding = * auth.http.ssl.cacertfile Type Default string etc/certs/ca.pem 说明 CA 证书文件路径。 auth.http.ssl.certfile Type Default string etc/certs/client-cert.pem 说明 客户端证书文件路径。 auth.http.ssl.keyfile Type Default string etc/certs/client.key.pem 说明 客户端私钥文件路径。 emqx-auth-jwt auth.jwt.secret Type Default string emqxsecret 说明 设置 HMAC Secret。 auth.jwt.from Type Optional Value Default enum username, password password 说明 从什么地方获取 JWT。可选值为: username: MQTT CONNECT 报文的 username 字段作为 JWT。 password: MQTT CONNECT 报文的 password 字段作为 JWT。 auth.jwt.pubkey Type Default string etc/certs/jwt_public_key.pem 说明 若使用 RSA 或者 ECDSA 加密算法，须指定私钥文件。 auth.jwt.verify_claims Type Optional Value Default enum on, off off 说明 启用或关闭 Claims 校验功能。 auth.jwt.verify_claims. Type Default string - 说明 启用 Claims 校验功能时，可设置 JWT 中字段的可选值。 例如，若期望 JWT 中的 Claim 字段 sub 的值为 \"abc\"，则可以配置如下规则: auth.jwt.verify_claims.sub = abc 期望值支持两个通配符: %u: username %c: clientid 例如，若期望 JWT 中的 Claim 字段 sub 的值与 MQTT CONNECT 报文中 username 字段相同，则可以配置如下规则: auth.jwt.verify_claims.sub = %u emqx-auth-ldap auth.ldap.servers Type Default string 127.0.0.1 说明 LDAP 服务地址。 auth.ldap.port Type Default integer 389 说明 LDAP 服务端口。 auth.ldap.pool Type Optional Value Default integer > 0 8 说明 连接池大小。 auth.ldap.bind_dn Type Default string cn=root,dc=emqx,dc=io 说明 登入 LDAP 服务的 DN。 auth.ldap.bind_password Type Default string public 说明 登入 LDAP 服务的密码。 auth.ldap.timeout Type Default duration 30s 说明 查询操作的超时时间。 auth.ldap.device_dn Type Default string ou=device,dc=emqx,dc=io 说明 客户端隶属的 DN。 auth.ldap.match_objectclass Type Default string mqttUser 说明 客户端对象的名称。 auth.ldap.username.attributetype Type Default string uid 说明 Username 属性的数据类型。 auth.ldap.password.attributetype Type Default string userPassword 说明 Password 属性的数据类型。 auth.ldap.ssl Type Optional Value Default enum true, false false 说明 是否开启 SSL。 auth.ldap.ssl.certfile Type Default string - 说明 SSL 服务端证书路径。 auth.ldap.ssl.keyfile Type Default string - 说明 SSL 服务端秘钥文件路径。 auth.ldap.ssl.cacertfile Type Default string - 说明 CA 证书文件路径。 auth.ldap.ssl.verify Type Optional Value Default enum verify_peer, verify_none - 说明 SSL 认证方式： verify_none：单向认证。 verify_peer：双向认证。 auth.ldap.ssl.fail_if_no_peer_cert Type Optional Value Default enum true, false false 说明 如果客户端未提供 SSL 证书，则断开连接。 emqx-auth-mongo auth.mongo.type Type Optional Value Default enum single, unknown, sharded, rs single 说明 设置 MongoDB 的拓扑类型: single: 单节点 unknown: 未知 sharded: 分片模式 rs: 副本模式 (replicated set) auth.mongo.rs_set_name Type Default string - 说明 在使用 rs 模式的情况下，设置 rs 的名字。 auth.mongo.rs_set_name Type Default string 127.0.0.1:27017 说明 设置 MongoDB 服务的地址。如有多个使用逗号 , 分隔。 auth.mongo.pool Type Default integer 8 说明 设置 MongoDB 连接池的进程数。 auth.mongo.login Type Default string - 说明 设置 MongoDB 的用户名。 auth.mongo.password Type Default string - 说明 设置 MongoDB 的密码。 auth.mongo.auth_source Type Default string mqtt 说明 设置 MongoDB 的认证源数据库名。 auth.mongo.database Type Default string mqtt 说明 设置 MongoDB 的数据库名。 auth.mongo.query_timeout Type Default duration 5s 说明 设置访问 MongoDB 超时时间。 auth.mongo.ssl Type Optional Value Default enum true, false false 说明 设置是否使用 SSL 访问 MongoDB。 auth.mongo.ssl_opts.keyfile Type Default string - 说明 若使用 SSL 访问 MongoDB，设置 SSL 客户端的私钥文件。 auth.mongo.ssl_opts.certfile Type Default string - 说明 若使用 SSL 访问 MongoDB，设置 SSL 客户端的证书文件。 auth.mongo.ssl_opts.cacertfile Type Default string - 说明 若使用 SSL 访问 MongoDB，设置 SSL 的 CA 证书文件。 auth.mongo.w_mode Type Optional Value Default enum unsafe, safe, undef undef 说明 设置 MongoDB 的写入模式。 auth.mongo.r_mode Type Optional Value Default enum master, slave_ok, undef undef 说明 设置 MongoDB 的读取模式。 auth.mongo.auth_query.collection Type Default string mqtt_user 说明 认证过程用的 Collection 名字。 auth.mongo.auth_query.password_field Type Default string password 说明 认证过程用的主要字段。如需在密码之后加 salt，可以配置为: auth.mongo.auth_query.password_field = password,salt auth.mongo.auth_query.password_hash Type Optional Value Default enum plain, md5, sha, sha256, bcrypt sha256 说明 设置密码字段用的哈希算法。如需在 sha256 密码之后加 salt，可以设置为: auth.mongo.auth_query.password_hash = sha256,salt 如需在 sha256 密码之前加 salt，可以设置为: auth.mongo.auth_query.password_hash = salt,sha256 如需在 bcrypt 密码之前加 salt，可以设置为: auth.mongo.auth_query.password_hash = salt,bcrypt auth.mongo.auth_query.selector Type Default string username=%u 说明 认证过程执行的 MongoDB 语句。命令可支持通配符: %u: username %c: clientid %C: 客户端 TLS 证书里的 Common Name %d: 客户端 TLS 证书里的 Subject auth.mongo.auth_query.super_query Type Optional Value Default enum on, off on 说明 认证中是否使用 SuperUser。 auth.mongo.super_query.collection Type Default string mqtt_user 说明 若使用 SuperUser，指定 SuperUser 的 MongoDB Collection。 auth.mongo.super_query.selector Type Default string username=%u, clientid=%c 说明 若使用 SuperUser，指定查询 SuperUser 使用的 MongoDB 语句。 auth.mongo.acl_query Type Optional Value Default enum on, off on 说明 是否开启 ACL 功能。 auth.mongo.acl_query.collection Type Default string mqtt_acl 说明 若使用 ACL 功能，指定查询 ACL 规则的 MongoDB Collection。 auth.mongo.acl_query.selector Type Default string username=%u 说明 若使用 ACL 功能，指定查询 ACL 规则使用的 MongoDB 语句。可支持多个 ACL 语句，多个语句之间使用 or 连接。 例如，配置如下两条访问规则： auth.mongo.acl_query.selector.1 = username=%u auth.mongo.acl_query.selector.2 = username=$all 并且客户端的 username='ilyas'，则在查询 acl 规则的时候，会执行如下 MongoDB 语句： db.mqtt_acl.find({$or: [{username: \"ilyas\"}, {username: \"$all\"}]}); auth.mongo.topology.pool_size Type Default integer 1 说明 MongoDB 拓扑参数，设置线程池大小。 auth.mongo.topology.max_overflow Type Default integer 0 说明 MongoDB 拓扑参数，当线程池中所有 workers 都处于忙碌状态时，允许创建多少额外的 worker 线程。 auth.mongo.topology.overflow_ttl Type Default integer 1000 说明 MongoDB 拓扑参数，当有 worker 空闲时。多久之后释放额外的 worker 线程。单位: 毫秒。 auth.mongo.topology.overflow_check_period Type Default integer 1000 说明 MongoDB 拓扑参数，多长时间检查一次有无空闲线程，以释放额外的 worker。 auth.mongo.topology.local_threshold_ms Type Default integer 1000 说明 MongoDB 拓扑参数，选择用来处理用户请求的 Secondary 节点的策略。记到所有节点的 RTT 中的最小值为 LowestRTT，那么只有那些 RTT auth.mongo.topology.connect_timeout_ms Type Default integer 20000 说明 MongoDB 拓扑参数，MongoDB 连接超时时间，单位: 毫秒。 auth.mongo.topology.socket_timeout_ms Type Default integer 100 说明 MongoDB 拓扑参数，MongoDB 消息发送超时时间，单位: 毫秒。 auth.mongo.topology.server_selection_timeout_ms Type Default integer 30000 说明 MongoDB 拓扑参数，选择 MongoDB Server 的超时时间，单位: 毫秒。 auth.mongo.topology.wait_queue_timeout_ms Type Default integer 1000 说明 MongoDB 拓扑参数，从线程池中选取 worker 的等待超时时间，单位: 毫秒。 auth.mongo.topology.heartbeat_frequency_ms Type Default integer 10000 说明 MongoDB 拓扑参数，拓扑扫描之间的间隔时间，单位: 毫秒。 auth.mongo.topology.min_heartbeat_frequency_ms Type Default integer 1000 说明 MongoDB 拓扑参数，heartbeat_frequency_ms 允许的最小值，单位: 毫秒。 emqx-auth-mysql auth.mysql.server Type Default ip 127.0.0.1:3306 说明 MySQL 服务器地址。 auth.mysql.pool Type Default integer 8 说明 数据库连接线程池大小。 auth.mysql.username Type Default string - 说明 MySQL 用户名。 auth.mysql.password Type Default string - 说明 MySQL 密码。 auth.mysql.database Type Default string mqtt 说明 MySQL 数据库名称。 auth.mysql.query_timeout Type Default duration 5s 说明 MySQL 数据查询超时时间。查询超时将等同于未找到用户数据处理。 auth.mysql.auth_query Type Default string select password from mqtt_user where username = '%u' limit 1 说明 认证时使用的 MySQL 选取语句，选取出来的数据将与经过由 auth.mysql.password_hash 指定的加密方式加密的密码进行比较，比较后内容一致的客户端将被允许登录。加盐后存储的密码需要同时选取盐对应的字段，例如 select password, salt from mqtt_user where username = '%u' limit 1。password 与 salt 字段名不可以修改，表名与 WHERE 子句中的字段名可以视情况变化。WHERE 子句支持以下占位符： 占位符 说明 %u 将被替换为 MQTT 客户端在 CONNECT 报文中指定的用户名 %c 将被替换为 MQTT 客户端在 CONNECT 报文中指定的客户端标识符 %C 将被替换为 TLS 连接时客户端证书中的 Common Name %d 将被替换为 TLS 连接时客户端证书中的 Subject auth.mysql.password_hash Type Default string sh256 说明 存储在数据库的密码所使用的加密方式。支持以下加密方式： plain，支持前后加盐，例如 salt,plain md5，支持前后加盐 sha，支持前后加盐 sha256，支持前后加盐 sha512，支持前后加盐 pbkdf2，格式为 pbkdf2,,,。其中， 为使用的哈希函数，支持 md4，md5，ripemd160，sha，sha224，sha256，sha384，sha512， 为迭代次数， 为导出密钥长度。示例：pbkdf2,sha256,1000,20 bcrypt，仅支持前向加盐，例如 salt,bcrypt auth.mysql.super_query Type Default string select is_superuser from mqtt_user where username = '%u' limit 1 说明 超级用户认证时使用的 SQL 选取语句，此语句中所有表名与字段名都可视情况修改，当且仅当选取得到字段的值为 1 时，该用户为超级用户。WHERE 子句中支持的占位符与 auth.mysql.auth_query 相同。 auth.mysql.acl_query Type Default string select allow, ipaddr, username, clientid, access, topic from mqtt_acl where ipaddr = '%a' or username = '%u' or username = '$all' or clientid = '%c' 说明 ACL 校验时使用的 SQL 选取语句，此语句中所有表名与字段名都可视情况修改。WHERE 子句中支持的占位符如下： 占位符 说明 %a 将被替换为客户端 IP 地址 %u 将被替换为 MQTT 客户端在 CONNECT 报文中指定的用户名 %c 将被替换为 MQTT 客户端在 CONNECT 报文中指定的客户端标识符 emqx-auth-pgsql auth.pgsql.server Type Default ip 127.0.0.1:5432 说明 PostgreSQL 服务器地址。 auth.pgsql.pool Type Default integer 8 说明 数据库连接线程池大小。 auth.pgsql.username Type Default string root 说明 PostgreSQL 用户名。 auth.pgsql.password Type Default string - 说明 PostgreSQL 密码。 auth.pgsql.database Type Default string mqtt 说明 PostgreSQL 数据库名称。 auth.pgsql.encoding Type Default string utf8 说明 PostgreSQL 数据库字符编码格式。 auth.pgsql.ssl Type Optional Value Default enum true, false false 说明 是否启用 TLS 连接。 auth.pgsql.ssl_opts.keyfile Type Default string - 说明 客户端私钥文件路径。 auth.pgsql.ssl_opts.certfile Type Default string - 说明 客户端证书文件路径。 auth.pgsql.ssl_opts.cacertfile Type Default string - 说明 客户端 CA 证书文件路径。 auth.pgsql.auth_query Type Default string select password from mqtt_user where username = '%u' limit 1 说明 认证时使用的 SQL 选取语句，同 auth.mysql.auth_query。 auth.pgsql.password_hash Type Default string sh256 说明 存储在数据库的密码所使用的加密方式，同 auth.mysql.password_hash。 auth.pgsql.super_query Type Default string select is_superuser from mqtt_user where username = '%u' limit 1 说明 超级用户认证时使用的 SQL 选取语句，同 auth.mysql.super_query。 auth.pgsql.acl_query Type Default string select allow, ipaddr, username, clientid, access, topic from mqtt_acl where ipaddr = '%a' or username = '%u' or username = '$all' or clientid = '%c' 说明 ACL 校验时使用的 SQL 选取语句，同 auth.mysql.acl_query。 emqx-auth-redis auth.redis.type Type Optional Value Default enum single, sentinel, cluster single 说明 Redis 服务集群类型： single：单节点服务。 sentinel：哨兵模式。 cluster：集群模式。 auth.redis.server Type Default string 127.0.0.1:6379 说明 Redis 服务地址，如果有多个则以逗号分隔。例如，192.168.0.1:6379, 192.168.0.2:6379。 auth.redis.sentinel Type Default string - 说明 Redis sentinel 模式下的集区名称。如果非 sentinel 模式，则不需要配置。 auth.redis.pool Type Optional Value Default integer > 0 8 说明 连接池大小。 auth.redis.database Type Default integer 0 说明 要连接的 Redis 数据库序号。 auth.redis.password Type Default string - 说明 Redis 用户密码。 auth.redis.query_timeout Type Default duration 5s 说明 Redis 查询超时时间。 auth.redis.auth_cmd Type Default string HMGET mqtt_user:%u password 说明 认证查询命令，可用站位符有： %u：客户端用户名。 %c：客户端标识。 %C：客户端 SSL 证书的 cn。 %d：客户端 SSL 证书的 dn。 auth.redis.password_hash Type Optional Value Default enum plain, md5, sha, sha256, bcrypt plain 说明 Redis 存储的 password 字段的编码格式。 auth.redis.super_cmd Type Default string HGET mqtt_user:%u is_superuser 说明 超级用户查询命令，可用的占位符有： %u：客户端用户名。 %c：客户端标识。 %C：客户端 SSL 证书的 cn。 %d：客户端 SSL 证书的 dn。 auth.redis.acl_cmd Type Default string HGETALL mqtt_acl:%u 说明 ACL 查询命令。可用的占位符有： %u：客户端用户名。 %c：客户端标识。 emqx-auth-username auth.user..username&auth.user..password Type Default string - 说明 客户端的认证数据，其中 auth.user..password 为明文密码。 相同的 auth.user..username 与 auth.user..password 必须成对出现。 是一个整型数字，用于区分多个客户端的认证数据。 auth.user.password_hash Type Optional Value Default enum plain, md5, sha, sha256 sha256 说明 密码存储至数据库时使用的 Hash 算法。以下选项可用： plain 密码以明文形式存储。 md5 密码使用 MD5 算法加密后存储。 sha 密码使用 SHA-1 算法加密后存储。 sha256 密码使用 SHA-256 算法加密后存储。 emqx-bridge-mqtt bridge.mqtt.aws.address Type Default string 127.0.0.1:1883 说明 桥接地址，支持两种格式，例如： emqx@192.168.0.100：EMQ X 节点名称，它表示将该节点的消息桥接到另外一个 EMQ X 节点。 192.168.0.100:1883：IP 地址和端口，它表示将该节点的消息通过一个 MQTT 连接桥接到另外一个 MQTT 服务器。 bridge.mqtt.aws.proto_ver Type Optional Value Default enum mqttv3, mqttv4, mqttv5 mqttv4 说明 MQTT 桥接的客户端协议版本。 bridge.mqtt.aws.start_type Type Optional Value Default eunm manual, auto manual 说明 启动类型： auto：跟随插件自动启动。 manual：手动启动桥接。 bridge.mqtt.aws.bridge_mode Type Optional Value Default boolean true, false true 说明 是否开启桥接模式，仅 MQTT 桥接支持。开启后 emqx_bridge_mqtt 启动的 MQTT 客户端在发送连接报文时会携带一个标志位，标识这是一个桥接客户端。 注：RabbitMQ 目前不支持该标志。 bridge.mqtt.aws.clientid Type Default string bridge_aws 说明 MQTT 桥接的客户端标识。 bridge.mqtt.aws.clean_start Type Optional Value Default boolean true, false true 说明 MQTT 桥接的 clean_start 标志。它表示客户端是否以 清楚会话 的方式连接到远程 MQTT Broker。 bridge.mqtt.aws.username Type Default string user 说明 MQTT 桥接客户端的用户名。 bridge.mqtt.aws.password Type Default string passwd 说明 MQTT 桥接客户端的密码。 bridge.mqtt.aws.forwards Type Default string topic1/#,topic2/# 说明 桥接转发规则。例如： topic1/#, topic2/#：emqx_bridge_mqtt 会将 EMQ X 中所以与 topic1/#，topic2/# 匹配的主题消息进行转发。 bridge.mqtt.aws.forward_mountpoint Type Default string bridge/aws/${node}/ 说明 转发主题的前缀。将消息转发到目标系统时，支持给该主题添加一个统一的前缀。 bridge.mqtt.aws.subscription.1.topic Type Default string - 说明 订阅对端系统的主题。 bridge.mqtt.aws.subscription.1.qos Type Optional Value Default enum 0, 1, 2 1 说明 订阅对端系统主题的 QoS。 bridge.mqtt.aws.receive_mountpoint Type Default string receive/aws/ 说明 接收消息的主题前缀。emqx_bridge_mqtt 支持给来着对端的消息添加一个统一的主题前缀。 bridge.mqtt.aws.ssl Type Optional Value Default boolean true, false true 说明 MQTT 桥接客户端是否开启 SSL。 bridge.mqtt.aws.cacertfile Type Default string etc/certs/cacert.pem 说明 MQTT 桥接客户端的 CA 证书文件路径。 bridge.mqtt.aws.certfile Type Default string etc/certs/client-cert.pem 说明 MQTT 桥接客户端的 SSL 证书文件路径。 bridge.mqtt.aws.keyfile Type Default string etc/certs/client-key.pem 说明 MQTT 桥接客户端的 SSL 秘钥文件路径。 bridge.mqtt.aws.ciphers Type Default string ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384 说明 SSL 握手支持的加密套件。 bridge.mqtt.aws.psk_ciphers Type Default string PSK-AES128-CBC-SHA,PSK-AES256-CBC-SHA,PSK-3DES-EDE-CBC-SHA,PSK-RC4-SHA 说明 SSL PSK 握手支持的加密套件。 bridge.mqtt.aws.keepalive Type Default duration 60s 说明 MQTT 桥接客户端的心跳间隔。 bridge.mqtt.aws.tls_versions Type Default string tlsv1.2,tlsv1.1,tlsv1 说明 MQTT 桥接客户端的 SSL 版本。 bridge.mqtt.aws.reconnect_interval Type Default duration 30s 说明 重连间隔。 bridge.mqtt.aws.retry_interval Type Default duration 20s 说明 QoS 1/2 消息重发间隔。 bridge.mqtt.aws.batch_size Type Default integer 32 说明 EMQ X 桥接的批处理大小。emqx_bridge_mqtt 的 EMQ X 桥接模式支持批量发送消息以提搞吞吐。 bridge.mqtt.aws.max_inflight_size Type Default integer 32 说明 飞行窗口大小。 bridge.mqtt.aws.queue.replayq_dir Type Default string etc/emqx_aws_bridge/ 说明 设置消息队列文件路径。不配置则仅使用内存存储。 bridge.mqtt.aws.queue.replayq_seg_bytes Type Default bytesize 10MB 说明 消息队列存储在磁盘的单个文件大小。 bridge.mqtt.aws.queue.max_total_size Type Default bytesize 5GB 说明 消息队列允许存储的最大值。 emqx-coap coap.port Type Default integer 5683 说明 指定 CoAP 插件的 UDP 绑定端口。 coap.enable_stats Type Optional Value Default enum on, off off 说明 启用或关闭 CoAP 的统计功能。 coap.dtls.port Type Default integer 5684 说明 指定 CoAP 插件的 DTLS 绑定端口。 coap.dtls.verify Type Optional Value Default enum verify_peer, verify_none verify_peer 说明 使用 DTLS 时，指定 DTLS 握手过程中是否校验客户端。 coap.dtls.keyfile Type Default string etc/certs/key.pem 说明 使用 DTLS 时，指定 DTLS 的私钥文件。 coap.dtls.certfile Type Default string etc/certs/cert.pem 说明 使用 DTLS 时，指定 DTLS 的证书文件。 coap.dtls.cacertfile Type Default string etc/certs/cacert.pem 说明 使用 DTLS 时，指定 DTLS 的 CA 证书文件。 coap.dtls.fail_if_no_peer_cert Type Optional Value Default enum true, false false 说明 使用 DTLS 时，DTLS 握手过程中若客户端没有证书，是否让握手失败。 coap.dtls.ciphers Type Default string ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA 说明 使用 DTLS 时，指定 DTLS 服务端支持的 Cipher 列表。 emqx-dashboard dashboard.default_user.login&dashboard.default_user.password Type Default string - 说明 Dashboard 默认用户的认证数据。dashboard.default_user.login 与 dashboard.default_user.password 必须同时存在。 dashboard.listener.http Type Default integer 18083 说明 HTTP 监听器的监听端口。 dashboard.listener.http.acceptors Type Default integer 4 说明 此监听器将创建的监听进程数量。 dashboard.listener.http.max_clients Type Default integer 512 说明 此监听器允许同时建立的最大连接数量限制。 dashboard.listener.http.inet6 Type Optional Value Default enum ture, false false 说明 是否设置套接字允许 IPv6 连接。 dashboard.listener.http.ipv6_v6only Type Optional Value Default enum ture, false false 说明 是否限制套接字仅使用 IPv6，禁止任何 IPv4 连接。仅适用于 IPv6 套接字，即仅在 dashboard.listener.http.inet6 被设置为 true 时此配置项的值有实际意义。需要注意的是，在某些操作系统上，例如 Windows，此配置项唯一允许的值为 true。 dashboard.listener.https Type Default integer 18084 说明 HTTPS 监听器的监听端口，默认此监听器被禁用。 dashboard.listener.https.acceptors Type Default integer 2 说明 同 dashboard.listener.http.acceptors。 dashboard.listener.https.max_clients Type Default integer 512 说明 同 dashboard.listener.http.max_clients。 dashboard.listener.https.inet6 Type Optional Value Default enum ture, false false 说明 同 dashboard.listener.http.inet6。 dashboard.listener.https.ipv6_v6only Type Optional Value Default enum ture, false false 说明 同 dashboard.listener.http.ipv6_v6only。 dashboard.listener.https.keyfile Type Default string etc/certs/key.pem 说明 服务端私钥文件路径。 dashboard.listener.https.certfile Type Default string etc/certs/cert.pem 说明 服务端证书文件路径。 dashboard.listener.https.cacertfile Type Default string etc/certs/cacert.pem 说明 CA 证书文件路径。 dashboard.listener.https.dhfile Type Default string etc/certs/dh-params.pem 说明 如果协商使用 Diffie Hellman 密钥交换的密码套件，则可以通过此配置项指定包含 PEM 编码的 Diffie Hellman 参数的文件路径。 如果未指定，则使用默认参数。 dashboard.listener.https.verify Type Optional Value Default enum verify_peer, verify_none verify_peer 说明 verify_none 表示关闭对端证书验证，服务端不会向客户端发出证书请求。verify_peer 表示开启对端证书验证，服务端会向客户端发出证书请求。当此配置项被设置为 verify_peer 时，通常需要配合 dashboard.listener.https.fail_if_no_peer_cert 一起使用，以指定是否强制客户端提供证书。 dashboard.listener.https.fail_if_no_peer_cert Type Optional Value Default enum ture, false true 说明 必须配合 dashboard.listener.https.verify 一起使用。如果设置为 true，则服务端向客户端请求证书时如果客户端不提供证书将导致握手失败。如果设置为 false，则客户端即使不提供证书也能握手成功。 dashboard.listener.https.tls_versions Type Default string tlsv1.2,tlsv1.1,tlsv1 说明 指定服务端支持的 TLS 协议版本，版本之间由 , 分隔，支持的 TLS 协议版本有： tlsv1.3, tlsv1.2, tlsv1.1, tlsv1, sslv3。 dashboard.listener.https.ciphers Type Default string ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA 说明 指定服务端支持的加密套件。 dashboard.listener.https.secure_renegotiate Type Optional Value Default enum on, off off 说明 指定是否启动安全重协商机制。 dashboard.listener.https.reuse_sessions Type Optional Value Default enum on, off on 说明 指定是否启用会话复用机制。 dashboard.listener.https.honor_cipher_order Type Optional Value Default enum on, off on 说明 如果设置为 on，则使用服务器的首选项进行密码选择。 如果设置为 off，则使用客户端的首选项。 emqx-lwm2m lwm2m.port Type Default integer 5683 说明 指定 LwM2M 使用的 UDP 端口。 lwm2m.lifetime_min Type Default duration 1s 说明 指定允许的 LwM2M lifetime 最小值，单位: 秒。 lwm2m.lifetime_max Type Default duration 86400s 说明 指定允许的 LwM2M lifetime 最大值，单位: 秒。 lwm2m.qmode_time_window Type Default integer 22 说明 指定 LwM2M Q 模式使用的窗口大小，单位: 秒。 这个窗口期之内可以下发执行给 Q 模式的设备，过了窗口期则缓存下行数据。 lwm2m.lb Type Optional Value Default enum coaproxy, undefined undefined 说明 设置是否使用 coaproxy。设置为 undefined 则不使用 coaproxy。 lwm2m.auto_observe Type Optional Value Default enum on, off off 说明 在设备注册后是否自动下发 observe 命令。 lwm2m.mountpoint Type Default string lwm2m/%e/ 说明 设置 LwM2M 主题的挂载点。支持以下通配符: '%e': Endpoint Name '%a': IP Address lwm2m.topics.command Type Default string dn/# 说明 设备注册完成后，需要订阅的下行命令主题。 lwm2m.topics.response Type Default string up/resp 说明 设备的上行回复需要发布到哪个主题。 lwm2m.topics.notify Type Default string up/notify 说明 设备的上行报告消息 (notify) 需要发布到哪个主题。 lwm2m.topics.register Type Default string up/resp 说明 设备的上行注册消息 (register) 需要发布到哪个主题。 lwm2m.topics.update Type Default string up/resp 说明 设备的上行更新消息 (update) 需要发布到哪个主题。 lwm2m.opts.buffer Type Default bytesize 1024KB 说明 UDP 调优参数，指定 UDP 用户态缓存大小。 lwm2m.opts.recbuf Type Default bytesize 1024KB 说明 UDP 调优参数，指定 UDP 接收缓存大小。 lwm2m.opts.sndbuf Type Default bytesize 1024KB 说明 UDP 调优参数，指定 UDP 发送缓存大小。 lwm2m.opts.read_packets Type Default integer 20 说明 UDP 调优参数，指定每次从 UDP socket 读取多少个报文。 lwm2m.certfile Type Default string etc/certs/cert.pem 说明 指定 UDP DTLS 使用的证书文件。 lwm2m.keyfile Type Default string etc/certs/key.pem 说明 指定 UDP DTLS 使用的私钥文件。 lwm2m.xml_dir Type Default dir etc/lwm2m_xml 说明 指定 LwM2M Object 定义文件存放的目录。 emqx-management management.max_row_limit Type Default integer 10000 说明 分页查询时返回的最大记录数量。 management.default_application.id Type Default string admin 说明 默认应用的 AppId。 management.default_application.secret Type Default string public 说明 默认应用的 AppSecret。 management.listener.http Type Default integer 8081 说明 HTTP 监听器的监听端口。 management.listener.http.acceptors Type Default integer 2 说明 此监听器将创建的监听进程数量。 management.listener.http.max_clients Type Default integer 512 说明 此监听器允许同时建立的最大连接数量限制。 management.listener.http.backlog Type Default integer 512 说明 TCP 连接队列的最大长度。它表明了系统中允许的正在三次握手的 TCP 连接队列最大个数。 management.listener.http.send_timeout Type Default duration 15s 说明 HTTP 报文发送超时时间。 management.listener.http.send_timeout_close Type Optional Value Default enum on, off on 说明 HTTP 报文发送超时后，是否关闭该连接。 management.listener.http.inet6 Type Optional Value Default enum true, false false 说明 是否设置套接字允许 IPv6 连接。 management.listener.http.ipv6_v6only Type Optional Value Default enum true, false false 说明 是否限制套接字仅使用 IPv6，禁止任何 IPv4 连接。仅适用于 IPv6 套接字，即仅在 management.listener.http.inet6 被设置为 true 时此配置项的值有实际意义。需要注意的是，在某些操作系统上，例如 Windows，此配置项唯一允许的值为 true。 management.listener.https Type Default Example integer - 8081 说明 HTTPS 监听器的监听端口。 management.listener.https.acceptors Type Default integer 2 说明 此监听器将创建的监听进程数量。 management.listener.https.max_clients Type Default integer 512 说明 此监听器允许同时建立的最大连接数量限制。 management.listener.https.backlog Type Default integer 512 说明 TCP 连接队列的最大长度。它表明了系统中允许的正在三次握手的 TCP 连接队列最大个数。 management.listener.https.send_timeout Type Default duration 15s 说明 HTTPS 报文发送超时时间。 management.listener.https.send_timeout_close Type Optional Value Default enum on, off on 说明 HTTPS 报文发送超时后，是否关闭该连接。 management.listener.https.keyfile Type Default string etc/certs/key.pem 说明 服务端私钥文件路径。 management.listener.https.certfile Type Default string etc/certs/cert.pem 说明 服务端证书文件路径。 management.listener.https.cacertfile Type Default string etc/certs/cacert.pem 说明 CA 证书文件路径。 management.listener.https.verify Type Optional Value Default enum verify_peer, verify_none verify_peer 说明 verify_none 表示关闭对端证书验证，服务端不会向客户端发出证书请求。verify_peer 表示开启对端证书验证，服务端会向客户端发出证书请求。当此配置项被设置为 verify_peer 时，通常需要配合 management.listener.https.fail_if_no_peer_cert 一起使用，以指定是否强制客户端提供证书。 management.listener.https.fail_if_no_peer_cert Type Optional Value Default enum ture, false true 说明 必须配合 management.listener.https.verify 一起使用。如果设置为 true，则服务端向客户端请求证书时如果客户端不提供证书将导致握手失败。如果设置为 false，则客户端即使不提供证书也能握手成功。 management.listener.https.inet6 Type Optional Value Default enum true, false false 说明 是否设置套接字允许 IPv6 连接。 management.listener.https.ipv6_v6only Type Optional Value Default enum true, false false 说明 是否限制套接字仅使用 IPv6，禁止任何 IPv4 连接。仅适用于 IPv6 套接字，即仅在 management.listener.https.inet6 被设置为 true 时此配置项的值有实际意义。需要注意的是，在某些操作系统上，例如 Windows，此配置项唯一允许的值为 true。 emqx-reloader reloader.interval Type Default duration 60s 说明 每隔多长时间将所有代码代码热更新一次。 reloader.logfile Type Default string reloader.log 说明 代码热更新的日志文件 emqx-retainer retainer.storage_type Type Optional Value Default enum ram, disc, disc_only ram 说明 保留消息的存储类型，以下选项可用： ram 保留消息仅存储在内存中。 disc 保留消息同时存储在内存和磁盘中。 disc_only 保留消息仅存储在磁盘中。 retainer.max_retained_messages Type Default integer 0 说明 保留消息的存储数量限制。一旦存储数量达到限制，可以替换已存在的保留消息，但不能为新的主题存储保留消息。0 表示没有限制。 retainer.max_payload_size Type Default bytesize 1MB 说明 允许存储的保留消息的 Payload 最大长度限制。如果 Payload 超出最大限制，该保留消息可以被正常处理，但不会存储在服务端。 retainer.expiry_interval Type Default duration 0 说明 保留消息的过期间隔，仅对协议版本低于 MQTT v5.0 的客户端生效，MQTT v5.0 客户端的保留消息过期间隔将以 Message Expiry Interval 的值为准。0 表示永不过期。 emqx-rule-engine rule-engine.ignore_sys_message Type Optional Value Default enum on, off on 说明 忽略系统消息 ($SYS)。启用此选项规则引擎将不会处理系统消息。 rule-engine.events. Type Optional Value Default enum on, off off 说明 设置是否发布事件消息。可指定事件消息的 QoS，例如: rule-engine.events.client_connected = on, qos1 若启用此选项，规则引擎会将系统消息使用 $events/ 主题发布出来。可支持的 有: client_connected: 客户端登录完成 client_disconnected: 客户端下线 session_subscribed: 客户端订阅 session_unsubscribed: 客户端取消订阅 message_delivered: 消息已投递 message_acked: 消息已确认 message_dropped: 消息被丢弃 如果禁用此选项，事件消息将不会发布，但事件规则仍然可以使用。例如，即使 rule_engine.events.client_connected = off，以下规则仍然可以使用: SELECT * FROM \"$events/client_connected\" emqx-sn mqtt.sn.port Type Default string 1884 说明 emqx_sn 监听的 UDP 端口。 mqtt.sn.advertise_duration Type Default duration 15s 说明 ADVERTISE 消息广播间隔，单位：秒。 mqtt.sn.gateway_id Type Default integer 1 说明 ADVERTISE 中的 MQTT-SN 网关 ID。 mqtt.sn.enable_stats Type Optional Value Default enum on, off off 说明 是否开启客户端状态统计信息。 mqtt.sn.enable_qos3 Type Optional Value Default enum on, off off 说明 是否处理 QoS 为 -1 的消息。 mqtt.sn.idle_timeout Type Default duration 30s 说明 建立后的发呆时间，如果这段时间内未收到任何报文，则会关闭该连接。 mqtt.sn.predefined.topic.0 Type Default string reserved 说明 预定义的 Topic 与 TopicId 映射。Id 为 0 的主题是保留项，固定为 reserved。例如，预定义主题 foo/bar 的 Id 为 1： mqtt.sn.predefined.topic.1 = foo/bar mqtt.sn.username Type Default string mqtt_sn_user 说明 emqx_sn 连接至 EMQ X 的用户名。 mqtt.sn.password Type Default string abc 说明 emqx_sn 连接至 EMQ X 的密码。 emqx-prometheus prometheus.push.gateway.server Type Default string http://127.0.0.1:9091 说明 指定 Prometheus gateway 的 URI。 prometheus.interval Type Default integer 15000 说明 指定 Stats 数据的收集间隔，单位: 毫秒。 prometheus.collector. Type Default string emqx_prometheus 说明 指定 Prometheus 的 Collector。 emqx-stomp stomp.listener Type Default integer 61613 说明 指定 Stomp 插件监听的本地端口。 stomp.listener.acceptors Type Default integer 4 说明 指定 Stomp 服务 Acceptor 线程池的大小。 stomp.listener.max_connections Type Default integer 512 说明 指定 Stomp 服务支持的最大连接数。 stomp.listener.ssl Type Optional Value Default enum on, off off 说明 指定是否使用 SSL。 stomp.listener.keyfile Type Default string etc/certs/key.pem 说明 若使用 SSL，指定 SSL 的私钥文件。 stomp.listener.certfile Type Default string etc/certs/cert.pem 说明 若使用 SSL，指定 SSL 的证书文件。 stomp.listener.cacertfile Type Default string etc/certs/cacert.pem 说明 若使用 SSL，指定 SSL 的 CA 证书文件。 stomp.listener.dhfile Type Default string etc/certs/dh-params.pem 说明 若使用 SSL，指定 Ephemeral Diffie-Helman 算法使用的 key 文件。 stomp.listener.verify Type Optional Value Default enum verify_peer, verify_none verify_peer 说明 若使用 SSL，指定握手过程中是否校验客户端。 stomp.listener.fail_if_no_peer_cert Type Optional Value Default enum true, false false 说明 若使用 SSL，SSL 握手过程中若客户端没有证书，是否让握手失败。 stomp.listener.tls_versions Type Default string tlsv1.2,tlsv1.1,tlsv1 说明 若使用 SSL，指定服务端支持的 SSL 的版本列表。 stomp.listener.handshake_timeout Type Default duration 15s 说明 若使用 SSL，指定 SSL 握手过程的超时时间。 stomp.listener.ciphers Type Default string ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA 说明 若使用 SSL，指定服务端支持的 Cipher 列表。 stomp.listener.secure_renegotiate Type Optional Value Default enum on, off off 说明 若使用 SSL，指定在客户端不遵循 RFC 5746 的情况下，是否拒绝 renegotiation 请求。 stomp.listener.reuse_sessions Type Optional Value Default enum on, off on 说明 若使用 SSL，指定是否支持 SSL session 重用。 stomp.listener.honor_cipher_order Type Optional Value Default enum on, off on 说明 若使用 SSL，指定是否使用服务端的偏好设置选择 Ciphers。 stomp.default_user.login Type Default string guest 说明 指定 Stomp 插件登录使用的 Username。 stomp.default_user.passcode Type Default string guest 说明 指定 Stomp 插件登录使用的 Password。 stomp.allow_anonymous Type Optional Value Default enum true, false true 说明 是否允许匿名登录。 stomp.frame.max_headers Type Default integer 10 说明 指定 Stomp 最大报文头数量。 stomp.frame.max_header_length Type Default integer 1024 说明 指定 Stomp 最大报文头长度。 stomp.frame.max_body_length Type Default integer 8192 说明 指定 Stomp 最大报文体长度。 emqx-web-hook web.hook.api.url Type Default string - 说明 emqx_web_hook 转发的目的 Web 服务器地址。 web.hook.encode_payload Type Optional Value Default enum base62, base64 - 说明 PUBLISH 消息中 Payload 字段的编码格式。 web.hook.rule.client.connect.1 Type Default string {\"action\": \"on_client_connect\"} 说明 转发 收到连接报文 事件。 web.hook.rule.client.connack.1 Type Default string {\"action\": \"on_client_connack\"} 说明 转发 下发连接应答 事件。 web.hook.rule.client.connected.1 Type Default string {\"action\": \"on_client_connected\"} 说明 转发 客户端成功接入 事件。 web.hook.rule.client.disconnected.1 Type Default string {\"action\": \"on_client_disconnected\"} 说明 转发 客户端已断开 事件。 web.hook.rule.client.subscribe.1 Type Default string {\"action\": \"on_client_subscribe\"} 说明 转发 将订阅 事件。 web.hook.rule.client.unsubscribe.1 Type Default string {\"action\": \"on_client_unsubscribe\"} 说明 转发 将取消订阅 事件。 web.hook.rule.session.subscribed.1 Type Default string {\"action\": \"on_session_subscribed\"} 说明 转发 已订阅 事件。 web.hook.rule.session.unsubscribed.1 Type Default string {\"action\": \"on_session_unsubscribed\"} 说明 转发 已取消订阅 事件。 web.hook.rule.session.terminated.1 Type Default string {\"action\": \"on_session_terminated\"} 说明 转发 会话已终止 事件。 web.hook.rule.message.publish.1 Type Default string {\"action\": \"on_message_publish\"} 说明 转发 消息发布 事件。 web.hook.rule.message.delivered.1 Type Default string {\"action\": \"on_message_delivered\"} 说明 转发 消息已投递 事件。 web.hook.rule.message.acked.1 Type Default string {\"action\": \"on_message_acked\"} 说明 转发 消息已应答 事件。 .emqxee { display: none; }"},"advanced/cli.html":{"url":"advanced/cli.html","title":"命令行接口","summary":null,"keywords":"","body":"命令行接口status 命令mgmt 命令mgmt listmgmt insert mgmt update mgmt lookup mgmt delete broker 命令broker statsbroker metricscluster 命令acl 命令clients 命令clients listclients show clients kick routes 命令routes listroutes show subscriptions 命令subscriptions listsubscriptions show subscriptions add subscriptions del plugins 命令plugins listplugins load plugins unload plugins reload modules 命令 modules listmodules loadmodules unloadmodules reloadvm 命令vm allvm loadvm memoryvm processvm iovm portsmnesia 命令log 命令log set-level log primary-levellog primary-level log handlers listlog handlers set-level trace 命令trace start client [ ]trace stop client trace start topic [ ]trace stop topic trace listlistenerslisteners listlisteners stop recon 命令retainer 命令retainer inforetainer topicsretainer cleanretainer clean admins 命令admins add admins passwd admins del 规则引擎(rule engine) 命令rules 命令rule-actions 命令resources 命令resource-types 命令与规则引擎相关的状态、统计指标和告警规则状态和统计指标动作状态和统计指标 资源状态和告警 命令行接口 EMQ X 提供了 ./bin/emqx_ctl 的管理命令行，用于用户对 EMQ X 进行管理、配置、查询。 status 命令 查询 EMQ X 运行状态: $ ./bin/emqx_ctl status Node 'emqx@127.0.0.1' is started emqx v4.0.0 is running mgmt 命令 mgmt 命令查询应用程序。 命令 描述 mgmt list 列出应用程序列表 mgmt insert 添加允许访问 HTTP API 的应用程序 mgmt update 更新允许访问 HTTP API 的应用程序 mgmt lookup 获取允许访问 HTTP API 的应用程序详情 mgmt delete 删除允许访问 HTTP API 的应用程序 mgmt list 列出应用程序列表: $ ./bin/emqx_ctl mgmt list app_id: 901abdba8eb8c, secret: MjgzMzQ5MjM1MzUzMTc4MjgyMjE3NzU4ODcwMDg0NjQ4OTG, name: hello, desc: , status: true, expired: undefined mgmt insert 添加 HTTP API 的应用程序: $ ./bin/emqx_ctl mgmt insert dbcb6e023370b world AppSecret: MjgzMzQ5MjYyMTY3ODk4MjA5NzMwODExODMxMDM1NDk0NDA mgmt update 更新 HTTP API 的应用程序: $ ./bin/emqx_ctl mgmt update dbcb6e023370b stop update successfully. mgmt lookup 获取 HTTP API 的应用程序详情: $ ./bin/emqx_ctl mgmt lookup dbcb6e023370b app_id: dbcb6e023370b secret: MjgzMzQ5MjYyMTY3ODk4MjA5NzMwODExODMxMDM1NDk0NDA name: world desc: Application user status: stop expired: undefined mgmt delete 删除 HTTP API 的应用程序: $ ./bin/emqx_ctl mgmt delete dbcb6e023370b ok broker 命令 broker 命令查询服务器基本信息，启动时间，统计数据与性能数据。 命令 描述 broker 查询 EMQ X 描述、版本、启动时间 broker stats 查询连接 (Connection)、会话 (Session)、主题 (Topic)、订阅 (Subscription)、路由 (Route) 统计信息 broker metrics 查询 MQTT 报文 (Packet)、消息 (Message) 收发统计 查询 EMQ X 基本信息，包括版本、启动时间等: $ ./bin/emqx_ctl broker sysdescr : EMQ X Broker version : 4.0.0 uptime : 4 minutes, 52 seconds datetime : 2020-02-21 09:39:58 broker stats 查询服务器客户端连接 (Connections)、主题 (Topics)、订阅 (Subscriptions)、路由 (Routes) 统计: $ ./bin/emqx_ctl broker stats actions.count : 5 actions.max : 5 channels.count : 0 channels.max : 0 connections.count : 0 connections.max : 0 resources.count : 0 resources.max : 0 retained.count : 3 retained.max : 3 routes.count : 0 routes.max : 0 rules.count : 0 rules.max : 0 sessions.count : 0 sessions.max : 0 suboptions.count : 0 suboptions.max : 0 subscribers.count : 0 subscribers.max : 0 subscriptions.count : 0 subscriptions.max : 0 subscriptions.shared.count : 0 subscriptions.shared.max : 0 topics.count : 0 topics.max : 0 broker metrics 查询服务器流量 (Bytes)、MQTT 报文 (Packets)、消息 (Messages) 收发统计: $ ./bin/emqx_ctl broker metrics actions.success : 0 bytes.received : 0 bytes.sent : 0 client.auth.anonymous : 0 client.authenticate : 0 client.check_acl : 0 client.connack : 0 client.connect : 0 client.connected : 0 client.disconnected : 0 client.subscribe : 0 client.unsubscribe : 0 delivery.dropped : 0 delivery.dropped.expired : 0 delivery.dropped.no_local : 0 delivery.dropped.qos0_msg : 0 delivery.dropped.queue_full : 0 delivery.dropped.too_large : 0 messages.acked : 0 messages.delayed : 0 messages.delivered : 0 messages.dropped : 0 messages.dropped.expired : 0 messages.dropped.no_subscriber: 0 messages.forward : 0 messages.publish : 0 messages.qos0.received : 0 messages.qos0.sent : 0 messages.qos1.received : 0 messages.qos1.sent : 0 messages.qos2.received : 0 messages.qos2.sent : 0 messages.received : 0 messages.retained : 3 messages.sent : 0 packets.auth.received : 0 packets.auth.sent : 0 packets.connack.auth_error : 0 packets.connack.error : 0 packets.connack.sent : 0 packets.connect.received : 0 packets.disconnect.received : 0 packets.disconnect.sent : 0 packets.pingreq.received : 0 packets.pingresp.sent : 0 packets.puback.inuse : 0 packets.puback.missed : 0 packets.puback.received : 0 packets.puback.sent : 0 packets.pubcomp.inuse : 0 packets.pubcomp.missed : 0 packets.pubcomp.received : 0 packets.pubcomp.sent : 0 packets.publish.auth_error : 0 packets.publish.dropped : 0 packets.publish.error : 0 packets.publish.received : 0 packets.publish.sent : 0 packets.pubrec.inuse : 0 packets.pubrec.missed : 0 packets.pubrec.received : 0 packets.pubrec.sent : 0 packets.pubrel.missed : 0 packets.pubrel.received : 0 packets.pubrel.sent : 0 packets.received : 0 packets.sent : 0 packets.suback.sent : 0 packets.subscribe.auth_error : 0 packets.subscribe.error : 0 packets.subscribe.received : 0 packets.unsuback.sent : 0 packets.unsubscribe.error : 0 packets.unsubscribe.received : 0 rules.matched : 0 session.created : 0 session.discarded : 0 session.resumed : 0 session.takeovered : 0 session.terminated : 0 cluster 命令 cluster 命令可以管理由多个 EMQ X 节点（进程）组成的集群: 命令 描述 cluster join 加入集群 cluster leave 离开集群 cluster force-leave 从集群删除节点 cluster status 查询集群状态 示例: 为更好地展示 cluster 命令，我们先在本机启动两个节点并组成集群，为避免端口冲突，我们对 emqx2 节点的监听端口做出了调整，例如 MQTT/TCP 监听端口由默认的 1883 改为了 2883，详情请参见 配置说明 与 配置项。 启动 emqx1 : $ cd emqx1 && ./bin/emqx start 启动 emqx2 : $ cd emqx2 && ./bin/emqx start 使用 cluster join 将两个节点组成集群： $ cd emqx2 && ./bin/emqx_ctl cluster join emqx1@127.0.0.1 Join the cluster successfully. Cluster status: [{running_nodes,['emqx1@127.0.0.1','emqx2@127.0.0.1']}] 任意节点目录下查询集群状态: $ ./bin/emqx_ctl cluster status Cluster status: [{running_nodes,['emqx2@127.0.0.1','emqx1@127.0.0.1']}] 集群消息路由测试: MQTT 命令行工具使用由 EMQ X 团队开发的 emqtt 客户端。 # emqx1 节点（1883 端口）订阅主题 x $ ./bin/emqtt sub -t x -q 1 -p 1883 Client emqtt-a7de8fffbe2fbeb2fadb sent CONNECT Client emqtt-a7de8fffbe2fbeb2fadb subscribed to x # 向 emqx2 节点（2883 端口 ）发布消息 $ ./bin/emqtt pub -t x -q 1 -p 2883 --payload hello Client emqtt-0898fa447676e17479a5 sent CONNECT Client emqtt-0898fa447676e17479a5 sent PUBLISH (Q1, R0, D0, Topic=x, Payload=...(5 bytes)) Client emqtt-0898fa447676e17479a5 sent DISCONNECT # emqx1 节点（1883 端口）收到消息 $ ./bin/emqtt sub -t x -q 1 -p 1883 hello emqx2 节点离开集群: $ cd emqx2 && ./bin/emqx_ctl cluster leave 强制 emqx2 节点离开集群，需要在集群下的目标节点以外的节点上进行操作: $ cd emqx1 && ./bin/emqx_ctl cluster force-leave emqx2@127.0.0.1 注意，EMQ X 不支持一个已经在一个集群中的节点加入另外一个集群，因为这会导致两个集群数据不一致，但支持加入过集群的节点在离开该集群后加入另一个集群。 acl 命令 重新加载 acl 规则: $ ./bin/emqx_ctl acl reload ok clients 命令 clients 命令查询连接的 MQTT 客户端。 命令 描述 clients list 列出所有客户端连接 clients show 查询指定 ClientId 的客户端 clients kick 踢除指定 ClientId 的客户端，连接与会话将一并终结。 clients list 列出所有客户端连接: $ ./bin/emqx_ctl clients list Client (mosqsub/43832-airlee.lo, username=test1, peername=127.0.0.1:62135, clean_start=true, keepalive=60, session_expiry_interval=0, subscriptions=0, inflight=0, awaiting_rel=0, delivered_msgs=0, enqueued_msgs=0, dropped_msgs=0, connected=true, created_at=1582249657, connected_at=1582249657) Client (mosqsub/44011-airlee.lo, username=test2, peername=127.0.0.1:64961, clean_start=true, keepalive=60, session_expiry_interval=0, subscriptions=0, inflight=0, awaiting_rel=0, delivered_msgs=0, enqueued_msgs=0, dropped_msgs=0, connected=true, created_at=1582249657, connected_at=1582249657, disconnected_at=1582249702) ... 返回 Client 对象的属性: Name 描述 username 用户名 peername 客户端 IP 与端口 clean_start MQTT Clean Start keepalive MQTT KeepAlive session_expiry_interval 会话过期间隔 subscriptions 当前订阅数量 inflight 当前正在下发的 QoS 1 和 QoS 2 的消息总数 awaiting_rel 等待客户端发送 PUBREL 的 QoS2 消息数 delivered_msgs EMQ X 向此客户端转发的消息数量 (包含重传) enqueued_msgs 消息队列当前长度 dropped_msgs 消息队列达到最大长度后丢弃的消息数量 connected 是否在线 created_at 会话创建时间戳 connected_at 客户端连接时间戳 disconnected_at 客户端断开连接时间戳（仅当断开连接还保留会话时才会出现） clients show 查询指定 ClientId 的客户端: $ ./bin/emqx_ctl clients show \"mosqsub/43832-airlee.lo\" Client (mosqsub/43832-airlee.lo, username=test1, peername=127.0.0.1:62747, clean_start=false, keepalive=60, session_expiry_interval=7200, subscriptions=0, inflight=0, awaiting_rel=0, delivered_msgs=0, enqueued_msgs=0, dropped_msgs=0, connected=true, created_at=1576479557, connected_at=1576479557) clients kick 踢除指定 ClientId 的客户端: $ ./bin/emqx_ctl clients kick \"clientid\" ok routes 命令 routes 命令用于查询路由信息。 EMQ X 中路由是指主题与节点的映射关系，用于在多个节点之间路由消息。 命令 描述 routes list 列出所有路由 routes show 查询指定 Topic 的路由 routes list 列出所有路由: $ ./bin/emqx_ctl routes list t2/# -> emqx2@127.0.0.1 t/+/x -> emqx2@127.0.0.1,emqx@127.0.0.1 routes show 查询指定 Topic d的路由: $ ./bin/emqx_ctl routes show t/+/x t/+/x -> emqx2@127.0.0.1,emqx@127.0.0.1 subscriptions 命令 subscriptions 命令查询消息服务器的订阅 (Subscription) 表。 命令 描述 subscriptions list 列出所有订阅 subscriptions show 查询指定 ClientId 客户端的订阅 subscriptions add 手动添加静态订阅 subscriptions del 手动删除静态订阅 subscriptions list 列出所有订阅: $ ./bin/emqx_ctl subscriptions list mosqsub/91042-airlee.lo -> t/y:1 mosqsub/90475-airlee.lo -> t/+/x:2 subscriptions show 查询某个 Client 的订阅: $ ./bin/emqx_ctl subscriptions show 'mosqsub/90475-airlee.lo' mosqsub/90475-airlee.lo -> t/+/x:2 subscriptions add 手动添加订阅关系: $ ./bin/emqx_ctl subscriptions add 'mosqsub/90475-airlee.lo' '/world' 1 ok subscriptions del 手动删除订阅关系: $ ./bin/emqx_ctl subscriptions del 'mosqsub/90475-airlee.lo' '/world' ok plugins 命令 plugins 命令用于加载、卸载、查询插件应用。EMQ X 通过插件扩展认证、定制功能，插件配置位于 etc/plugins/ 目录下。 命令 描述 plugins list 列出全部插件 (Plugin) plugins load 加载插件 (Plugin) plugins unload 卸载插件 (Plugin) plugins reload 重载插件 (Plugin) 当配置文件发生更改，如果需要配置立即生效，你可以执行 emqx_ctl reload 命令，即使插件在配置修改时并未处于运行状态，你也应当使用此命令而不是emqx_ctl load ，因为 `emqx_ctl load 不会编译新的配置文件。 plugins list 列出全部插件: $ ./bin/emqx_ctl plugins list Plugin (emqx_auth_clientid, version=v4.0.0, description=EMQ X Authentication with ClientId/Password, active=false) Plugin (emqx_auth_http, version=v4.0.0, description=EMQ X Authentication/ACL with HTTP API, active=false) Plugin (emqx_auth_jwt, version=v4.0.0, description=EMQ X Authentication with JWT, active=false) Plugin (emqx_auth_ldap, version=v4.0.0, description=EMQ X Authentication/ACL with LDAP, active=false) Plugin (emqx_auth_mongo, version=v4.0.0, description=EMQ X Authentication/ACL with MongoDB, active=false) Plugin (emqx_auth_mysql, version=v4.0.0, description=EMQ X Authentication/ACL with MySQL, active=false) Plugin (emqx_auth_pgsql, version=v4.0.0, description=EMQ X Authentication/ACL with PostgreSQL, active=false) Plugin (emqx_auth_redis, version=v4.0.0, description=EMQ X Authentication/ACL with Redis, active=false) Plugin (emqx_auth_username, version=v4.0.0, description=EMQ X Authentication with Username and Password, active=false) Plugin (emqx_bridge_mqtt, version=v4.0.0, description=EMQ X Bridge to MQTT Broker, active=false) Plugin (emqx_coap, version=v4.0.0, description=EMQ X CoAP Gateway, active=false) Plugin (emqx_dashboard, version=v4.0.0, description=EMQ X Web Dashboard, active=true) Plugin (emqx_delayed_publish, version=v4.0.0, description=EMQ X Delayed Publish, active=false) Plugin (emqx_lua_hook, version=v4.0.0, description=EMQ X Lua Hooks, active=false) Plugin (emqx_lwm2m, version=v4.0.0, description=EMQ X LwM2M Gateway, active=false) Plugin (emqx_management, version=v4.0.0, description=EMQ X Management API and CLI, active=true) Plugin (emqx_plugin_template, version=v4.0.0, description=EMQ X Plugin Template, active=false) Plugin (emqx_psk_file, version=v4.0.0, description=EMQX PSK Plugin from File, active=false) Plugin (emqx_recon, version=v4.0.0, description=EMQ X Recon Plugin, active=true) Plugin (emqx_reloader, version=v4.0.0, description=EMQ X Reloader Plugin, active=false) Plugin (emqx_retainer, version=v4.0.0, description=EMQ X Retainer, active=true) Plugin (emqx_rule_engine, version=v4.0.0, description=EMQ X Rule Engine, active=true) Plugin (emqx_sn, version=v4.0.0, description=EMQ X MQTT SN Plugin, active=false) Plugin (emqx_statsd, version=v4.0.0, description=Statsd for EMQ X, active=false) Plugin (emqx_stomp, version=v4.0.0, description=EMQ X Stomp Protocol Plugin, active=false) Plugin (emqx_web_hook, version=v4.0.0, description=EMQ X Webhook Plugin, active=false) 插件属性: Name 描述 version 插件版本 description 插件描述 active 是否已加载 plugins load 加载插件: $ ./bin/emqx_ctl plugins load emqx_lua_hook Plugin emqx_lua_hook loaded successfully. plugins unload 卸载插件: $ ./bin/emqx_ctl plugins unload emqx_lua_hook Plugin emqx_lua_hook unloaded successfully. plugins reload 重载插件: $ ./bin/emqx_ctl plugins reload emqx_lua_hook Plugin emqx_lua_hook reloaded successfully. modules 命令 modules 命令用于加载、卸载和查询内置模块。 命令 描述 modules list 列出全部内置模块 (Module) modules load 加载内置模块 (Module) modules unload 卸载内置模块 (Module) modules reload 重载内置模块 (Module) modules list 列出全部内置模块: $ ./bin/emqx_ctl modules list Module(emqx_mod_delayed, description=EMQ X Delayed Publish Module, active=false) Module(emqx_mod_topic_metrics, description=EMQ X Topic Metrics Module, active=false) Module(emqx_mod_subscription, description=EMQ X Subscription Module, active=false) Module(emqx_mod_acl_internal, description=EMQ X Internal ACL Module, active=true) Module(emqx_mod_rewrite, description=EMQ X Topic Rewrite Module, active=false) Module(emqx_mod_presence, description=EMQ X Presence Module, active=true) modules load 加载内置模块: $ ./bin/emqx_ctl modules load emqx_mod_delayed Module emqx_mod_delayed loaded successfully. modules unload 卸载内置模块: $ ./bin/emqx_ctl modules unload emqx_mod_delayed Module emqx_mod_delayed unloaded successfully. modules reload 重载内置模块: $ ./bin/emqx_ctl modules reload emqx_mod_acl_internal Module emqx_mod_acl_internal reloaded successfully. vm 命令 vm 命令用于查询 Erlang 虚拟机负载、内存、进程、IO 信息。 命令 描述 vm 等同于 vm all vm all 查询 VM 全部信息 vm load 查询 VM 负载 vm memory 查询 VM 内存 vm process 查询 VM Erlang 进程数量 vm io 查询 VM io 最大文件句柄 vm ports 查询 VM 的端口 vm all 查询 VM 全部信息，包括负载、内存、Erlang 进程数量等: $ ./bin/emqx_ctl vm all cpu/load1 : 4.22 cpu/load5 : 3.29 cpu/load15 : 3.16 memory/total : 99995208 memory/processes : 38998248 memory/processes_used : 38938520 memory/system : 60996960 memory/atom : 1189073 memory/atom_used : 1173808 memory/binary : 100336 memory/code : 25439961 memory/ets : 7161128 process/limit : 2097152 process/count : 315 io/max_fds : 10240 io/active_fds : 0 ports/count : 18 ports/limit : 1048576 vm load 查询 VM 负载: $ ./bin/emqx_ctl vm load cpu/load1 : 2.21 cpu/load5 : 2.60 cpu/load15 : 2.36 vm memory 查询 VM 内存: $ ./bin/emqx_ctl vm memory memory/total : 23967736 memory/processes : 3594216 memory/processes_used : 3593112 memory/system : 20373520 memory/atom : 512601 memory/atom_used : 491955 memory/binary : 51432 memory/code : 13401565 memory/ets : 1082848 vm process 查询 Erlang 进程数量及其限制: $ ./bin/emqx_ctl vm process process/limit : 2097152 process/count : 314 vm io 查询文件描述符数量及其限制: $ ./bin/emqx_ctl vm io io/max_fds : 10240 io/active_fds : 0 vm ports 查询端口占用数量及其限制: $ ./bin/emqx_ctl vm ports ports/count : 18 ports/limit : 1048576 mnesia 命令 查询 mnesia 数据库系统状态。 log 命令 log 命令用于设置日志等级。访问 Documentation of logger 以获取详细信息 命令 描述 log set-level 设置主日志等级和所有 Handlers 日志等级 log primary-level 查看主日志等级 log primary-lelvel 设置主日志等级 log handlers list 查看当前安装的所有 Hanlders log handlers set-level 设置指定 Hanlder 的日志等级 日志的等级由低到高分别为：debug | info | notice | warning | error | critical | alert | emergency，日志等级越低，系统输出的日志数量越多，消耗的系统资源越大。为提高系统运行性能，默认的主日志等级是 error。 log set-level 设置主日志等级和所有 Handlers 日志等级: $ ./bin/emqx_ctl log set-level debug debug log primary-level 查看主日志等级: $ ./bin/emqx_ctl log primary-level debug log primary-level 设置主日志等级: $ ./bin/emqx_ctl log primary-level info info log handlers list 查看当前安装的所有 Hanlders: $ ./bin/emqx_ctl log handlers list LogHandler (id=emqx_logger_handler, level=debug, destination=unknown) LogHandler (id=file, level=debug, destination=log/emqx.log) LogHandler (id=default, level=debug, destination=console) log handlers set-level 设置指定 Hanlder 的日志等级: $ ./bin/emqx_ctl log handlers set-level emqx_logger_handler error error trace 命令 trace 命令用于追踪某个 Client 或 Topic，打印日志信息到文件，详情请查看 日志与追踪。 命令 描述 trace list 列出所有开启的追踪 trace start client [] 开启 Client 追踪，存储指定等级的日志到文件 trace stop client 关闭 Client 追踪 trace start topic [] 开启 Topic 追踪，存储指定等级的日志到文件 trace stop topic 关闭 Topic 追踪 trace start client [ ] 开启 Client 追踪: $ ./bin/emqx_ctl log primary-level debug debug $ ./bin/emqx_ctl trace start client clientid log/clientid_trace.log trace clientid clientid successfully $ ./bin/emqx_ctl trace start client clientid2 log/clientid2_trace.log error trace clientid clientid2 successfully trace stop client 关闭 Client 追踪: $ ./bin/emqx_ctl trace stop client clientid stop tracing clientid clientid successfully trace start topic [ ] 开启 Topic 追踪: $ ./bin/emqx_ctl log primary-level debug debug $ ./bin/emqx_ctl trace start topic topic log/topic_trace.log trace topic topic successfully $ ./bin/emqx_ctl trace start topic topic2 log/topic2_trace.log error trace topic topic2 successfully trace stop topic 关闭 Topic 追踪: $ ./bin/emqx_ctl trace topic topic off stop tracing topic topic successfully trace list 列出所有开启的追踪: $ ./bin/emqx_ctl trace list Trace (clientid=clientid2, level=error, destination=\"log/clientid2_trace.log\") Trace (topic=topic2, level=error, destination=\"log/topic2_trace.log\") listeners listeners 命令用于查询开启的 TCP 服务监听器。 命令 描述 listeners 查询开启的 TCP 服务监听器 listeners stop 停止监听端口，支持 mqtt:ssl，mqtt:tcp，http:dashboard，http:management，mqtt:ws，mqtt:wss 协议 listeners list 查询开启的 TCP 服务监听器: $ ./bin/emqx_ctl listeners listener on mqtt:ssl:8883 acceptors : 16 max_conns : 102400 current_conn : 0 shutdown_count : [] listener on mqtt:tcp:0.0.0.0:1883 acceptors : 8 max_conns : 1024000 current_conn : 0 shutdown_count : [] listener on mqtt:tcp:127.0.0.1:11883 acceptors : 4 max_conns : 1024000 current_conn : 2 shutdown_count : [] listener on http:dashboard:18083 acceptors : 2 max_conns : 512 current_conn : 0 shutdown_count : [] listener on http:management:8081 acceptors : 2 max_conns : 512 current_conn : 0 shutdown_count : [] listener on mqtt:ws:8083 acceptors : 2 max_conns : 102400 current_conn : 0 shutdown_count : [] listener on mqtt:wss:8084 acceptors : 2 max_conns : 16 current_conn : 0 shutdown_count : [] listener 参数说明: Name 描述 acceptors TCP Acceptor 池 max_conns 最大允许连接数 current_conns 当前连接数 shutdown_count 连接关闭原因统计 listeners stop 停止监听端口: $ ./bin/emqx_ctl listeners stop mqtt:tcp 0.0.0.0:1883 Stop mqtt:tcp listener on 0.0.0.0:1883 successfully. recon 命令 EMQ X 的 recon 命令基于 Erlang Recon 库实现，用于帮助 DevOps 人员诊断生产节点中的问题，普通用户无需关心。使用 recon 命令会耗费一定的性能，请谨慎使用。 命令 描述 recon memory recon_alloc:memory/2 recon allocated recon_alloc:memory (allocated_types, current/max) recon bin_leak recon:bin_leak (100) recon node_stats recon:node_stats_print(10, 1000) recon remote_load Mod recon:remote_load (Mod) recon proc_count Attr N recon:proc_count(Attr, N) 访问 Documentation for recon 以获取详细信息。 retainer 命令 命令 描述 retainer info 显示保留消息的数量 retainer topics 显示当前存储的保留消息的所有主题 retainer clean 清除所有保留的消息 retainer clean 清除指定的主题下的保留的消息 retainer info 显示保留消息的数量: $ ./bin/emqx_ctl retainer info retained/total: 3 retainer topics 显示当前存储的保留消息的所有主题: $ ./bin/emqx_ctl retainer topics $SYS/brokers/emqx@127.0.0.1/version $SYS/brokers/emqx@127.0.0.1/sysdescr $SYS/brokers retainer clean 清除所有保留的消息: $ ./bin/emqx_ctl retainer clean Cleaned 3 retained messages retainer clean 清除指定的主题下的保留的消息: $ ./bin/emqx_ctl retainer clean topic Cleaned 1 retained messages admins 命令 用于创建、删除管理员账号，重置管理员密码。 命令 描述 admins add 创建 admin 账号 admins passwd 重置 admin 密码 admins del 删除 admin 账号 admins add 创建 admin 账户: $ ./bin/emqx_ctl admins add root public test ok admins passwd 重置 admin 账户密码: $ ./bin/emqx_ctl admins passwd root private ok admins del 删除 admin 账户: $ ./bin/emqx_ctl admins del root ok 规则引擎(rule engine) 命令 rules 命令 命令 描述 rules list List all rules rules show Show a rule rules create [-d []] Create a rule rules delete Delete a rule rules create 创建一个新的规则。参数: : 规则 SQL : JSON 格式的动作列表 -d : 可选，规则描述信息 使用举例: ## 创建一个测试规则，简单打印所有发送到 't/a' 主题的消息内容 $ ./bin/emqx_ctl rules create \\ 'select * from \"t/a\"' \\ '[{\"name\":\"inspect\", \"params\": {\"a\": 1}}]' \\ -d 'Rule for debug' Rule rule:9a6a725d created 上例创建了一个 ID 为 rule:9a6a725d 的规则，动作列表里只有一个动作：动作名为 inspect，动作的参数是 {\"a\": 1}。 rules list 列出当前所有的规则: $ ./bin/emqx_ctl rules list rule(id='rule:9a6a725d', for='['t/a']', rawsql='select * from \"t/a\"', actions=[{\"metrics\":...,\"name\":\"inspect\",\"params\":...}], metrics=..., enabled='true', description='Rule for debug') rules show 查询规则: ## 查询 RuleID 为 'rule:9a6a725d' 的规则 $ ./bin/emqx_ctl rules show 'rule:9a6a725d' rule(id='rule:9a6a725d', for='['t/a']', rawsql='select * from \"t/a\"', actions=[{\"metrics\":...,\"name\":\"inspect\",\"params\":...}], metrics=..., enabled='true', description='Rule for debug') rules delete 删除规则: ## 删除 RuleID 为 'rule:9a6a725d' 的规则 $ ./bin/emqx_ctl rules delete 'rule:9a6a725d' ok rule-actions 命令 命令 描述 rule-actions list List actions rule-actions show Show a rule action 动作可以由 EMQ X 内置(称为系统内置动作)，或者由 EMQ X 插件编写，但不能通过 CLI/API 添加或删除。 rule-actions show 查询动作: ## 查询名为 'inspect' 的动作 $ ./bin/emqx_ctl rule-actions show 'inspect' action(name='inspect', app='emqx_rule_engine', types=[], title ='Inspect (debug)', description='Inspect the details of action params for debug purpose') rule-actions list 列出符合条件的动作: ## 列出当前所有的动作 $ ./bin/emqx_ctl rule-actions list action(name='data_to_rabbit', app='emqx_bridge_rabbit', types=[bridge_rabbit], title ='Data bridge to RabbitMQ', description='Store Data to Kafka') action(name='data_to_timescaledb', app='emqx_backend_pgsql', types=[timescaledb], title ='Data to TimescaleDB', description='Store data to TimescaleDB') ... resources 命令 命令 描述 resources create [-c []] [-d []] Create a resource resources list [-t ] List resources resources show Show a resource resources delete Delete a resource resources create 创建一个新的资源，参数: type: 资源类型 -c config: JSON 格式的配置 -d descr: 可选，资源的描述 $ ./bin/emqx_ctl resources create 'web_hook' -c '{\"url\": \"http://host-name/chats\"}' -d 'forward msgs to host-name/chats' Resource resource:a7a38187 created resources list 列出当前所有的资源: $ ./bin/emqx_ctl resources list resource(id='resource:a7a38187', type='web_hook', config=#{> => >}, status=#{is_alive => false}, description='forward msgs to host-name/chats') 列出当前某个类型的资源: $ ./bin/emqx_ctl resources list --type='web_hook' resource(id='resource:a7a38187', type='web_hook', config=#{> => >}, status=#{is_alive => false}, description='forward msgs to host-name/chats') resources show 查询资源: $ ./bin/emqx_ctl resources show 'resource:a7a38187' resource(id='resource:a7a38187', type='web_hook', config=#{> => >}, status=#{is_alive => false}, description='forward msgs to host-name/chats') resources delete 删除资源: $ ./bin/emqx_ctl resources delete 'resource:a7a38187' ok resource-types 命令 命令 描述 resource-types list List all resource-types resource-types show Show a resource-type 资源类型可以由 EMQ X 内置(称为系统内置资源类型)，或者由 EMQ X 插件编写，但不能通过 CLI/API 添加或删除。 resource-types list 列出当前所有的资源类型: ./bin/emqx_ctl resource-types list resource_type(name='backend_mongo_rs', provider='emqx_backend_mongo', title ='MongoDB Replica Set Mode', description='MongoDB Replica Set Mode') resource_type(name='backend_cassa', provider='emqx_backend_cassa', title ='Cassandra', description='Cassandra Database') ... resource-types show 查询资源类型: $ ./bin/emqx_ctl resource-types show backend_mysql resource_type(name='backend_mysql', provider='emqx_backend_mysql', title ='MySQL', description='MySQL Database') 与规则引擎相关的状态、统计指标和告警 规则状态和统计指标 已命中: 规则命中(规则 SQL 匹配成功)的次数， 命中速度: 规则命中的速度(次/秒) 最大命中速度: 规则命中速度的峰值(次/秒) 5分钟平均速度: 5分钟内规则的平均命中速度(次/秒) 动作状态和统计指标 成功: 动作执行成功次数 失败: 动作执行失败次数 资源状态和告警 可用: 资源可用 不可用: 资源不可用(比如数据库连接断开) .emqxee { display: none; }"},"development/protocol.html":{"url":"development/protocol.html","title":"MQTT 协议","summary":null,"keywords":"","body":"协议介绍MQTT协议概览特点应用MQTT基于主题(Topic)消息路由MQTT V3.1.1协议报文MQTT消息QoSMQTT会话(Clean Session)MQTT连接保活心跳MQTT遗愿消息(Last Will)MQTT保留消息(Retained Message)MQTT WebSocket连接MQTT 与 XMPP 协议对比MQTT-SN 协议MQTT-SN 和 MQTT 的区别EMQX-SN 网关插件MQTT-SN 客户端库LWM2M 协议EMQX-LWM2M 插件MQTT 和 LwM2M的转换LwM2M 的客户端库私有 TCP 协议配置说明配置监听的端口配置监听池大小。影响 TCP 建链的并发速率。最大连接数每秒支持的最大并发连接数协议介绍 MQTT协议 概览 MQTT是一个轻量的发布订阅模式消息传输协议，专门针对低带宽和不稳定网络环境的物联网应用设计。 MQTT官网: http://mqtt.org MQTT V3.1.1协议规范: http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html 特点 开放消息协议，简单易实现 发布订阅模式，一对多消息发布 基于TCP/IP网络连接 1字节固定报头，2字节心跳报文，报文结构紧凑 消息QoS支持，可靠传输保证 应用 MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域。 物联网M2M通信，物联网大数据采集 Android消息推送，WEB消息推送 移动即时消息，例如Facebook Messenger 智能硬件、智能家具、智能电器 车联网通信，电动车站桩采集 智慧城市、远程医疗、远程教育 电力、石油与能源等行业市场 MQTT基于主题(Topic)消息路由 MQTT协议基于主题(Topic)进行消息路由，主题(Topic)类似URL路径，例如: chat/room/1 sensor/10/temperature sensor/+/temperature $SYS/broker/metrics/packets/received $SYS/broker/metrics/# 主题(Topic)通过'/'分割层级，支持'+', '#'通配符: '+': 表示通配一个层级，例如a/+，匹配a/x, a/y '#': 表示通配多个层级，例如a/#，匹配a/x, a/b/c/d 订阅者与发布者之间通过主题路由消息进行通信，例如采用mosquitto命令行发布订阅消息: mosquitto_sub -t a/b/+ -q 1 mosquitto_pub -t a/b/c -m hello -q 1 订阅者可以订阅含通配符主题，但发布者不允许向含通配符主题发布消息。 MQTT V3.1.1协议报文 报文结构 固定报头(Fixed header) 可变报头(Variable header) 报文有效载荷(Payload) 固定报头 Bit 7 6 5 4 3 2 1 0 byte1 MQT T Pack et typ e Fla gs byte2... Rem aining Lengt h 报文类型 类型名称 类型值 报文说明 CONNECT 1 发起连接 CONNACK 2 连接回执 PUBLISH 3 发布消息 PUBACK 4 发布回执 PUBREC 5 QoS2消息回执 PUBREL 6 QoS2消息释放 PUBCOMP 7 QoS2消息完成 SUBSCRIBE 8 订阅主题 SUBACK 9 订阅回执 UNSUBSCRIBE 10 取消订阅 UNSUBACK 11 取消订阅回执 PINGREQ 12 PING请求 PINGRESP 13 PING响应 DISCONNECT 14 断开连接 PUBLISH发布消息 PUBLISH报文承载客户端与服务器间双向的发布消息。 PUBACK报文用于接收端确认QoS1报文，PUBREC/PUBREL/PUBCOMP报文用于QoS2消息流程。 PINGREQ/PINGRESP心跳 客户端在无报文发送时，按保活周期(KeepAlive)定时向服务端发送PINGREQ心跳报文，服务端响应PINGRESP报文。PINGREQ/PINGRESP报文均2个字节。 MQTT消息QoS MQTT发布消息QoS保证不是端到端的，是客户端与服务器之间的。订阅者收到MQTT消息的QoS级别，最终取决于发布消息的QoS和主题订阅的QoS。 发布消息的QoS 主题订阅的QoS 接收消息的QoS 0 0 0 0 1 0 0 2 0 1 0 0 1 1 1 1 2 1 2 0 0 2 1 1 2 2 2 Qos0消息发布订阅 Qos1消息发布订阅 Qos2消息发布订阅 MQTT会话(Clean Session) MQTT客户端向服务器发起CONNECT请求时，可以通过'Clean Session'标志设置会话。 'Clean Session'设置为0，表示创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销。 'Clean Session'设置为1，表示创建一个新的临时会话，在客户端断开时，会话自动销毁。 MQTT连接保活心跳 MQTT客户端向服务器发起CONNECT请求时，通过KeepAlive参数设置保活周期。 客户端在无报文发送时，按KeepAlive周期定时发送2字节的PINGREQ心跳报文，服务端收到PINGREQ报文后，回复2字节的PINGRESP报文。 服务端在1.5个心跳周期内，既没有收到客户端发布订阅报文，也没有收到PINGREQ心跳报文时，主动心跳超时断开客户端TCP连接。 emqx 消息服务器默认按最长 2.5 心跳周期超时设计。 MQTT遗愿消息(Last Will) MQTT客户端向服务器端CONNECT请求时，可以设置是否发送遗愿消息(Will Message)标志，和遗愿消息主题(Topic)与内容(Payload)。 MQTT客户端异常下线时(客户端断开前未向服务器发送DISCONNECT消息)，MQTT消息服务器会发布遗愿消息。 MQTT保留消息(Retained Message) MQTT客户端向服务器发布(PUBLISH)消息时，可以设置保留消息(Retained Message)标志。保留消息(Retained Message)会驻留在消息服务器，后来的订阅者订阅主题时仍可以接收该消息。 例如mosquitto命令行发布一条保留消息到主题'a/b/c': mosquitto_pub -r -q 1 -t a/b/c -m 'hello' 之后连接上来的MQTT客户端订阅主题'a/b/c'时候，仍可收到该消息: $ mosquitto_sub -t a/b/c -q 1 hello 保留消息(Retained Message)有两种清除方式: 客户端向有保留消息的主题发布一个空消息: mosquitto_pub -r -q 1 -t a/b/c -m '' 消息服务器设置保留消息的超期时间。 MQTT WebSocket连接 MQTT协议除支持TCP传输层外，还支持WebSocket作为传输层。通过WebSocket浏览器可以直连MQTT消息服务器，发布订阅模式与其他MQTT客户端通信。 MQTT协议的WebSocket连接，必须采用binary模式，并携带子协议Header: Sec-WebSocket-Protocol: mqttv3.1 或 mqttv3.1.1 MQTT 与 XMPP 协议对比 MQTT协议设计简单轻量、路由灵活，将在移动互联网物联网消息领域，全面取代PC时代的XMPP协议: MQTT协议一个字节固定报头，两个字节心跳报文，报文体积小编解码容易。XMPP协议基于繁重的XML，报文体积大且交互繁琐。 MQTT协议基于主题(Topic)发布订阅模式消息路由，相比XMPP基于JID的点对点消息路由更为灵活。 MQTT协议未定义报文内容格式，可以承载JSON、二进制等不同类型报文。XMPP协议采用XML承载报文，二进制必须Base64编码等处理。 MQTT协议支持消息收发确认和QoS保证，XMPP主协议并未定义类似机制。MQTT协议有更好的消息可靠性保证。 MQTT-SN 协议 MQTT-SN 协议是 MQTT 的直系亲属，它使用 UDP 进行通信，标准的端口是1884。MQTT-SN 的主要目的是为了适应受限的设备和网络，比如一些传感器，只有很小的内存和 CPU，TCP 对于这些设备来说非常奢侈。还有一些网络，比如 ZIGBEE，报文的长度在300字节以下，无法承载太大的数据包。所以 MQTT-SN 的数据包更小巧。 MQTT-SN 的官方标准下载地址: http://mqtt.org/new/wp-content/uploads/2009/06/MQTT-SN_spec_v1.2.pdf MQTT-SN 和 MQTT 的区别 MQTT-SN 的信令和 MQTT 大部分都相同，比如都有 Will, 都有 Connect/Subscribe/Publish 命令. MQTT-SN 最大的不同是，Topic 使用 TopicId 来代替，而 TopicId 是一个16比特的数字。每一个数字对应一个 Topic, 设备和云端需要使用 REGISTER 命令映射 TopicId 和 Topic 的对应关系。 MQTT-SN 可以随时更改 Will 的内容, 甚至可以取消. 而 MQTT 只允许在 CONNECT 时设定 Will 的内容, 而且不允许更改. MQTT-SN 的网络中有网关这种设备，它负责把 MQTT-SN 转换成 MQTT，和云端的 MQTT Broker 通信. MQTT-SN 的协议支持自动发现网关的功能。 MQTT-SN 还支持设备的睡眠功能，如果设备进入睡眠状态，无法接收 UDP 数据，网关将把下行的 PUBLISH 消息缓存起来，直到设备苏醒后再传送。 EMQX-SN 网关插件 EMQX-SN 是 EMQ X 的一个网关插件，实现了 MQTT-SN 的大部分功能，它相当于一个在云端的 MQTT-SN 网关，直接和 EMQ X Broker 相连。 配置参数 # File: etc/plugins/emqx_sn.conf: mqtt.sn.port = 1884 mqtt.sn.advertise_duration = 900 mqtt.sn.gateway_id = 1 mqtt.sn.username = mqtt_sn_user mqtt.sn.password = abc 配置项 说明 mqtt.sn.port 指定 MQTT-SN 监听的端口号 mqtt.sn.advertise_duration ADVERTISE 消息的发送间隔(秒) mqtt.sn.gateway_id 网关 ID mqtt.sn.username 这是可选的参数，指定所有 MQTT-SN 连接的用户名，用于鉴权模块 mqtt.sn.password 这也是可选的参数，和 username 一起使用 启动 emqx-sn ./bin/emqx_ctl plugins load emqx_sn MQTT-SN 客户端库 https://github.com/eclipse/paho.mqtt-sn.embedded-c/ https://github.com/ty4tw/MQTT-SN https://github.com/njh/mqtt-sn-tools https://github.com/arobenko/mqtt-sn LWM2M 协议 LwM2M 全称是 Lightweight Machine-To-Machine，是由 Open Mobile Alliance(OMA) 定义的一套适用于物联网的轻量级协议，它提供了设备管理和通讯的功能，尤其适用于资源有限的终端设备。协议可以在 这里 下载。 LwM2M 基于 REST 架构，使用 CoAP 作为底层的传输协议，承载在 UDP 或者 SMS 上，因而报文结构简单小巧，并且在网络资源有限及无法确保设备始终在线的环境里同样适用。 LwM2M 最主要的实体包括 LwM2M Server 和 LwM2M Client。 LwM2M Server 作为服务器，部署在 M2M 服务供应商处或网络服务供应商处。LwM2M 定义了两种服务器 一种是 LwM2M BOOTSTRAP SERVER，emqx-lwm2m 插件并未实现该服务器的功能。 一种是 LwM2M SERVER，emqx-lwm2m 实现该服务器在 UDP 上的功能，SMS 并没有实现。 LwM2M Client 作为客户端，部署在各个 LwM2M 设备上。 在 LwM2M Server 和 LwM2M Client 之间，LwM2M 协议定义了4个接口。 引导接口 Bootstrap：向 LwM2M 客户端提供注册到 LwM2M 服务器的必要信息，例如服务器访问信息、客户端支持的资源信息等。 客户端注册接口 Client Registration：使 LwM2M 客户端与 LwM2M 服务器互联，将 LwM2M 客户端的相关信息存储在 LwM2M 服务器上。只有完成注册后，LwM2M 客户端与服务器端之间的通信与管理才成为可能。 设备管理与服务实现接口 Device Management and Service Enablement：该接口的主控方为 LwM2M 服务器，服务器向客户端发送指令，客户端对指令做出回应并将回应消息发送给服务器。 信息上报接口 Information Reporting：允许 LwM2M 服务器端向客户端订阅资源信息，客户端接收订阅后按照约定的模式向服务器端报告自己的资源变化情况。 LwM2M 把设备上的服务抽象为 Object 和 Resource, 在 XML 文件中定义各种 Object 的属性和功能。可以在 这里 找到 XML 的各种定义。 LwM2M 协议预定义了8种 Object 来满足基本的需求，分别是： Security 安全对象 Server 服务器对象 Access Control 访问控制对象 Device 设备对象 Connectivity Monitoring 连通性监控对象 Firmware 固件对象 Location 位置对象 Connectivity Statistics 连通性统计对象 EMQX-LWM2M 插件 EMQX-LWM2M 是 EMQ X 服务器的一个网关插件，实现了 LwM2M 的大部分功能。MQTT 客户端可以通过 EMQX-LWM2M 访问支持 LwM2M 的设备。设备也可以往 EMQX-LWM2M 上报 notification，为 EMQ X后端的服务采集数据。 MQTT 和 LwM2M的转换 从 MQTT 客户端可以发送 Command 给 LwM2M 设备。MQTT 到 LwM2M 的命令使用如下的 topic \"lwm2m/{?device_end_point_name}/command\". 其中 MQTT Payload 是一个 json 格式的字符串，指定要发送的命令，更多的细节请参见 emqx-lwm2m 的文档。 LwM2M 设备的回复用如下 topic 传送 \"lwm2m/{?device_end_point_name}/response\". MQTT Payload 也是一个 json 格式的字符串，更多的细节请参见 emqx-lwm2m 的文档。 配置参数 ## File: etc/emqx_lwm2m.conf: lwm2m.port = 5683 lwm2m.certfile = etc/certs/cert.pem lwm2m.keyfile = etc/certs/key.pem lwm2m.xml_dir = etc/lwm2m_xml 配置项 说明 lwm2m.port 指定 LwM2M 监听的端口号，为了避免和 emqx-coap 冲突，使用了非标准的5783端口 lwm2m.certfile DTLS 使用的证书 lwm2m.keyfile DTLS 使用的秘钥 lwm2m.xml_dir 存放 XML 文件的目录，这些 XML 用来定义 LwM2M Object 启动 emqx-lwm2m ./bin/emqx_ctl plugins load emqx_lwm2m LwM2M 的客户端库 https://github.com/eclipse/wakaama https://github.com/OpenMobileAlliance/OMA-LWM2M-DevKit https://github.com/AVSystem/Anjay http://www.eclipse.org/leshan/ 私有 TCP 协议 EMQ X 提供 emqx-tcp 插件，插件作为一个靠近端侧的一个接入模块，按照其功能逻辑和整个系统的关系，将整个消息交换的过程可以分成三个部分：终端侧，平台侧和其它侧： |||| || || +---+ PUB +-----------+ | D | INCOMING +----------+ PUB +---------+ -->| subscriber| | E |----------->| |----------->| |--/ +-----------+ | V | | emqx-tcp | | EMQ X | | I | 终端侧，通过本插件定义的 TCP 私有协议进行接入，然后实现数据的上报，或者接收下行的消息。 平台侧，主体是 emqx-tcp 插件和 EMQ X 系统。emqx-tcp 负责报文的编解码，代理订阅下行主题。实现将上行消息转为 EMQ X 系统中的 MQTT 消息 PUBLISH 到整个系统中；将下行的 MQTT 消息转化为 TCP 私有协议的报文结构，下发到终端。 其它侧，可以对 2 中出现的上行的 PUBLISH 消息的主题进行订阅，以接收上行消息。或对发布消息到具体的下行的主题，以发送数据到终端侧。 配置说明 协议层 ## 闲置时间。超过该时间未收到 CONNECT 帧, 将 ## 直接关闭该 TCP 连接 tcp.proto.idle_timeout = 1s ## 上行主题。上行消息到 EMQ 系统中的消息主题 ## ## 占位符： ## - %c: 接入客户端的 ClientId ## - %u: 接入客户端的 Username tcp.proto.up_topic = tcp/%c/up ## 下行主题。客户端接入成功后, emqx-tcp 会订阅 ## 该主题，以接收 EMQ 系统向该类型的客户端下 ## 发的消息。 ## ## 占位符：(同上) tcp.proto.dn_topic = tcp/%c/dn ## 最大处理的单个 TCP 私有协议报文大小 tcp.proto.max_packet_size = 65535 ## 开启状态统计。开启后，emqx-tcp 会定期更新 ## 连接信息, 并检测连接的健康状态 tcp.proto.enable_stats = on ## 强制 GC, 当进程已处理 1000 消息或发送数据超过 1M tcp.proto.force_gc_policy = 1000|1MB ## 强制关闭连接, 当进程堆积 8000 消息或堆栈内存超过 800M tcp.proto.force_shutdown_policy = 8000|800MB 监听器 监听器配置比较广泛，在此仅列举部分常用部分： ```bash 配置监听的端口 tcp.listener.external = 0.0.0.0:8090 配置监听池大小。影响 TCP 建链的并发速率。 tcp.listener.external.acceptors = 8 最大连接数 tcp.listener.external.max_connections = 1024000 每秒支持的最大并发连接数 tcp.listener.external.max_conn_rate = 1000 ``` .emqxee { display: none; }"},"development/client.html":{"url":"development/client.html","title":"MQTT 客户端库","summary":null,"keywords":"","body":"MQTT 客户端库MQTT 客户端生命周期MQTT 客户端库 本页选取各个编程语言中热门 MQTT 客户端库进行介绍说明，提供连接、发布、订阅、取消订阅基本功能代码示例。 MQTT C 客户端库 MQTT Java 客户端库 MQTT Go 客户端库 MQTT Erlang 客户端库 MQTT JavaScript 客户端库 MQTT Python 客户端库 MQTT 社区收录了完整的 MQTT 客户端库列表，本章节对热门的每个库都提供连接样例、支持度分析，你可以点击此处查看。 MQTT 客户端生命周期 MQTT 客户端整个生命周期的行为可以概括为：建立连接、订阅主题、接收消息并处理、向指定主题发布消息、取消订阅、断开连接。 标准的客户端库在每个环节都暴露出相应的方法，不同库在相同环节所需方法参数含义大致相同，具体选用哪些参数、启用哪些功能特性需要用户深入了解 MQTT 协议特性并结合实际应用场景而定。 以一个客户端连接并发布、处理消息为例，每个环节大致需要进行的步骤： 建立连接： 指定 MQTT Broker 基本信息接入地址与端口 指定传输类型是 TCP 还是 MQTT over WebSocket 如果启用 TLS 需要选择协议版本并携带相应的的证书 Broker 启用了认证鉴权则客户端需要携带相应的 MQTT Username Password 信息 配置客户端参数如 keepalive 时长、clean session 回话保留标志位、MQTT 协议版本、遗嘱消息（LWT）等 订阅主题：连接建立成功后可以订阅主题，需要指定主题信息 指定主题过滤器 Topic，订阅的时候支持主题通配符 + 与 # 的使用 指定 QoS，根据客户端库和 Broker 的实现可选 Qos 0 1 2，注意部分 Broker 与云服务提供商不支持部分 QoS 级别，如 AWS IoT 、阿里云 IoT 套件、Azure IoT Hub 均不支持 QoS 2 级别消息 订阅主题可能因为网络问题、Broker 端 ACL 规则限制而失败 接收消息并处理： 一般是在连接时指定处理函数，依据客户端库与平台的网络编程模型不同此部分处理方式略有不同 发布消息：向指定主题发布消息 指定目标主题，注意该主题不能包含通配符 + 或 #，若主题中包含通配符可能会导致消息发布失败、客户端断开等情况（视 Broker 与客户端库实现方式） 指定消息 QoS 级别，同样存在不同 Broker 与平台支持的 QoS 级别不同，如 Azure IoT Hub 发布 QoS 2 的消息将断开客户端连接 指定消息体内容，消息体内容大小不能超出 Broker 设置最大消息大小 指定消息 Retain 保留消息标志位 取消订阅： 指定目标主题即可 断开连接： 客户端主动断开连接，服务器端将发布遗嘱消息（LWT） .emqxee { display: none; }"},"development/c.html":{"url":"development/c.html","title":"MQTT C 客户端库","summary":null,"keywords":"","body":"MQTT C 客户端库Paho C 使用示例Paho C MQTT 5.0 支持MQTT C 客户端库 Eclipse Paho C 与 Eclipse Paho Embedded C 均为 Eclipse Paho 项目下的 C 语言客户端库（MQTT C Client），均为使用 ANSI C 编写的功能齐全的 MQTT 客户端。 Eclipse Paho Embedded C 可以在桌面操作系统上使用，但主要针对 mbed，Arduino和 FreeRTOS 等嵌入式环境。 该客户端有同步/异步两种 API ，分别以 MQTTClient 和 MQTTAsync 开头： 同步 API 旨在更简单，更有用，某些调用将阻塞直到操作完成为止，使用编程上更加容易； 异步 API 中只有一个调用块 API-waitForCompletion ，通过回调进行结果通知，更适用于非主线程的环境。 Paho C 使用示例 MQTT C 语言相关两个客户端库的比较、下载、使用方式等详细说明请移步至项目主页查看，本示例包含 C 语言的 Paho C 连接 EMQ X Broker，并进行消息收发完整代码： #include \"stdio.h\" #include \"stdlib.h\" #include \"string.h\" #include \"MQTTClient.h\" #define ADDRESS \"tcp://broker.emqx.io:1883\" #define CLIENTID \"emqx_test\" #define TOPIC \"testtopic/1\" #define PAYLOAD \"Hello World!\" #define QOS 1 #define TIMEOUT 10000L int main(int argc, char* argv[]) { MQTTClient client; MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer; MQTTClient_message pubmsg = MQTTClient_message_initializer; MQTTClient_deliveryToken token; int rc; MQTTClient_create(&client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL); // MQTT 连接参数 conn_opts.keepAliveInterval = 20; conn_opts.cleansession = 1; if ((rc = MQTTClient_connect(client, &conn_opts)) != MQTTCLIENT_SUCCESS) { printf(\"Failed to connect, return code %d\\n\", rc); exit(-1); } // 发布消息 pubmsg.payload = PAYLOAD; pubmsg.payloadlen = strlen(PAYLOAD); pubmsg.qos = QOS; pubmsg.retained = 0; MQTTClient_publishMessage(client, TOPIC, &pubmsg, &token); printf(\"Waiting for up to %d seconds for publication of %s\\n\" \"on topic %s for client with ClientID: %s\\n\", (int)(TIMEOUT/1000), PAYLOAD, TOPIC, CLIENTID); rc = MQTTClient_waitForCompletion(client, token, TIMEOUT); printf(\"Message with delivery token %d delivered\\n\", token); // 断开连接 MQTTClient_disconnect(client, 10000); MQTTClient_destroy(&client); return rc; } Paho C MQTT 5.0 支持 目前 Paho C 已经完整支持 MQTT 5.0。 .emqxee { display: none; }"},"development/java.html":{"url":"development/java.html","title":"MQTT Java 客户端库","summary":null,"keywords":"","body":"MQTT Java 客户端库通过 Maven 安装 Paho JavaPaho Java 使用示例Paho Java MQTT 5.0 支持MQTT Java 客户端库 Eclipse Paho Java Client 是用 Java 编写的 MQTT 客户端库（MQTT Java Client），可用于 JVM 或其他 Java 兼容平台（例如Android）。 Eclipse Paho Java Client 提供了MqttAsyncClient 和 MqttClient 异步和同步 API。 通过 Maven 安装 Paho Java 通过包管理工具 Maven 可以方便地安装 Paho Java 客户端库，截止目前最新版本安装如下： org.eclipse.paho org.eclipse.paho.client.mqttv3 1.2.2 Paho Java 使用示例 Java 体系中 Paho Java 是比较稳定、广泛应用的 MQTT 客户端库，本示例包含 Java 语言的 Paho Java 连接 EMQ X Broker，并进行消息收发完整代码： App.java package io.emqx; import org.eclipse.paho.client.mqttv3.MqttClient; import org.eclipse.paho.client.mqttv3.MqttConnectOptions; import org.eclipse.paho.client.mqttv3.MqttException; import org.eclipse.paho.client.mqttv3.MqttMessage; import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence; public class App { public static void main(String[] args) { String subTopic = \"testtopic/#\"; String pubTopic = \"testtopic/1\"; String content = \"Hello World\"; int qos = 2; String broker = \"tcp://broker.emqx.io:1883\"; String clientId = \"emqx_test\"; MemoryPersistence persistence = new MemoryPersistence(); try { MqttClient client = new MqttClient(broker, clientId, persistence); // MQTT 连接选项 MqttConnectOptions connOpts = new MqttConnectOptions(); connOpts.setUserName(\"emqx_test\"); connOpts.setPassword(\"emqx_test_password\".toCharArray()); // 保留会话 connOpts.setCleanSession(true); // 设置回调 client.setCallback(new PushCallback()); // 建立连接 System.out.println(\"Connecting to broker: \" + broker); client.connect(connOpts); System.out.println(\"Connected\"); System.out.println(\"Publishing message: \" + content); // 订阅 client.subscribe(subTopic); // 消息发布所需参数 MqttMessage message = new MqttMessage(content.getBytes()); message.setQos(qos); client.publish(pubTopic, message); System.out.println(\"Message published\"); client.disconnect(); System.out.println(\"Disconnected\"); client.close(); System.exit(0); } catch (MqttException me) { System.out.println(\"reason \" + me.getReasonCode()); System.out.println(\"msg \" + me.getMessage()); System.out.println(\"loc \" + me.getLocalizedMessage()); System.out.println(\"cause \" + me.getCause()); System.out.println(\"excep \" + me); me.printStackTrace(); } } } 回调消息处理类 OnMessageCallback.java package io.emqx; import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken; import org.eclipse.paho.client.mqttv3.MqttCallback; import org.eclipse.paho.client.mqttv3.MqttMessage; public class OnMessageCallback implements MqttCallback { public void connectionLost(Throwable cause) { // 连接丢失后，一般在这里面进行重连 System.out.println(\"连接断开，可以做重连\"); } public void messageArrived(String topic, MqttMessage message) throws Exception { // subscribe后得到的消息会执行到这里面 System.out.println(\"接收消息主题:\" + topic); System.out.println(\"接收消息Qos:\" + message.getQos()); System.out.println(\"接收消息内容:\" + new String(message.getPayload())); } public void deliveryComplete(IMqttDeliveryToken token) { System.out.println(\"deliveryComplete---------\" + token.isComplete()); } } Paho Java MQTT 5.0 支持 目前 Paho Java 还在适配 MQTT 5.0，尚未全面支持。 .emqxee { display: none; }"},"development/go.html":{"url":"development/go.html","title":"MQTT Go 客户端库","summary":null,"keywords":"","body":"MQTT Go 客户端库MQTT Go 使用示例Paho Golang MQTT 5.0 支持MQTT Go 客户端库 Eclipse Paho MQTT Go Client 为 Eclipse Paho 项目下的 Go 语言版客户端库，该库能够连接到 MQTT Broker 以发布消息，订阅主题并接收已发布的消息，支持完全异步的操作模式。 客户端依赖于 Google 的 proxy 和 websockets 软件包，通过以下命令完成安装： go get github.com/eclipse/paho.mqtt.golang MQTT Go 使用示例 本示例包含 Go 语言的 Paho MQTT 连接 EMQ X Broker，并进行消息收发完整代码： package main import ( \"fmt\" \"log\" \"os\" \"time\" \"github.com/eclipse/paho.mqtt.golang\" ) var f mqtt.MessageHandler = func(client mqtt.Client, msg mqtt.Message) { fmt.Printf(\"TOPIC: %s\\n\", msg.Topic()) fmt.Printf(\"MSG: %s\\n\", msg.Payload()) } func main() { mqtt.DEBUG = log.New(os.Stdout, \"\", 0) mqtt.ERROR = log.New(os.Stdout, \"\", 0) opts := mqtt.NewClientOptions().AddBroker(\"tcp://broker.emqx.io:1883\").SetClientID(\"emqx_test_client\") opts.SetKeepAlive(60 * time.Second) // 设置消息回调处理函数 opts.SetDefaultPublishHandler(f) opts.SetPingTimeout(1 * time.Second) c := mqtt.NewClient(opts) if token := c.Connect(); token.Wait() && token.Error() != nil { panic(token.Error()) } // 订阅主题 if token := c.Subscribe(\"testtopic/#\", 0, nil); token.Wait() && token.Error() != nil { fmt.Println(token.Error()) os.Exit(1) } // 发布消息 token := c.Publish(\"testtopic/1\", 0, false, \"Hello World\") token.Wait() time.Sleep(6 * time.Second) // 取消订阅 if token := c.Unsubscribe(\"testtopic/#\"); token.Wait() && token.Error() != nil { fmt.Println(token.Error()) os.Exit(1) } // 断开连接 c.Disconnect(250) time.Sleep(1 * time.Second) } Paho Golang MQTT 5.0 支持 目前 Paho Golang 还在适配 MQTT 5.0，尚未全面支持。 .emqxee { display: none; }"},"development/erlang.html":{"url":"development/erlang.html","title":"MQTT Erlang 客户端库","summary":null,"keywords":"","body":"MQTT Erlang 客户端库emqtt 使用示例emqtt MQTT 5.0 支持MQTT Erlang 客户端库 emqtt 是开源 MQTT Broker EMQ X 官方提供的客户端库，适用于 Erlang 语言。 Erlang 生态有多个 MQTT Broker 实现，如通过插件支持 MQTT 的 RabbitMQ ，VerenMQ、EMQ X 等。但受限于语言小众性，可用的 MQTT 客户端库几乎没有选择的余地，MQTT 社区收录的 Erlang 客户端库中 emqtt 是最佳选择。 emqtt 完全由 Erlang 实现，完成整支持 MQTT v3.1.1 和 MQTT v5.0 协议版本，支持 SSL 单双向认证与 WebSocket 连接。另一款 MQTT 基准测试工具 emqtt_bench 就基于该客户端库构建。 emqtt 使用示例 本示例包含 Erlang 的 emqtt 客户端库连接 EMQ X Broker，并进行消息收发完整代码： ClientId = >. {ok, ConnPid} = emqtt:start_link([{clientid, ClientId}]). {ok, _Props} = emqtt:connect(ConnPid). Topic = >. QoS = 1. {ok, _Props, _ReasonCodes} = emqtt:subscribe(ConnPid, {Topic, QoS}). {ok, _PktId} = emqtt:publish(ConnPid, >, >, QoS). %% If the qos of publish packet is 0, `publish` function would not return packetid. ok = emqtt:publish(ConnPid, >, >, 0). %% Recursively get messages from mail box. Y = fun (Proc) -> ((fun (F) -> F(F) end)((fun(ProcGen) -> Proc(fun() -> (ProcGen(ProcGen))() end) end))) end. Rec = fun(Receive) -> fun()-> receive {publish, Msg} -> io:format(\"Msg: ~p~n\", [Msg]), Receive(); _Other -> Receive() after 5 -> ok end end end. (Y(Rec))(). %% If you don't like y combinator, you can also try named function to recursively get messages in erlang shell. Receive = fun Rec() -> receive {publish, Msg} -> io:format(\"Msg: ~p~n\", [Msg]), Rec(); _Other -> Rec() after 5 -> ok end end. Receive(). {ok, _Props, _ReasonCode} = emqtt:unsubscribe(ConnPid, >). ok = emqtt:disconnect(ConnPid). emqtt MQTT 5.0 支持 目前 emqtt 已经完整支持 MQTT 5.0。 .emqxee { display: none; }"},"development/javascript.html":{"url":"development/javascript.html","title":"MQTT JavaScript 客户端库","summary":null,"keywords":"","body":"MQTT JavaScript 客户端库MQTT.js 使用示例MQTT.js MQTT 5.0 支持MQTT JavaScript 客户端库 MQTT.js 是 JavaScript 编写的，实现了 MQTT 协议客户端功能的模块，可以在浏览器 和 Node.js 环境中使用。 由于 JavaScript 单线程特性，MQTT.js 是全异步 MQTT 客户端，MQTT.js 支持 MQTT 与 MQTT over WebSocket，在不同运行环境支持的度如下： 浏览器环境：MQTT over WebSocket（包括微信小程序、支付宝小程序等定制浏览器环境） Node.js 环境：MQTT、MQTT over WebSocket 不同环境里除了少部分连接参数不同，其他 API 均是相同的。 使用 npm 安装： npm i mqtt 使用 CDN 安装（浏览器）： // 将在全局初始化一个 mqtt 变量 console.log(mqtt) 在安装 Node.js 的环境里，可以通过 npm i mqtt -g 命令全局安装以命令行的形式使用 MQTT.js。 npm i mqtt -g mqtt help > MQTT.js command line interface, available commands are: * publish publish a message to the broker * subscribe subscribe for updates from the broker * version the current MQTT.js version * help help about commands > Launch 'mqtt help [command]' to know more about the commands. MQTT.js 使用示例 本示例包含 JavaScrip 语言的 MQTT.js 连接 EMQ X Broker，并进行消息收发完整代码： // const mqtt = require('mqtt') import mqtt from 'mqtt' // 连接选项 const options = { clean: true, // 保留回话 connectTimeout: 4000, // 超时时间 // 认证信息 clientId: 'emqx_test', username: 'emqx_test', password: 'emqx_test', } // 连接字符串, 通过协议指定使用的连接方式 // ws 未加密 WebSocket 连接 // wss 加密 WebSocket 连接 // mqtt 未加密 TCP 连接 // mqtts 加密 TCP 连接 // wxs 微信小程序连接 // alis 支付宝小程序连接 const connectUrl = 'wss://broker.emqx.io:8084/mqtt' const client = mqtt.connect(connectUrl, options) client.on('reconnect', (error) => { console.log('正在重连:', error) }) client.on('error', (error) => { console.log('连接失败:', error) }) client.on('message', (topic, message) => { console.log('收到消息：', topic, message.toString()) }) MQTT.js MQTT 5.0 支持 目前 MQTT.js 已经完整支持 MQTT 5.0。 .emqxee { display: none; }"},"development/python.html":{"url":"development/python.html","title":"MQTT Python 客户端库","summary":null,"keywords":"","body":"MQTT Python 客户端库Paho Python 使用示例Paho Python MQTT 5.0 支持MQTT Python 客户端库 Eclipse Paho Python 为 Eclipse Paho 项目下的 Python 语言版客户端库，该库能够连接到 MQTT Broker 以发布消息，订阅主题并接收已发布的消息。 使用 PyPi 包管理工具安装： pip install paho-mqtt Paho Python 使用示例 本示例包含 Python 语言的 Paho Python 连接 EMQ X Broker，并进行消息收发完整代码： import paho.mqtt.client as mqtt # 连接成功回调 def on_connect(client, userdata, flags, rc): print('Connected with result code '+str(rc)) client.subscribe('testtopic/#') # 消息接收回调 def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() # 指定回调函数 client.on_connect = on_connect client.on_message = on_message # 建立连接 client.connect('broker.emqx.io', 1883, 60) # 发布消息 client.publish('emqtt',payload='Hello World',qos=0) client.loop_forever() Paho Python MQTT 5.0 支持 目前 Paho Python 还在适配 MQTT 5.0，尚未全面支持。 .emqxee { display: none; }"},"development/resource.html":{"url":"development/resource.html","title":"其他资源","summary":null,"keywords":"","body":"其他资源其他资源 本页整理提供 EMQ X 客户端库、客户端工具、性能测试工具以及硬件等资源，如果你有相关推荐，欢迎提交到此页。 MQTT 客户端库CoAP 客户端库客户端工具性能测试工具硬件资源 Eclipse Paho C Embedded C libmosquitto libemqtt wolfMQTT Eclipse Paho C++ Embedded C++ CocoaMQTT emqttc erlmqtt Eclipse Paho Java Xenqtt MeQanTT mqtt-client Eclipse Paho MQTT.js node_mqtt_client ascoltatori mqttIO-objC MQTTKit MQTT-Client phpMQTT Mosquitto-PHP sskaje's MQTT library Eclipse Paho Python nyamuk MQTT-For-Twisted HBMQTT ruby-mqtt mosquitto Aphid SwiftMQTT Microcoap Cantcoap Lobaro-coap Libcoap Gen_coap NCoAP Californium Node-coap Coapthon Aiocoap MQTT Web Toolkit MQTTX mqtt-jmeter xmeter coap-jmeter jmeter locust Air202 EMW3088 ESP8266 88MW300 CC3200 ESP12F MT7697 NodeMCU Wrtnode7 ESP32 .emqxee { display: none; }"},"faq/faq.html":{"url":"faq/faq.html","title":"入门概念","summary":null,"keywords":"","body":"入门概念EMQ X 是什么？为什么选择EMQ X？EMQ X 与物联网平台的关系是什么？EMQ X 有哪些产品？EMQ X 与 NB-IoT、LoRAWAN 的关系是什么？MQTT 协议与 HTTP 协议相比，有何优点和弱点?什么是认证鉴权？使用场景是什么？什么是 Hook？使用场景是什么？什么是 mqueue？如何配置 mqueue？什么是 WebSocket？什么情况下需要通过 WebSocket 去连接 EMQ X 服务器？什么是共享订阅？有何使用场景？什么是离线消息？什么是代理订阅？使用场景是什么？系统主题有何用处？都有哪些系统主题？入门概念 EMQ X 是什么？ EMQ X 是开源百万级分布式 MQTT 消息服务器（MQTT Messaging Broker），用于支持各种接入标准 MQTT 协议的设备，实现从设备端到服务器端的消息传递，以及从服务器端到设备端的设备控制消息转发。从而实现物联网设备的数据采集，和对设备的操作和控制。 为什么选择EMQ X？ EMQ X 与别的 MQTT 服务器相比，有以下的优点： 经过100+版本的迭代，EMQ X 目前为开源社区中最流行的 MQTT 消息中间件，在各种客户严格的生产环境上经受了严苛的考验； EMQ X 支持丰富的物联网协议，包括 MQTT、MQTT-SN、CoAP、 LwM2M、LoRaWAN 和 WebSocket 等； 优化的架构设计，支持超大规模的设备连接。企业版单机能支持百万的 MQTT 连接；集群能支持千万级别的 MQTT 连接； 易于安装和使用； 灵活的扩展性，支持企业的一些定制场景； 中国本地的技术支持服务，通过微信、QQ等线上渠道快速响应客户需求； EMQ X 与物联网平台的关系是什么？ 典型的物联网平台包括设备硬件、数据采集、数据存储、分析、Web / 移动应用等。EMQ X 位于数据采集这一层，分别与硬件和数据存储、分析进行交互，是物联网平台的核心：前端的硬件通过 MQTT 协议与位于数据采集层的 EMQ X 交互，通过 EMQ X 将数据采集后，通过 EMQ X 提供的数据接口，将数据保存到后台的持久化平台中（各种关系型数据库和 NOSQL 数据库），或者流式数据处理框架等，上层应用通过这些数据分析后得到的结果呈现给最终用户。 EMQ X 有哪些产品？ 标签: 企业版 EMQ X 公司主要提供三个产品，主要体现在支持的连接数量、产品功能和商业服务等方面的区别： EMQ X Broker：EMQ X 开源版，提供 MQTT 协议、CoAP 和 LwM2M 等常见物联网协议的支持；支持 10 万级的并发连接； EMQ X Enterprise：EMQ X 企业版，在开源版基础上，增加了数据持久化 Redis、MySQL、MongoDB 或 PostgreSQL，数据桥接转发 Kafka，LoRaWAN 支持，监控管理，Kubernates 部署等方面的支持；支持百万级并发连接； EMQ X Platform：EMQ X 平台版，在企业版基础上，支持千万级的连接和跨数据中心的解决方案，提供物联网平台全生命周期中需要的各种服务（咨询、培训、架构设计、定制开发、平台建设、功能测试与运维服务）。 EMQ X 与 NB-IoT、LoRAWAN 的关系是什么？ 标签: NB-IoT LoRAWAN 多协议 EMQ X 是一个开源的 MQTT 消息服务器，并且 MQTT 是一个 TCP 协议栈上位于应用层的协议；而 NB-IoT 和 LoRAWAN 在 TCP 协议层处于物理层，负责物理信号的传输。因此两者在 TCP 协议栈的不同层次上，实现不同的功能。 MQTT 协议与 HTTP 协议相比，有何优点和弱点? 标签: 多协议 HTTP 协议是一个无状态的协议，每个 HTTP 请求为 TCP 短连接，每次请求都需要重新创建一个 TCP 连接（可以通过 keep-alive 属性来优化 TCP 连接的使用，多个 HTTP 请求可以共享该 TCP 连接）；而 MQTT 协议为长连接协议，每个客户端都会保持一个长连接。与 HTTP 协议相比优势在于 ： MQTT 的长连接可以用于实现从设备端到服务器端的消息传送之外，还可以实现从服务器端到设备端的实时控制消息发送，而 HTTP 协议要实现此功能只能通过轮询的方式，效率相对来说比较低； MQTT 协议在维护连接的时候会发送心跳包，因此协议以最小代价内置支持设备 “探活” 的功能，而 HTTP 协议要实现此功能的话需要单独发出 HTTP 请求，实现的代价会更高； 低带宽、低功耗。MQTT 在传输报文的大小上与 HTTP 相比有巨大的优势，因为 MQTT 协议在连接建立之后，由于避免了建立连接所需要的额外的资源消耗，发送实际数据的时候报文传输所需带宽与 HTTP 相比有很大的优势，参考网上有人做的测评，发送一样大小的数据，MQTT 比 HTTP 少近 50 倍的网络传输数据，而且速度快了将近 20 倍。在网上有人做的另外一个评测显示，接收消息的场景，MQTT 协议的耗电量为 HTTP 协议的百分之一，而发送数据的时候 MQTT 协议的耗电量为 HTTP 协议的十分之一； MQTT 提供消息质量控制（QoS），消息质量等级越高，消息交付的质量就越有保障，在物联网的应用场景下，用户可以根据不同的使用场景来设定不同的消息质量等级； 什么是认证鉴权？使用场景是什么？ 标签: 认证鉴权 认证鉴权指的是当一个客户端连接到 MQTT 服务器的时候，通过服务器端的配置来控制客户端连接服务器的权限。EMQ 的认证机制包含了有三种， 用户名密码：针对每个 MQTT 客户端的连接，可以在服务器端进行配置，用于设定用户名和密码，只有在用户名和密码匹配的情况下才可以让客户端进行连接 ClientID：每个 MQTT 客户端在连接到服务器的时候都会有个唯一的 ClientID，可以在服务器中配置可以连接该服务器的 ClientID 列表，这些 ClientID 的列表里的客户端可以连接该服务器 匿名：允许匿名访问 通过用户名密码、ClientID 认证的方式除了通过配置文件之外，还可以通过各类数据库和外部应用来配置，比如 MySQL、PostgreSQL、Redis、MongoDB、HTTP 和 LDAP 等。 什么是 Hook？使用场景是什么？ 标签: WebHook 钩子（hook）指的是由 EMQ X 在连接、对话和消息触发某些事件的时候提供给对外部的接口，主要提供了如下的钩子，EMQ X 提供了将这些 hook 产生的事件持久化至数据库的功能，从而很方便地查询得知客户端的连接、断开等各种信息。 client.connected：客户端上线 client.disconnected：客户端连接断开 client.subscribe：客户端订阅主题 client.unsubscribe：客户端取消订阅主题 session.created：会话创建 session.resumed：会话恢复 session.subscribed：会话订阅主题后 session.unsubscribed：会话取消订阅主题后 session.terminated：会话终止 message.publish：MQTT 消息发布 message.delivered：MQTT 消息送达 message.acked：MQTT 消息回执 message.dropped：MQTT 消息丢弃 什么是 mqueue？如何配置 mqueue？ 标签: 消息队列 mqueue 是 EMQ X 在消息发布流程中保存在会话中的一个消息队列，当 MQTT 连接报文中的 clean session 设置为 false 的时候，即使是客户端断开连接的情况下，EMQ X 也会为断连客户端保存一个会话，这个会话会缓存订阅关系，并代替断开连接的客户端去接收订阅主题上的消息，而这些消息会存在 EMQ X 的 mqueue 中，等到客户端重新上线再将消息重新发给客户端。由于 qos0 消息在 MQTT 协议中的优先级比较低，所以 EMQ X 默认不缓存 qos 0 的消息，mqueue 在 EMQ X 中是可以配置的，通过配置 zone.$name.mqueue_store_qos0 = true 可以将 qos0 消息也存在 mqueue 中，mqueue 的大小也是有限制的，通过配置项 zone.external.max_mqueue_len ，可以确定每个会话缓存的消息数量。注意，这些消息是存储在内存中的，所以尽量不要将 mqueue 长度限制修改为 0（设置为 0 代表 mqueue 长度没有限制），否则在实际的业务场景中，有内存耗光的风险。 什么是 WebSocket？什么情况下需要通过 WebSocket 去连接 EMQ X 服务器？ 标签: WebSocket 多协议 WebSocket 是一种在基于 HTTP 协议上支持全双工通讯的协议，通过该协议，用户可以实现浏览器和服务器之间的双向通信，比如可以通过服务器往浏览器端推送消息。EMQ X 提供了 WebSocket 连接支持，用户可以在浏览器端直接实现对主题的订阅和消息发送等操作。 什么是共享订阅？有何使用场景？ 标签: 共享订阅 共享订阅是 MQTT 5.0 标准的新特性，在标准发布前，EMQ X 就已经把共享订阅作为标准外特性进行了支持。在普通订阅中，所有订阅者都会收到订阅主题的所有消息，而在共享订阅中，订阅同一个主题的客户端会轮流的收到这个主题下的消息，也就是说同一个消息不会发送到多个订阅者，从而实现订阅端的多个节点之间的负载均衡。 共享订阅对于数据采集 / 集中处理类应用非常有用。在这样的场景下，数据的生产者远多余数据的消费者，且同一条数据只需要被任意消费者处理一次。 更多使用方式请参考 共享订阅。 什么是离线消息？ 标签: 离线消息 一般情况下 MQTT 客户端仅在连接到消息服务器的时候，如果客户端离线将收不到消息。但是在客户端有固定的 ClientID，clean_session 为 false，且 QoS 设置满足服务器端的配置要求时，在客户端离线时，服务器可以为客户端保持一定量的离线消息，并在客户端再次连接是发送给客户端。 离线消息在网络连接不是很稳定时，或者对 QoS 有一定要求时非常有用。 什么是代理订阅？使用场景是什么？ 标签: 代理订阅 通常情况客户端需要在连接到 EMQ X 之后主动订阅主题。代理订阅是指服务器为客户端订阅主题，这一过程不需要客户端参与，客户端和需要代理订阅的主题的对应关系保存在服务器中。 使用代理订阅可以集中管理大量的客户端的订阅，同时为客户端省略掉订阅这个步骤，可以节省客户端侧的计算资源和网络带宽。 以 Redis 数据库为例，代理订阅在 EMQ X 上使用方式请参考 Redis 实现客户端代理订阅 注：目前 EMQ X 企业版支持代理订阅。 系统主题有何用处？都有哪些系统主题？ 标签: 系统主题 系统主题以 $SYS/ 开头。EMQ X 会以系统主题的方式周期性的发布关于自身运行状态、MQTT 协议统计、客户端上下线状态到系统主题。订阅系统主题可以获得这些信息。 这里列举一些系统主题，完整的系统主题请参考 EMQ X 文档的相关章节： $SYS/brokers: 集群节点列表 $SYS/brokers/${node}/clients/${clientid}/connected: 当客户端连接时发送的客户端信息 $SYS/broker/${node}/stats/connections/count: 当前客户端总数 $SYS/broker/${node}/stats/sessions/count: 当前会话总数 .emqxee { display: none; }"},"faq/use-guide.html":{"url":"faq/use-guide.html","title":"使用教程","summary":null,"keywords":"","body":"使用教程怎么样才能使用 EMQ X？怎样更新 EMQ X license?EMQ X 支持私有协议进行扩展吗？如支持应该如何实现？我可以捕获设备上下线的事件吗？该如何使用？我想限定某些主题只为特定的客户端所使用，EMQ X 该如何进行配置？EMQ X 能做流量控制吗？EMQ X 是如何实现支持大规模并发和高可用的？EMQ X 能把接入的 MQTT 消息保存到数据库吗？在服务器端能够直接断开一个 MQTT 连接吗？EMQ X 能把接入的消息转发到 Kafka 吗？EMQ X 企业版中桥接 Kafka，一条 MQTT 消息到达 EMQ X 集群之后就回 MQTT Ack 报文还是写入 Kafka 之后才回 MQTT Ack 报文?EMQ X 支持集群自动发现吗？有哪些实现方式？我可以把 MQTT 消息从 EMQ X 转发其他消息中间件吗？例如 RabbitMQ？我可以把消息从 EMQ X 转到公有云 MQTT 服务上吗？比如 AWS 或者 Azure 的 IoT Hub？MQTT Broker（比如 Mosquitto）可以转发消息到 EMQ X 吗？我想跟踪特定消息的发布和订阅过程，应该如何做？为什么我做压力测试的时候，连接数目和吞吐量老是上不去，有系统调优指南吗？EMQ X 支持加密连接吗？推荐的部署方案是什么？EMQ X 安装之后无法启动怎么排查？EMQ X中ssl resumption session的使用MQTT 客户端断开连接统计使用教程 怎么样才能使用 EMQ X？ EMQ X 开源版可免费下载使用，下载地址：https://www.emqx.io/downloads#broker EMQ X 企业版支持下载试用，用户可以在 https://www.emqx.io/downloads#enterprise 下载，申请试用 license之后即可试用。 另外，还可以在公有云直接创建 EMQ X 企业版： 阿里云 青云 怎样更新 EMQ X license? 标签: License 点击 \"Download License\" 按钮下载 license, 然后找到您下载的 \"license.zip\" 文件并解压. 复制压缩包里的两个文件 (emqx.lic, emqx.key) 到 EMQ X 的 license 目录. 如果您的 EMQX 是使用 zip 包安装的, 那么压缩包里的两个文件需要拷贝到 \"emqx/etc/\" 目录; 如果是用 DEB/RPM 包安装的, 两个文件需要拷贝到 \"/etc/emqx/\" 目录; 如果是用 Docker 镜像安装的, 两个文件需要拷贝到 \"/opt/emqx/etc/\" 目录. 拷贝完成后需要通过命令行重新加载 license 以完成更新： 基础命令： emqx_ctl license reload [license 文件所在路径] 不同安装方式更新命令如下： ## 适用于 zip 包 ./bin/emqx_ctl license reload etc/emqx.lic ## DEB/RPM 包安装 emqx_ctl license reload /etc/emqx/emqx.lic ## Docker 镜像安装 docker exec -it emqx-ee emqx_ctl license reload /opt/emqx/etc/emqx.lic EMQ X 支持私有协议进行扩展吗？如支持应该如何实现？ 标签: 多协议 扩展 对于新开发的私有协议，EMQ X 提供一套 TCP 协议接入规范，私有协议可以按照该规范进行开发接入。如果您所使用的协议已经定型或协议底层非 TCP，可以通过网关进行转换处理，之后通过 MQTT 协议接入 EMQ X，或直接联系 EMQ 官方支持私有协议适配。 我可以捕获设备上下线的事件吗？该如何使用？ 标签: WebHook 系统主题 EMQ X 企业版可以通过以下的三种方式捕获设备的上下线的事件， Web Hook 订阅相关的 $SYS 主题 $SYS/brokers/${node}/clients/${clientid}/connected $SYS/brokers/${node}/clients/${clientid}/disconnected 直接保存到数据库 最后一种方法只有在企业版里才支持，支持的数据库包括 Redis、MySQL、PostgreSQL、MongoDB 和 Cassandra。用户可以通过配置文件指定所要保存的数据库，以及监听 client.connected 和 client.disconnected 事件，这样在设备上、下线的时候把数据保存到数据库中。 我想限定某些主题只为特定的客户端所使用，EMQ X 该如何进行配置？ 标签: ACL 发布订阅 EMQ X 支持限定客户端可以使用的主题，从而实现设备权限的管理。如果要做这样的限定，需要在 EMQ X 启用 ACL（Access Control List），并禁用匿名访问和关闭无 ACL 命中的访问许可（为了测试调试方便，在默认配置中，后两项是开启的，请注意关闭）。 ## etc/emqx.conf ## ACL nomatch mqtt.acl_nomatch = allow ACL 可以配置在文件 etc/acl.conf 中，或者配置在后台数据库中。下面例子是 ACL 控制文件的一个配置行，含义是用户 “dashboard” 可以订阅 “$SYS/#” 主题。ACL 在后台数据库中的配置思想与此类似，详细配置方法请参阅 EMQ X 文档的 ACL 访问控制 章节。 {allow, {user, \"dashboard\"}, subscribe, [\"$SYS/#\"]}. EMQ X 能做流量控制吗？ 标签: 流量控制 能。目前 EMQ X 支持连接速率和消息率控制。配置如下： ## Value: Number listener.tcp.external.max_conn_rate = 1000 ## Value: rate,burst listener.tcp.external.rate_limit = 1024,4096 EMQ X 是如何实现支持大规模并发和高可用的？ 标签: 性能 高并发 高并发和高可用是 EMQ X 的设计目标，为了实现这些目标 EMQ X 中应用了多种技术，比如： 利用 Erlang/OTP 平台的软实时、高并发和容错； 全异步架构； 连接、会话、路由、集群的分层设计； 消息平面和控制平面的分离等。 在精心设计和实现之后，单个 EMQ X Enterprise 节点就可以处理百万级的连接。 EMQ X 支持多节点集群，集群下整个系统的性能会成倍高于单节点，并能在单节点故障时保证系统服务不中断。 EMQ X 能把接入的 MQTT 消息保存到数据库吗？ 标签: 持久化 EMQ X 企业版支持消息持久化，可以将消息保存到数据库，开源版还暂时不支持。目前 EMQ X 企业版消息持久化支持的数据库有： Redis MongoDB MySQL PostgreSQL Cassandra AWS DynamoDB TimescaleDB OpenTSDB InfluxDB 有关数据持久化的支持请参见 EMQ X 数据持久化概览。 在服务器端能够直接断开一个 MQTT 连接吗？ 标签: HTTP API Dashboard 可以的。EMQ X 提供的 HTTP API 中包含断开 MQTT 连接，该操作在 EMQ X 2.x 和 3.0 的实现方式有所不同： 在 2.x 版本中是由 EMQ X 自定义扩展协议实现的 在 3.0 版本之后按照 MQTT 5.0 协议对从服务器端断开连接的规范要求实现的 调用的 API 如下所示： HTTP 方法：DELETE URL：api/[v2|v3]/clients/{clientid} 返回内容： { \"code\": 0, \"result\": [] } HTTP API 使用方式参考 管理监控API (HTTP API) EMQ X 能把接入的消息转发到 Kafka 吗？ 标签: Kafka 桥接 持久化 能。目前 EMQ X 企业版提供了内置的 Kafka 桥接方式，支持把消息桥接至 Kafka 进行流式处理。 EMQ X 使用 Kafka 参照 EMQ X 到 Kafka 的桥接 EMQ X 企业版中桥接 Kafka，一条 MQTT 消息到达 EMQ X 集群之后就回 MQTT Ack 报文还是写入 Kafka 之后才回 MQTT Ack 报文? 标签: Kafka 配置 取决于 Kafka 桥接的配置，配置文件位于/etc/emqx/plugins/emqx_bridge_kafka.conf ## Pick a partition producer and sync/async. bridge.kafka.produce = sync 同步：EMQ X 在收到 Kafka 返回的 Ack 之后才会给前端返回 MQTT Ack 报文 异步：MQTT 消息到达 EMQ X 集群之后就回 MQTT Ack 报文，而不会等待 Kafka 返回给 EMQ X 的 Ack 如果运行期间，后端的 Kafka 服务不可用，则消息会被累积在 EMQ X 服务器中， EMQ X 2.4.3 之前的版本会将未发送至 Kafka 的消息在内存中进行缓存，直至内存使用完毕，并且会导致 EMQ X 服务不可用。 EMQ X 2.4.3 版本开始会将未发送至 Kafka 的消息在磁盘中进行缓存，如果磁盘用完可能会导致数据丢失。 因此建议做好 Kafka 服务的监控，在发现 Kafka 服务有异常情况的时候尽快恢复 Kafka 服务。 EMQ X 支持集群自动发现吗？有哪些实现方式？ 标签: 集群 EMQ X 支持集群自动发现。集群可以通过手动配置或自动配置的方式实现。 目前支持的自动发现方式有： 手动集群 静态集群 IP Multi-cast 自动集群 DNS 自动集群 ETCD 自动集群 K8S 自动集群 有关集群概念和组建集群方式请参照 EMQ X 的集群概念 我可以把 MQTT 消息从 EMQ X 转发其他消息中间件吗？例如 RabbitMQ？ 标签: RabbitMQ 桥接 持久化 EMQ X 支持转发消息到其他消息中间件，通过 EMQ X 提供的桥接方式就可以做基于主题级别的配置，从而实现主题级别的消息转发。 EMQ X 桥接相关的使用方式请参照 EMQ X 桥接 我可以把消息从 EMQ X 转到公有云 MQTT 服务上吗？比如 AWS 或者 Azure 的 IoT Hub？ 标签: 桥接 EMQ X 可以转发消息到标准 MQTT Broker，包括其他 MQTT 实现、公有云的 IoT Hub，通过 EMQ X 提供的桥接就可以实现。 MQTT Broker（比如 Mosquitto）可以转发消息到 EMQ X 吗？ 标签: Mosquitto 桥接 Mosquitto 可以配置转发消息到 EMQ X，请参考数据桥接。 EMQ X 桥接相关的使用方式请参照 EMQ X 桥接 我想跟踪特定消息的发布和订阅过程，应该如何做？ 标签: Trace 调试 EMQ X 支持追踪来自某个客户端的报文或者发布到某个主题的报文。追踪消息的发布和订阅需要使用命令行工具（emqx_ctl）的 trace 命令，下面给出一个追踪‘topic’主题的消息并保存在 trace_topic.log 中的例子。更详细的说明请参阅 EMQ X 文档的相关章节。 ./bin/emqx_ctl trace topic \"topic\" \"trace_topic.log\" 为什么我做压力测试的时候，连接数目和吞吐量老是上不去，有系统调优指南吗？ 标签: 调试 性能测试 在做压力测试的时候，除了要选用有足够计算能力的硬件，也需要对软件运行环境做一定的调优。比如修改修改操作系统的全局最大文件句柄数，允许用户打开的文件句柄数，TCP 的 backlog 和 buffer，Erlang 虚拟机的进程数限制等等。甚至包括需要在客户端上做一定的调优以保证客户端可以有足够的连接资源。 系统的调优在不同的需求下有不同的方式，在 EMQ X 的文档-测试调优 中对用于普通场景的调优有较详细的说明 EMQ X 支持加密连接吗？推荐的部署方案是什么？ 标签: TLS 加密连接 EMQ X 支持加密连接。在生产环境部署时，推荐的方案是使用负载均衡终结 TLS。通过该方式，设备端和服务器端（负载均衡）的采用加密的连接，而负载均衡和后端的 EMQ X 节点采用一般的 TCP 连接。 EMQ X 安装之后无法启动怎么排查？ 标签: 调试 执行 $ emqx console ，查看输出内容 logger 命令缺失 $ emqx console Exec: /usr/lib/emqx/erts-10.3.5.1/bin/erlexec -boot /usr/lib/emqx/releases/v3.2.1/emqx -mode embedded -boot_var ERTS_LIB_DIR /usr/lib/emqx/erts-10.3.5.1/../lib -mnesia dir \"/var/lib/emqx/mnesia/emqx@127.0.0.1\" -config /var/lib/emqx/configs/app.2019.07.23.03.07.32.config -args_file /var/lib/emqx/configs/vm.2019.07.23.03.07.32.args -vm_args /var/lib/emqx/configs/vm.2019.07.23.03.07.32.args -- console Root: /usr/lib/emqx /usr/lib/emqx /usr/bin/emqx: line 510: logger: command not found 解决办法： Centos/Redhat $ yum install rsyslog Ubuntu/Debian $ apt-get install bsdutils openssl 缺失 $ emqx console Exec: /emqx/erts-10.3/bin/erlexec -boot /emqx/releases/v3.2.1/emqx -mode embedded -boot_var ERTS_LIB_DIR /emqx/erts-10.3/../lib -mnesia dir \"/emqx/data/mnesia/emqx@127.0.0.1\" -config /emqx/data/configs/app.2019.07.23.03.34.43.config -args_file /emqx/data/configs/vm.2019.07.23.03.34.43.args -vm_args /emqx/data/configs/vm.2019.07.23.03.34.43.args -- console Root: /emqx /emqx Erlang/OTP 21 [erts-10.3] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:32] [hipe] {\"Kernel pid terminated\",application_controller,\"{application_start_failure,kernel,{{shutdown,{failed_to_start_child,kernel_safe_sup,{on_load_function_failed,crypto}}},{kernel,start,[normal,[]]}}}\"} Kernel pid terminated (application_controller) ({application_start_failure,kernel,{{shutdown,{failed_to_start_child,kernel_safe_sup,{on_load_function_failed,crypto}}},{kernel,start,[normal,[]]}}}) Crash dump is being written to: log/crash.dump...done 解决办法：安装1.1.1以上版本的 openssl License 文件缺失 $ emqx console Exec: /usr/lib/emqx/erts-10.3.5.1/bin/erlexec -boot /usr/lib/emqx/releases/v3.2.1/emqx -mode embedded -boot_var ERTS_LIB_DIR /usr/lib/emqx/erts-10.3.5.1/../lib -mnesia dir \"/var/lib/emqx/mnesia/emqx@127.0.0.1\" -config /var/lib/emqx/configs/app.2019.07.23.05.52.46.config -args_file /var/lib/emqx/configs/vm.2019.07.23.05.52.46.args -vm_args /var/lib/emqx/configs/vm.2019.07.23.05.52.46.args -- console Root: /usr/lib/emqx /usr/lib/emqx Erlang/OTP 21 [erts-10.3.5.1] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:32] [hipe] Starting emqx on node emqx@127.0.0.1 Start http:management listener on 8080 successfully. Start http:dashboard listener on 18083 successfully. Start mqtt:tcp listener on 127.0.0.1:11883 successfully. Start mqtt:tcp listener on 0.0.0.0:1883 successfully. Start mqtt:ws listener on 0.0.0.0:8083 successfully. Start mqtt:ssl listener on 0.0.0.0:8883 successfully. Start mqtt:wss listener on 0.0.0.0:8084 successfully. EMQ X 3.2.1 is running now! \"The license certificate is expired!\" 2019-07-23 05:52:51.355 [critical] The license certificate is expired! 2019-07-23 05:52:51.355 [critical] The license certificate is expired! System shutdown! Stop mqtt:tcp listener on 127.0.0.1:11883 successfully. Stop mqtt:tcp listener on 0.0.0.0:1883 successfully. Stop mqtt:ws listener on 0.0.0.0:8083 successfully. Stop mqtt:ssl listener on 0.0.0.0:8883 successfully. Stop mqtt:wss listener on 0.0.0.0:8084 successfully. [os_mon] memory supervisor port (memsup): Erlang has closed [os_mon] cpu supervisor port (cpu_sup): Erlang has closed 解决办法：登陆emqx.io申请license或安装开源版的 EMQ X Broker EMQ X中ssl resumption session的使用 标签: TLS 修改emqx.conf配置中的 reuse_sessions = on 并生效后。如果客户端与服务端通过 SSL 已经连接成功，当第二次遇到客户端连接时，会跳过 SSL 握手阶段，直接建立连接，节省连接时间，增加客户端连接速度。 MQTT 客户端断开连接统计 标签: 指标 执行 emqx_ctl listeners，查看对应端口下的 shutdown_count 统计。 客户端断开链接错误码列表： keepalive_timeout：MQTT keepalive 超时 closed：TCP客户端断开连接（客户端发来的FIN，但没收到 MQTT DISCONNECT） normal：MQTT客户端正常断开 einval：EMQ X 想向客户端发送一条消息，但是Socket 已经断开 function_clause：MQTT 报文格式错误 etimedout：TCP 发送超时（没有收到TCP ACK 回应） proto_unexpected_c：在已经有一条MQTT连接的情况下重复收到了MQTT连接请求 idle_timeout： TCP 连接建立 15s 之后，还没收到 connect 报文 .emqxee { display: none; }"},"faq/deployment.html":{"url":"faq/deployment.html","title":"安装部署","summary":null,"keywords":"","body":"安装部署EMQ X 推荐部署的操作系统是什么？EMQ X 支持 Windows 操作系统吗？EMQ X 如何预估资源的使用？EMQ X 的百万连接压力测试的场景是什么？我的连接数目并不大，EMQ X 生产环境部署需要多节点吗？安装部署 EMQ X 推荐部署的操作系统是什么？ EMQ X 支持跨平台部署在 Linux、Windows、MacOS、ARM 嵌入系统，生产系推荐在 CentOS、Ubuntu、Debian 等 Linux 发行版上部署。 EMQ X 支持 Windows 操作系统吗？ 支持。部署参考文章. EMQ X 如何预估资源的使用？ 标签: 资源估算 EMQ X 对资源的使用主要有以下的影响因素，每个因素都会对计算和存储资源的使用产生影响： 连接数：对于每一个 MQTT 长连接，EMQ X 会创建两个 Erlang 进程，每个进程都会耗费一定的资源。连接数越高，所需的资源越多； 平均吞吐量：指的是每秒 Pub 和 Sub 的消息数量。吞吐量越高，EMQ X 的路由处理和消息转发处理就需要更多的资源； 消息体大小：消息体越大，在 EMQ X 中处理消息转发的时候在内存中进行数据存储和处理，所需的资源就越多； 主题数目：如果主题数越多，在 EMQ X 中的路由表会相应增长，因此所需的资源就越多； QoS：消息的 QoS 越高，EMQ X 服务器端所处理的逻辑会更多，因此会耗费更多的资源； 另外，如果设备通过 TLS（加密的连接）连接 EMQ X，EMQ X 会需要额外的资源（主要是 CPU 资源）。推荐方案是在 EMQ X 前面部署负载均衡，由负载均衡节点卸载 TLS，实现职责分离。 可参考 TODO 来预估计算资源的使用；公有云快速部署 EMQ X 实例，请参考TODO。 EMQ X 的百万连接压力测试的场景是什么？ 标签: 性能测试 在EMQ 2.0版本发布的时候，由第三方软件测试工具服务提供商 XMeter 执行了一次百万级别连接的性能测试。测试基于开源社区中最流行的性能测试工具 Apache JMeter，以及开源性能测试插件。该性能测试场景为测试客户端到服务器端的MQTT协议连接，该测试场景下除了发送MQTT协议的控制包和PING包（每5分钟发送一次）外，不发送用户数据，每秒新增连接数为1000，共计运行30分钟。 在该测试中，还执行了一些别的性能测试，主要为在为10万MQTT背景连接的情况下，执行了不同条件下的消息发送和接收的场景。具体请参见性能测试报告. 我的连接数目并不大，EMQ X 生产环境部署需要多节点吗？ 标签: 集群 即使在连接数量，消息率不高的情况下（服务器低负载），在生产环境下部署多节点的集群依然是很有意义的。集群能提高系统的可用性，降低单点故障的可能性。当一个节点宕机时，其他在线节点可以保证整个系统的服务不中断。 .emqxee { display: none; }"},"faq/error.html":{"url":"faq/error.html","title":"常见错误","summary":null,"keywords":"","body":"常见错误EMQ X 无法连接 MySQL 8.0OPENSSL 版本不正确Windows 缺失 MSVCR120.dll常见错误 EMQ X 无法连接 MySQL 8.0 标签: MySQL 认证 不同于以往版本，MySQL 8.0 对账号密码配置默认使用caching_sha2_password插件，需要将密码插件改成mysql_native_password 修改 mysql.user 表 ## 切换到 mysql 数据库 mysql> use mysql; ## 查看 user 表 mysql> select user, host, plugin from user; +------------------+-----------+-----------------------+ | user | host | plugin | +------------------+-----------+-----------------------+ | root | % | caching_sha2_password | | mysql.infoschema | localhost | caching_sha2_password | | mysql.session | localhost | caching_sha2_password | | mysql.sys | localhost | caching_sha2_password | | root | localhost | caching_sha2_password | +------------------+-----------+-----------------------+ ## 修改密码插件 mysql> ALTER USER 'your_username'@'your_host' IDENTIFIED WITH mysql_native_password BY 'your_password'; Query OK, 0 rows affected (0.01 sec) ## 刷新 mysql> FLUSH PRIVILEGES; Query OK, 0 rows affected (0.00 sec) 修改 my.conf 在 my.cnf 配置文件里面的 [mysqld] 下面加一行 default_authentication_plugin=mysql_native_password 重启 MySQL 即可 OPENSSL 版本不正确 标签: 启动失败 现象 执行 ./bin/emqx console 输出的错误内容包含： {application_start_failure,kernel,{{shutdown,{failed_to_start_child,kernel_safe_sup,{on_load_function_failed,crypto}}}, ..} 它表示，EMQ X 依赖的 Erlang/OTP 中的 crypto 应用启动失败。 解决方法 Linux 进入到 EMQ X 的安装目录（如果使用包管理工具安装 EMQ X，则应该进入与 EMQ X 的 lib 目录同级的位置） ## 安装包安装 $ cd emqx ## 包管理器安装，例如 yum。则它的 lib 目录应该在 /lib/emqx $ cd /lib/emqx 查询 crypto依赖的 .so 动态库列表及其在内存中的地址： $ ldd lib/crypto-*/priv/lib/crypto.so lib/crypto-4.6/priv/lib/crypto.so: /lib64/libcrypto.so.10: version `OPENSSL_1.1.1' not found (required by lib/crypto-4.6/priv/lib/crypto.so) linux-vdso.so.1 => (0x00007fff67bfc000) libcrypto.so.10 => /lib64/libcrypto.so.10 (0x00007fee749ca000) libc.so.6 => /lib64/libc.so.6 (0x00007fee74609000) libdl.so.2 => /lib64/libdl.so.2 (0x00007fee74404000) libz.so.1 => /lib64/libz.so.1 (0x00007fee741ee000) /lib64/ld-linux-x86-64.so.2 (0x00007fee74fe5000) 其中 OPENSSL_1.1.1' not found表明指定的 OPENSSL 版本的 .so 库未正确安装。 源码编译安装 OPENSSL 1.1.1，并将其 so 文件放置到可以被系统识别的路径： ## 下在最新版本 1.1.1 $ wget https://www.openssl.org/source/openssl-1.1.1c.tar.gz ## 上传至 ct-test-ha $ scp openssl-1.1.1c.tar.gz ct-test-ha:~/ ## 解压并编译安装 $ tar zxf openssl-1.1.1c.tar.gz $ cd openssl-1.1.1c $ ./config $ make test # 执行测试；如果输出 PASS 则继续 $ make install ## 确保库的引用 $ ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1 $ ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1 完成后，执行在 EMQ X 的 lib 同级目录下执行 ldd lib/crypto-*/priv/lib/crypto.so ，检查是否已能正确识别。如果不在有 not found 的 .so 库，即可正常启动 EMQ X。 macOS 进入到 EMQ X 的安装目录： ## 安装包安装 $ cd emqx ## brew 安装 $ cd /usr/local/Cellar/emqx// 查询 crypto依赖的 .so 动态库列表： $ otool -L lib/crypto-*/priv/lib/crypto.so lib/crypto-4.4.2.1/priv/lib/crypto.so: /usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib (compatibility version 1.1.0, current version 1.1.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5) 检查其显示 OPENSSL 已成功安装至指定的目录： $ ls /usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib ls: /usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib: No such file or directory 若不存在该文件，则需安装与 otool 打印出来的对应的 OPENSSL 版本，例如此处显示的为 openssl@1.1： $ brew install openssl@1.1 安装完成后，即可正常启动 EMQ X。 Windows 缺失 MSVCR120.dll 标签: 启动失败 现象 Windows 执行 ./bin/emqx console 弹出错误窗口： 无法启动次程序，因为计算机中丢失 MSVCR120.dll。请尝试重新安装该程序以解决此问题。 解决方法 安装 Microsoft Visual C++ RedistributablePackage .emqxee { display: none; }"},"faq/enterprise.html":{"url":"faq/enterprise.html","title":"商业服务","summary":null,"keywords":"","body":"商业服务EMQ X 企业版（Enterprise）和开源版（Broker）的主要区别是什么？EMQ X 提供方案咨询服务吗？商业服务 EMQ X 企业版（Enterprise）和开源版（Broker）的主要区别是什么？ 标签: 企业版 EMQ X 企业版基于开源版，包含了开源版的所有功能。与开源版相比，主要有以下方面的区别： 接入设备量级：开源版的稳定接入为 10 万，而企业版为 100 万。 数据持久化：企业版支持将消息转储到各类持久化数据库中，包括流行的关系型数据库，比如 MySQL、PostgresSQL；内存数据库 Redis；非关系型数据库 MongoDB 等； Kafka 数据桥接：通过内置桥接插件高效转发 MQTT 消息到 Kafka 集群，用户可以通过消费 Kafka 消息来实现实时流式数据的处理； RabbitMQ 数据桥接：支持 MQTT 消息桥接转发 RabbitMQ，应用可以通过消费 RabbitMQ 消息来实现可能的异构系统的集成； 监控管理（EMQ X Control Center） EMQ X 集群监控：包括连接、主题、消息和对话（session）统计等 Erlang 虚拟机监测：Erlang 虚拟机的进程、线程、内存、数据库和锁的使用等 主机监控：CPU、内存、磁盘、网络和操作系统等各类指标 安全特性：通过配置基于 TLS、DTLS 的安全连接（证书）等来提供更高级别安全保证。 EMQ X 提供方案咨询服务吗？ 提供。EMQ X 在为客户搭建物联网平台的咨询方面有丰富的经验，包括为互联网客户和电信运营商搭建千万级物联网平台的实践。包括如何搭建负载均衡、集群、安全策略、数据存储和分析方案等方面可以根据客户的需求制定方案，满足业务发展的需求。 .emqxee { display: none; }"},"faq/tags.html":{"url":"faq/tags.html","title":"FAQ 标签","summary":null,"keywords":"","body":"标签启动失败企业版NB-IoTLoRAWAN多协议License扩展资源估算认证鉴权WebHook系统主题消息队列WebSocketACL发布订阅共享订阅流量控制离线消息代理订阅性能高并发持久化HTTP APIDashboardKafka桥接配置集群RabbitMQMosquittoTrace调试性能测试TLS加密连接MySQL认证指标标签 启动失败 OPENSSL 版本不正确 企业版 EMQ X 有哪些产品？ EMQ X 企业版（Enterprise）和开源版（Broker）的主要区别是什么？ NB-IoT EMQ X 与 NB-IoT、LoRAWAN 的关系是什么？ LoRAWAN EMQ X 与 NB-IoT、LoRAWAN 的关系是什么？ 多协议 什么是 WebSocket？什么情况下需要通过 WebSocket 去连接 EMQ X 服务器？ License 怎样更新 EMQ X license? 扩展 EMQ X 支持私有协议进行扩展吗？如支持应该如何实现？ 资源估算 EMQ X 如何预估资源的使用？ 认证鉴权 什么是认证鉴权？使用场景是什么？ WebHook 我可以捕获设备上下线的事件吗？该如何使用？ 什么是 Hook？使用场景是什么？ 系统主题 我可以捕获设备上下线的事件吗？该如何使用？ 系统主题有何用处？都有哪些系统主题？ 消息队列 什么是 mqueue？如何配置 mqueue？ WebSocket 什么是 WebSocket？什么情况下需要通过 WebSocket 去连接 EMQ X 服务器？ ACL 我想限定某些主题只为特定的客户端所使用，EMQ X 该如何进行配置？ 发布订阅 我想限定某些主题只为特定的客户端所使用，EMQ X 该如何进行配置？ 共享订阅 什么是共享订阅？有何使用场景？ 流量控制 EMQ X 能做流量控制吗？ 离线消息 什么是离线消息？ 代理订阅 什么是代理订阅？使用场景是什么？ 性能 EMQ X 是如何实现支持大规模并发和高可用的？ 高并发 EMQ X 是如何实现支持大规模并发和高可用的？ 持久化 我可以把 MQTT 消息从 EMQ X 转发其他消息中间件吗？例如 RabbitMQ？ HTTP API 在服务器端能够直接断开一个 MQTT 连接吗？ Dashboard 在服务器端能够直接断开一个 MQTT 连接吗？ Kafka EMQ X 企业版中桥接 Kafka，一条 MQTT 消息到达 EMQ X 集群之后就回 MQTT Ack 报文还是写入 Kafka 之后才回 MQTT Ack 报文? 桥接 MQTT Broker（比如 Mosquitto）可以转发消息到 EMQ X 吗？ 配置 EMQ X 企业版中桥接 Kafka，一条 MQTT 消息到达 EMQ X 集群之后就回 MQTT Ack 报文还是写入 Kafka 之后才回 MQTT Ack 报文? 集群 EMQ X 支持集群自动发现吗？有哪些实现方式？ 我的连接数目并不大，EMQ X 生产环境部署需要多节点吗？ RabbitMQ 我可以把 MQTT 消息从 EMQ X 转发其他消息中间件吗？例如 RabbitMQ？ Mosquitto MQTT Broker（比如 Mosquitto）可以转发消息到 EMQ X 吗？ Trace 我想跟踪特定消息的发布和订阅过程，应该如何做？ 调试 为什么我做压力测试的时候，连接数目和吞吐量老是上不去，有系统调优指南吗？ EMQ X 安装之后无法启动怎么排查？ 性能测试 为什么我做压力测试的时候，连接数目和吞吐量老是上不去，有系统调优指南吗？ EMQ X 的百万连接压力测试的场景是什么？ TLS EMQ X 支持加密连接吗？推荐的部署方案是什么？ EMQ X中ssl resumption session的使用 加密连接 EMQ X 支持加密连接吗？推荐的部署方案是什么？ MySQL EMQ X 无法连接 MySQL 8.0 认证 EMQ X 无法连接 MySQL 8.0 指标 MQTT 客户端断开连接统计 .emqxee { display: none; }"},"changes/changes.html":{"url":"changes/changes.html","title":"变更日志","summary":null,"keywords":"","body":"版本发布4.1.3 版本emqx-managementemqx-retainer4.2-alpha.3 版本emqxemqx-auth-ldapemqx-retaineremqx-managementemqx-dashboardemqx-extension-hookemqx-exproto4.1.2 版本emqxemqx-rel4.2-alpha.2 版本emqx-statsdemqx-bridge-mqttemqx-lwm2memqx-retaineremqx-lua-hookemqx-web-hookemqx-auth-mysqlemqx-exproto4.1.1 版本emqx-retaineremqx-bridge-mqttemqx-relemqx-lua-hook4.2-alpha.1 版本emqxemqx-rule-engineemqx-relesockdgen_coapgen_rpc4.1.0 版本4.1-rc.2 版本emqxemqx-auth-mnesiaemqx-rule-engineemqx-relemqx-extension-java-sdkemqx-extension-python-sdk4.1-rc.1 版本emqxemqx-auth-mnesiaemqx-reloaderemqx-snemqx-web-hook4.0.7 版本emqxemqx-web-hook4.1-beta.1 版本emqxemqx-managementemqx-bridge-mqttemqx-statsdemqx-saslemqx-auth-jwtemqx-extension-hookemqx-dashboard4.0.6 版本emqxemqx-bridge-mqttemqx-rule-engine4.1-alpha.3 版本emqx-coapemqx-auth-mnesiaemqx-saslemqx-managementemqx-lwm2m4.1-alpha.2 版本emqxemqx-management (plugin)emqx-rel (build project)emqx-dashboard (plugin)emqx-extension-hook (plugin)4.1-alpha.1 版本emqxemqx-managementemqx-dashboard4.0.5 版本emqxemqx-rule-engine (plugin)emqx-sn (plugin)4.0.4 版本emqxemqx-dashboard (plugin)emqx-retainer (plugin)4.0.3 版本emqxemqx-management (plugin)4.0.2 版本emqxemqx-stomp (plugin)emqx-auth-redis (plugin)cowboy (dependency)4.0.1 版本emqxemqx-rule-engineemqx-web-hook4.0.0 版本4.0-rc.4 版本emqxemqx-bridge-mqttemqx-managementemqx-auth-http4.0-rc.3 版本emqxemqx-dashboard (plugin)emqx-management (plugin)emqx-coap (plugin)emqx-delayed-publish (plugin)emqx-statsd (plugin)emqx-bridge-mqtt (plugin)emqx-auth-http (plugin)All of Authentication Plugins4.0-rc.2 版本emqxemqx-retainer (plugin)emqx-dashboard (plugin)4.0-rc.1 版本emqxemqx-auth-username (plugin)emqx-auth-clientid (plugin)emqx-management (plugin)3.2.7 版本emqx-auth-username (plugin)emqx-auth-clientid (plugin)3.2.6 版本emqx (major)4.0-beta.4 版本emqx (major)emqx-management (plugin)minirest (plugin)esockd (dependency)ekka (dependency)3.2.5 版本emqx-rule-engine (plugin)minirest (plugin)emqx-web-hook (plugin)4.0-beta.3 版本emqx-management (plugin)emqx-dashboard (plugin)emqx-delayed-publish (plugin)3.2.4 版本emqx-auth-mysql (plugin)emqx-dashboard (plugin)emqx-management (plugin)emqx-delay-publish (plugin)emqx-rule-engine (plugin)4.0-beta.2 版本emqtt (plugin)emqx-sn (plugin)emqx-coap (plugin)4.0-beta.1 版本3.2.3 版本emqx-dashboard (plugin)3.2.2 版本emqx-rule-engine (plugin)emqx-dashboard (plugin)ekka (dependency)3.2.1 版本emqx-rule-engine (plugin)emqx-dashboard (plugin)emqx-lwm2m (plugin)emqx-rel (build project)3.2.0 版本规则引擎项目构建MQTT Broker 桥接HTTP 插件集群 (ekka)其他插件和依赖3.2-rc.3 版本emqx-web-hook (plugin)emqx-bridge-mqtt (plugin)emqx-rule-engine (plugin)emqx-dashboard (plugin)3.2-rc.2 版本emqx-rule-engine (plugin)emq-bridge-mqtt (plugin)emqx-rel (build project)3.2-rc.1 版本emqx-rule-engine (plugin)emqx-sn (plugin)emqx-auth-jwt (plugin)emqx-rel (build-project)3.2-beta.3 版本emqx-rule-engine (plugin)emqx-management (plugin)3.2-beta.2 版本emqx-rule-engine (plugin)emqx-auth-http (plugin)emqx-dockeremqx-management (plugin)ekka (deps)3.2-beta.1 版本emqx-rule-engine (plugin)emqx-web-hook (plugin)emqx-auth-http (plugin)emqx-sn (plugin)3.1.2 版本EMQ X Coreemqx-coap (plugin)ekka (deps)3.1.1 版本emqx-lwm2m (plugin)3.1.0 版本emqx-management (plugin)emqx-rule-engine (plugin)emqx-storm (plugin)3.1-rc.3 版本emqx-auth-mysql (plugin)emqx-statsd (plugin)emqx-web-hook (plugin)emqx-rule-engine (plugin)emqx-rel3.1-rc.2 版本emqx-auth-http (plugin)emqx-auth-username (plugin)emqx-auth-clientid (plugin)emqx-rule-engine (plugin)emqx-packages (plugin)emqx-dashboard (plugin)3.1-rc.1 版本emqx-auth-http (plugin)emqx-auth-clientid (plugin)emqx-auth-jwt (plugin)emqx-rule-engine (plugin)emqx-rel3.1-beta.3 版本emqx-rule-engine (plugin)emqx-lua-hook (plugin)emqx-auth-mysql (plugin)3.1-beta.2 版本emqx-management (plugin)emqx-auth-jwt (plugin)emqx-auth-usernmae (plugin)emqx-web-hook (plugin)minirest (deps)gen_rpc (deps)3.1-beta.1 版本emqx-auth-redisemqx-dashboardemqx-auth-usernameemqx-auth-clientid3.0.1 版本emqx-lwm2memqx-auth-usernameemqx-auth-clientidemqx-management3.0.0 版本emqx-auth-ldapemqx-lua-hookemqx-management3.0-rc.5 版本emqx-passwdemqx-web-hookemqx-dashboardemqx-management3.0-rc.4 版本emqx-coapemqx-managementekkaminirestcuttlefishemqx-rel3.0-rc.3 版本emqx-stompemqx-snemqx-lua-hookemqx-statsdemqx-dashboardemqx-auth-pgsql3.0-rc.2 版本3.0-rc.1 版本emqx-lwm2m3.0-Beta.4 版本emqx-delayed-publishemqx-passwdbcryptesockd3.0-Beta.3 版本emqx-managementemqx-web-hookemqx-dashboardemqx-retaineremqx-coapemqx-dockeresockd3.0-Beta.2 版本EMQ X Coreemqx-management (插件)emqx-delayed-publish (插件)minirest (依赖工程)emqx-rel (编译工程)3.0-Beta.1 版本全面支持 MQTT-5.0集群架构演进消息速率限制Feature improvements and Bug Fixes2.3.11 版本Bugfix and Enhancementsemq-auth-jwtemq-auth-mongo2.3.10 版本Bugfix and Enhancementsemq-auth-http2.3.9 版本Bugfix and Enhancementsesockd2.3.8 版本Bugfix and Enhancementsemq-auth-mongo2.3.7 版本Bugfix and Enhancementsemq-auth-http2.3.6 版本Bugfix and Enhancementsemq-auth-jwt2.3.5 版本Bugfix and Enhancementsemq-snemq-auth-http2.3.4 版本Bugfix and Enhancementsemq-sn2.3.3 版本Bugfix and Enhancementsemq-dashboardemq-modulesemq-dockeremq-packages2.3.2 版本Bugfix and Enhancementsesockdemq-auth-mysqlemq-relxemq-snemq-web-hook2.3.1 版本Bugfix and Enhancementsemq-retaineremq-dashboardemq-modulesemq-snemq-relxmochiweb2.3.0 版本 \"Passenger's Log\"Bugfix and Enhancementsemq-dashboard Plugin (emq-dashboard#PR174)emq-coap Plugin (emq-coap#PR61)emq-relxemq-web-hook Pluginemq-auth-jwt Plugin(emq-auth-jwt#PR15)emq-auth-mongo Plugin(emq-auth-mongo#PR92)2.3-rc.2 版本Bugfixemq-dashboard Plugin (emq-dashboard#164)2.3-rc.1 版本Bugfixemq-dashboard Plugin (emq-dashboard#154)2.3-beta.4 版本HighlightsBugfixemq-dashboardemq-coap2.3-beta.3 版本2.3-beta.3 版本EnhancementsBugfix2.3-beta.2 版本Enhancementsemq-sn Plugin (emq-sn#49)emq-auth-ldap Plugin (emq-auth-ldap#21)emq-coap Plugin (emq-coap#51)2.3-beta.1 版本节点发现与自动集群集群脑裂与自动愈合节点宕机与自动清除LWM2M协议支持JSON Web Token认证支持Retainer插件Debian 9 安装包Erlang/OTP R202.2 正式版 \"Nostalgia\"2.2-rc.2 版本问题与改进2.2-rc.1 版本问题与改进2.2-beta.3 版本问题与改进emq_auth_redis插件emq_auth_mongo插件文档更新2.2-beta.2 版本问题与改进Update READMEElixir Plugin2.2-beta.1 版本MQTT协议监听器配置Proxy Protocol V1/2支持Web Hook插件Lua Hook插件改进认证链设计支持bcrypt密码Hashetc/emq.conf配置变更emq-dashboard2.1.2 版本2.1.1 版本2.1.0 版本2.1.0-rc.2 版本2.1.0-rc.1 版本2.1.0-beta.2 版本2.1.0-beta.1 版本GC优化API改进问题修复2.1-beta 版本Client, Session统计信息新增missed统计指标Syslog日志集成Tune QoS支持'acl reload'管理命令配置项变更合并扩展模块到emq_modules项目Dashboard插件recon插件reloader插件2.0.7 版本2.0.6 版本2.0.5 版本2.0.4 版本2.0.3 版本2.0.2 版本2.0.1 版本2.0 正式版 \"西湖以西\"共享订阅(Shared Subscription)本地订阅(Local Subscription)erlang.mk与relxCoAP协议支持MQTT-SN协议支持'K = V'格式配置文件操作系统环境变量Docker镜像支持Windows平台支持问题与改进扩展插件2.0-rc.3 版本2.0-rc.3 版本2.0-rc.2 版本2.0-rc.1 版本2.0-beta.3 版本共享订阅(Shared Subscription)本地订阅(Local Subscription)问题修复2.0-beta.2 版本CoAP协议支持API Breaking ChangesBugfix2.0-beta.1 版本项目简称 - EMQ项目发布方式应用与发布erlang.mk与relxGit分支结构MQTT-SN协议支持改进插件架构2.0 版本项目文档发布订阅流程1.1.3 版本1.1.2 版本1.1.1 版本1.1 版本问题与改进Dashboard插件HTTP认证插件MongoDB认证插件MySQL认证插件Postgre认证插件Redis认证插件Reloader插件1.0.2 版本1.0.1 版本1.0 (七英里) 版本问题与改进项目文档官方站点致谢0.17.1-beta 版本EnhancementsDashboard0.17.0-beta 版本HighlightsEnhancementsTestsPlugins0.16.0-beta 版本HighlightsEnhancementsBugfix0.15.0-beta 版本HighlightsEnhancementsBugfixPlugins0.14.1-beta 版本0.14.0-beta 版本HighlightsEnhancementsBugfixBenchmark0.13.1-beta 版本0.13.0-beta 版本HighlightsEnhancementsBugfixBenchmark0.12.3-beta 版本0.12.2-beta 版本0.12.1-beta 版本0.12.0-beta 版本HighlightsEnhancementsBugfixBenchmark0.11.0-beta 版本0.10.4-beta 版本0.10.3-beta 版本0.10.2-beta 版本0.10.1-beta 版本0.10.0-beta 版本0.9.3-alpha 版本0.9.2-alpha 版本0.9.1-alpha 版本0.9.0-alpha 版本0.8.6-beta 版本0.8.5-beta 版本0.8.4-beta 版本0.8.3-beta 版本0.8.2-alpha 版本0.8.1-alpha 版本0.8.0-alpha 版本0.7.1-alpha 版本0.7.0-alpha 版本0.6.2-alpha 版本0.6.1-alpha 版本0.6.0-alpha 版本0.5.5-beta 版本0.5.4-alpha 版本0.5.3-alpha 版本0.5.2-alpha 版本0.5.1-alpha 版本0.5.0-alpha 版本0.4.0-alpha 版本0.3.4-beta 版本0.3.3-beta 版本0.3.2-beta 版本0.3.1-beta 版本0.3.0-beta 版本0.3.0-alpha 版本0.2.1-beta 版本0.2.0 版本0.1.5 版本0.1.4 版本0.1.3 版本0.1.2 版本0.1.1 版本0.1.0 版本版本发布 4.1.3 版本 发布日期: 2020-08-04 EMQ X 4.1.3 现已发布，主要包含以下改动: emqx-management 错误修复: 为 PUBLISH API 的 payload 字段增加类型检查 Github PR: emqx/emqx-management#250 emqx-retainer 错误修复: 修复订阅主题同时包含 '+' 和 '#' 不会下发保留消息的问题 Github PR: emqx/emqx-retainer#146 4.2-alpha.3 版本 发布日期: 2020-07-31 EMQ X 4.2-alpha.3 现已发布，主要包含以下改动: emqx 功能增强: 支持全局速率限制 Github PR: emqx/emqx#3613 重新设计的告警 Github PR: emqx/emqx#3632 错误修复: 修复没有使用主题别名替代主题的问题 Github PR: emqx/emqx#3617 emqx-auth-ldap 功能增强: 支持 IPv6 Github PR: emqx/emqx-auth-ldap#114 emqx-retainer 错误修复: 修复订阅主题同时包含 '+' 和 '#' 不会下发保留消息的问题 Github PR: emqx/emqx-retainer#147 emqx-management 功能增强: 重新设计的告警 API Github PR: emqx/emqx-management#244 emqx-dashboard 功能增强: 增加告警页面 Github PR: emqx/emqx-dashboard#245 emqx-extension-hook 功能增强: 不再支持 Python 2 Github PR: emqx/emqx-extension-hook#11 emqx-exproto 功能增强: 支持 Java 驱动 Github PR: emqx/emqx-exproto#5 4.1.2 版本 发布日期: 2020-07-23 EMQ X 4.1.2 现已发布，主要包含以下改动: emqx 错误修复: 修复没有使用主题别名替代主题的问题 Github PR: emqx/emqx#3616 修复某些操作占用过多 CPU 的问题 Github PR: emqx/emqx#3581 emqx-rel 错误修复: 修复以容器方式运行 emqx 时日志写满所有日志文件后控制台不再输出日志的问题 Github PR: emqx/emqx-rel#559 4.2-alpha.2 版本 发布日期: 2020-07-17 EMQ X 4.2-alpha.2 现已发布，主要包含以下改动: emqx-statsd 功能增强: 更名为 emqx-prometheus Github Repository: emqx/emqx-prometheus emqx-bridge-mqtt 功能增强: 支持在规则引擎中创建订阅资源 Github PR: emqx/emqx-bridge-mqtt#78 emqx-lwm2m 错误修复: 修复没有正确获取版本号的问题 Github PR: emqx/emqx-lwm2m#82 emqx-retainer 功能增强: 增强性能 Github PR: emqx/emqx-retainer#140 emqx-lua-hook 错误修复: 修复没有正确卸载 Lua 脚本和命令行接口的问题 Github PR: emqx/emqx-lua-hook#105 emqx-web-hook 功能增强: 支持配置自定义的 HTTP 请求头部 Github PR: emqx/emqx-web-hook#200 emqx-auth-mysql 功能增强: 支持 IPv6 Github PR: emqx/emqx-auth-mysql#228 emqx-exproto 功能增强: 支持使用多种编程语言开发任何定制协议 Github Repository: emqx/emqx-exproto 4.1.1 版本 发布日期: 2020-07-03 EMQ X 4.1.1 现已发布，主要包含以下改动: emqx-retainer 错误修复: 修复性能问题 Github PR: emqx/emqx-retainer#141 emqx-bridge-mqtt 错误修复: 将挂载点改为可选配置 Github PR: emqx/emqx-bridge-mqtt#84 emqx-rel 错误修复: 屏蔽 docker 运行时输出的控制台日志中的敏感信息 Github Issue: emqx/emqx-rel#524 Github PR: emqx/emqx-rel#542 Thanks: emqx/emqx-rel#525 - daadu emqx-lua-hook 错误修复: 修复插件卸载时没有卸载脚本和 CLI 的问题 Github PR: emqx/emqx-lua-hook#106 4.2-alpha.1 版本 发布日期: 2020-06-20 EMQ X 4.2-alpha.2 现已发布，主要包含以下改动: emqx 功能增强: 支持 Response Information Github PR: emqx/emqx#3533 错误修复: 修复连接属性为空时导致连接进程崩溃的问题 Github PR: emqx/emqx#3525 emqx-rule-engine 功能增强: 为规则引擎事件增加 MQTT 属性字段以及与规则相关的元数据 Github PR: emqx/emqx-rule-engine#163 emqx-rel 功能增强: 支持 CentOS 8 Github PR: emqx/emqx-rel#526 支持 Ubuntu 20.04 Github PR: emqx/emqx-rel#521 esockd 错误修复: 修复 max_conn_rate 配置的错误类型 Github PR: emqx/esockd#161 gen_coap 功能增强: 使用 esockd 替换 gen_udp Github PR: emqx/gen_coap#12 gen_rpc 错误修复: 修复 acceptor 在某些情况下发生崩溃的问题 Github PR: emqx/gen_rpc#9 4.1.0 版本 发布日期: 2020-06-04 EMQ X 4.1.0 现已发布，主要包含以下改动： 功能增强: 支持多语言扩展并提供 SDK，已支持语言：Python, Java 支持基于主题的指标统计 支持插件启动时加载最新配置 支持消息转发时使用主题别名 代理订阅支持配置所有订阅选项 支持客户端列表的模糊查询和多条件查询 支持订阅列表的模糊查询 支持通过 Dashboard 添加简单的认证信息 支持跨版本数据迁移 支持 MQTT AUTH 报文，目前仅支持 SCRAM-SHA-1 认证机制，支持用户自行扩展 支持使用代理协议时获取网络地址与端口 增加基于 Mnesia 数据库的认证插件（在后续版本中完全替代 emqx-auth-clientid 与 emqx-auth-username 插件） 支持编辑规则引擎中的规则 通过 Docker 运行 EMQ X 时支持注释配置项 LwM2M 网关插件支持 IPv6 和同时监听多个端口 CoAP 网关插件支持 IPv6 JWT 认证插件支持配置 jwerl 签名格式 错误修复: 修复 etc/emqx.conf 为只读文件时 EMQ X 无法启动的问题 修复连接进程在某些情况下出错崩溃的问题 修复浏览器不支持当前 SSL/TLS 证书的问题 修复 MQTT 桥接插件默认情况下不会发送心跳包的问题 修复异常登录检测功能没有删除过期数据导致内存增长的问题 修复内置 ACL 模块重新加载时没有清除 ACL 缓存的问题 修复 WebHook 插件中 client.disconnected 事件在某些情况下出错的问题 修复 MQTT-SN 网关插件不支持指定监听 IP 地址的问题并支持 IPv6 4.1-rc.2 版本 发布日期: 2020-05-23 EMQ X 4.1-rc.2 现已发布，主要包含以下改动： emqx 错误修复: 修复客户端在发送 CONNECT 报文前发送其他报文导致崩溃的问题 Github PR: emqx/emqx#3476 emqx-auth-mnesia 功能增强: 支持全局 ACL 规则 Github PR: emqx/emqx-auth-mnesia#13 emqx-rule-engine 错误修复: 修复资源不可用时无法导入规则的问题，以及修复导入规则后某些情况下无法启用的问题 Github Commit: emqx-rule-engine#582de5 emqx-rel 功能增强: 通过 Docker 运行 EMQ X 时支持注释配置项 Github PR: emqx/emqx-rel#508 emqx-extension-java-sdk 功能增强: 为多语言扩展增加 Java SDK Github Repository: emqx/emqx-extension-java-sdk emqx-extension-python-sdk 功能增强: 为多语言扩展增加 Python SDK Github Repository: emqx/emqx-extension-python-sdk 4.1-rc.1 版本 发布日期: 2020-05-15 EMQ X 4.1-rc.1 现已发布，主要包含以下改动： emqx 错误修复: 修复浏览器不支持当前 SSL/TLS 证书的问题 Github PR: emqx/emqx#3447 修复连接进程在某些情况下出错崩溃的问题 Github PR: emqx/emqx#3459 emqx-auth-mnesia 错误修复: 修复配置的用户无法通过认证的问题 Github PR: emqx/emqx-auth-mnesia#6 修复没有正确处理错误的问题 Github PR: emqx/emqx-auth-mnesia#9 emqx-reloader 错误修复: 修复某些情况下不会重新加载模块代码的问题 Github PR: emqx/emqx-reloader#73 emqx-sn 错误修复: 修复不支持指定监听 IP 地址的问题并支持 IPv6 Github PR: emqx/emqx-sn#158 emqx-web-hook 错误修复: 修复 client.disconnected 事件在某些情况下出错的问题 Github PR: emqx/emqx-web-hook#188 4.0.7 版本 发布日期: 2020-05-09 EMQ X 4.0.7 现已发布，主要包含以下改动： emqx 错误修复: 修复浏览器不支持当前 SSL/TLS 证书的问题 Github PR: emqx/emqx#3448 修复连接进程在某些情况下出错崩溃的问题，感谢 Github issue#3455 的反馈 Github PR: emqx/emqx#3458 emqx-web-hook 错误修复: 修复 client.disconnected 事件在某些情况下出错的问题 Github PR: emqx/emqx-web-hook#187 4.1-beta.1 版本 发布日期: 2020-04-26 EMQ X 4.1-beta.1 现已发布，主要包含以下改动： emqx 错误修复: 修复 flapping 检查没有删除过期数据的问题 Github PR: emqx/emqx#3406 修复内置 ACL 模块重新加载时没有清除 ACL 缓存的问题 Github PR: emqx/emqx#3409 emqx-management 错误修复: 修复错误的时间戳单位 Github PR: emqx/emqx-management#203 emqx-bridge-mqtt 错误修复: 修复没有发送 PINREQ 报文导致连接断开的问题 Github PR: emqx/emqx-bridge-mqtt#68 emqx-statsd 错误修复: 修复没有获取 EMQ X Broker 指标的问题 Github PR: emqx/emqx-statsd#55 emqx-sasl 功能增强: 支持服务端认证 Github PR: emqx/emqx-sasl#3 错误修复: 修复 SCRAM-SHA-1 认证算法不可用的问题 Github PR: emqx/emqx-sasl#2 emqx-auth-jwt 功能增强: 支持配置 jwerl 签名格式 Github PR: emqx/emqx-auth-jwt#117 emqx-extension-hook 功能增强: 增加 Java 支持 Github PR: emqx/emqx-extension-hook#2 emqx-dashboard 功能增强: 支持内部模块管理 Github PR: emqx/emqx-dasboard#225 支持规则编辑 Github PR: emqx/emqx-dasboard#227, emqx/emqx-dasboard#230 4.0.6 版本 发布日期: 2020-04-22 EMQ X 4.0.6 现已发布，主要包含以下改动： emqx 错误修复: 修复 flapping 检查没有删除过期数据的问题 Github PR: emqx/emqx#3407 修复使用 WebSocket 时 Proxy Protocol 功能无法使用的问题 Github PR: emqx/emqx#3372 emqx-bridge-mqtt 错误修复: 修复默认情况不会发送心跳包的问题 Github PR: emqx/emqx-bridge-mqtt#67 emqx-rule-engine 错误修复: 修复规则引擎时间戳的错误类型 Github Commit: emqx/emqx-rule-engine#27ca37 修复规则引擎测试 SQL 语句功能 Github Commit: emqx/emqx-rule-engine#33fcba 4.1-alpha.3 版本 发布日期: 2020-04-17 EMQ X 4.1-alpha.3 现已发布，主要包含以下改动： emqx-coap 功能增强: 支持 IPv6 Github PR: emqx/emqx-coap#167 emqx-auth-mnesia 功能增强: 增加基于 Mnesia 数据库的认证插件 Github PR: emqx/emqx-auth-mnesia#1 emqx-sasl 功能增强: 支持 SCRAM-SHA-1 认证算法 Github Repository: emqx/emqx-sasl emqx-management 功能增强: 支持返回所有的 Topic Metrics Github PR: emqx/emqx-management#197 emqx-lwm2m 功能增强: 支持 IPv6 和同时监听多个端口 Github PR: emqx/emqx-lwm2m#78 4.1-alpha.2 版本 发布日期: 2020-04-11 EMQ X 4.1-alpha.2 现已发布. emqx 功能增强: 支持使用代理协议时获取网络地址与端口 Github PR: emqx/emqx#3372 支持 MQTT AUTH 报文（尚未支持认证算法） Github PR: emqx/emqx#3374 emqx-management (plugin) 功能增强: 优化主题统计指标的 HTTP APIs Github PR: emqx/emqx-management#189 支持跨版本数据迁移 Github PR: emqx/emqx-management#190 支持订阅的模糊搜索 Github PR: emqx/emqx-management#191 为内部模块增加 HTTP APIs 和 CLIs Github PR: emqx/emqx-management#193 emqx-rel (build project) 错误修复: 修复 etc/emqx.conf 为只读文件时 emqx 无法启动的问题 Github issue: emqx/emqx-rel#479 Github PR: emqx/emqx-rel#480 emqx-dashboard (plugin) 错误修复: 修复无法删除用户的问题 Github PR: emqx/emqx-dashboard#219 emqx-extension-hook (plugin) 功能增强: 支持多语言扩展，目前仅支持 Python Github Repository: emqx/emqx-extension-hook 4.1-alpha.1 版本 发布日期: 2020-03-27 EMQ X 4.1-alpha.1 现已发布，主要包括以下改动: emqx 功能增强: 支持主题指标统计 Github PR: emqx/emqx#3341 插件启动时加载最新配置 Github PR: emqx/emqx#3335 支持消息转发时使用主题别名 Github PR: emqx/emqx#3344 延迟发布功能现通过内部模块提供 Github PR: emqx/emqx#3323 移除插件信息中的版本字段 Github PR: emqx/emqx#3335 代理订阅支持设置所有订阅选项 Github PR: emqx/emqx#3307 emqx-management 功能增强: 为主题指标通知增加 HTTP APIs Github PR: emqx/emqx-management#183 支持模糊查询和多条件查询 Github PR: emqx/emqx-management#182 emqx-dashboard 功能增强: 支持通过 Dashboard 添加简单的认证信息 Github PR: emqx/emqx-dashboard#182 4.0.5 版本 发布日期: 2020-03-17 EMQ X 4.0.5 现已发布。此版本主要进行了错误修复。 emqx 错误修复: 修复 GC 策略 Github PR: emqx/emqx#3317 修复了 Maximum-QoS 属性的值设置错误的问题 Github issue: emqx/emqx#3304, emqx/emqx#3315 Github PR: emqx/emqx#3321 修复了 EMQ X 运行在 Docker 环境中时 CPU 占用率每隔 15 秒异常升高的问题 Github issue: emqx/emqx#3274 Github PR: emqx/emqx-rel#462 修复配置文件中 node.* 配置项不生效的问题 Github issue: emqx/emqx#3302 Github PR: emqx/emqx-rel#463 emqx-rule-engine (plugin) 错误修复: 修复规则引擎不支持 Payload 为 utf-8 字符串的问题 Github issue: emqx/emqx#3287 Github PR: emqx/emqx#3299 emqx-sn (plugin) 错误修复: 修复 MQTT-SN 订阅丢失的问题 Github issue: emqx/emqx#3275 Github PR: emqx/emqx-sn#156 4.0.4 版本 发布日期: 2020-03-06 EMQ X 4.0.4 现已发布。此版本主要进行了\b\b\b\b错误修复。 emqx 错误修复: 修复 acl_deny_action 配置项不生效的问题 Github issue: emqx/emqx#3266 Github PR: emqx/emqx#3286 修复 mountpoint 配置项的错误类型 Github issue: emqx/emqx#3271 Github PR: emqx/emqx#3272 修复 peer_cert_as_username 配置项不生效的问题 Github issue: emqx/emqx#3281 Github PR: emqx/emqx#3291 修复连接正常关闭后仍打印错误日志的问题 Github PR: emqx/emqx#3290 emqx-dashboard (plugin) 错误修复: 修复 Dashboard 节点下拉列表中显示空白的问题 Github issue: emqx/emqx#3278 Github PR: emqx/emqx-dashboard#206 emqx-retainer (plugin) 错误修复: 保留消息达到最大存储数量后的行为由无法存储任何保留消息更正为可以替换已存在主题的保留消息 Github PR: emqx/emqx-retainer#136 4.0.3 版本 发布日期: 2020-02-21 EMQ X 4.0.3 现已发布。此版本主要进行了\b\b\b\b错误修复。 emqx 功能增强: 添加允许客户端绕过认证插件登录的选项 Github PR: emqx/emqx#3253 错误修复: 修复某些竞争条件下会打印不必要的错误日志的问题 Github PR: emqx/emqx#3246 emqx-management (plugin) 错误修复: 移除不再使用的字段和函数以及修复字段值异常的问题 Github PR: emqx/emqx-management#176 修复集群环境下无法获取客户端列表的问题 Github PR: emqx/emqx-management#173 修复 HTTPS 监听选项 Github PR: emqx/emqx-management#172 修复应用列表的返回格式 Github PR: emqx/emqx-management#169 4.0.2 版本 发布日期: 2020-02-07 EMQ X 4.0.2 现已发布。此版本主要进行了\b\b\b\b错误修复和性能优化。 emqx 功能增强: 提升 Json 编解码性能 Github PR: emqx/emqx#3213, emqx/emqx#3230, emqx/emqx#3235 压缩生成的项目大小 Github PR: emqx/emqx#3214 错误修复: 修复某些情况下没有发送 DISCONNECT 报文的问题 Github PR: emqx/emqx#3208 修复收到相同 PacketID 的 PUBLISH 报文时会断开连接的问题 Github PR: emqx/emqx#3233 emqx-stomp (plugin) 错误修复: 修复最大连接数限制不生效的问题 Github PR: emqx/emqx-stomp#93 emqx-auth-redis (plugin) 错误修复: 修复内部模块启动失败的问题 Github PR: emqx/emqx-auth-redis#151 cowboy (dependency) 错误修复: 修复 Websocket 连接某些情况下不会发送遗嘱消息的问题 Github Commit: emqx/cowboy#3b6bda 4.0.1 版本 发布日期: 2020-01-17 EMQ X 4.0.1 现已发布。此版本主要进行了\b\b\b\b错误修复和性能优化。 emqx 功能增强: force_shutdown_policy 默认关闭 Github PR: emqx/emqx#3184 支持定时全局 GC 并提供配置项 Github PR: emqx/emqx#3190 优化 force_gc_policy 的默认配置 Github PR: emqx/emqx#3192, emqx/emqx#3201 优化 Erlang VM 参数配置 Github PR: emqx/emqx#3195, emqx/emqx#3197 错误修复: 修复使用错误的单位导致黑名单功能异常的问题 Github PR: emqx/emqx#3188 修复对 Retain As Publish 标志位的处理并且在桥接模式下保持 Retain 标识位的值 Github PR: emqx/emqx#3189 修复无法使用多个 Websocket 监听端口的问题 Github PR: emqx/emqx#3196 修复会话 takeover 时 EMQ X 可能不发送 DISCONNECT 报文的问题 Github PR: emqx/emqx#3208 emqx-rule-engine 功能增强: 提供更多操作数组的 SQL 函数 Github PR: emqx/emqx-rule-engine#136 减少未配置任何规则时对性能的影响 Github PR: emqx/emqx-rule-engine#138 emqx-web-hook 错误修复: 修复参数不匹配导致的崩溃问题 Github PR: emqx/emqx-web-hook#167 4.0.0 版本 发布日期: 2020-01-10 EMQ X 4.0.0 正式版现已发布。在这个版本中，我们通过重构 channel 和 session 显著地改进了吞吐性能，通过添加更多的钩子和统计指标增强了可扩展性，重新设计了规则引擎的 SQL，并优化 Edge 版本的性能表现。 常规 功能增强: 架构优化，大幅提高消息吞吐性能，降低了 CPU 与内存占用 改进 MQTT 5.0 报文处理流程 规则引擎支持全新的 SQL 语句 调整 metrics 命名并增加更多的 metrics 调整钩子参数并增加更多的钩子 emqtt 提供发布与订阅的命令行接口 错误修复: 修复了 SSL 握手失败导致崩溃的问题 修复 max_subscriptions 配置不生效的问题 修复跨集群转发消息失序的问题 修复命令行接口无法获取单个主题的多条路由信息的问题 REST API 功能增强: 支持 IPv6 REST API 默认监听端口由 8080 改为 8081，减少被其他应用占用的情况 移除所有 sessions 相关的接口 connections 调整为 clients，并提供原先 sessions 的功能 支持订阅查询接口返回共享订阅的真实主题 支持配置默认的 AppID 与 AppSecret 发布消息的 REST API 支持使用 base64 编码的 payload 错误修复: 修复转码后的 URI 没有被正确处理的问题 认证 功能增强: HTTP 认证插件支持用户配置自定义的 HTTP 请求头部 clientid 与 username 认证插件重新支持用户通过配置文件配置默认的 clientid 与 username 4.0-rc.4 版本 发布日期: 2019-12-31 EMQ X 4.0-rc.4 版本现已发布，其中包括以下更改: emqx 功能增强: 增加了更多的钩子 Github PR: emqx/emqx#3138 增加了更多的 metrics Github PR: emqx/emqx#3139, emqx/emqx#3141 错误修复: 修复定时器超时消息可能匹配失败的问题 Github PR: emqx/emqx#3145 emqx-bridge-mqtt 错误修复: 修复 keepalive 配置项使用了错误的单位的问题 Github PR: emqx/emqx-bridge-mqtt#43 emqx-management 功能增强: 支持配置默认的 AppID 与 AppSecret Github PR: emqx/emqx-management#153 发布消息的 HTTP API 现以支持 base64 编码后的 payload Github PR: emqx/emqx-management#154 emqx-auth-http 功能增强: 支持用户自行配置 HTTP 请求头 Github PR: emqx/emqx-auth-http#170 4.0-rc.3 版本 发布日期: 2019-12-21 EMQ X 4.0-rc.3 版本现已发布，其中包括以下更改: emqx 功能增强: 添加更多的 Metrics; 并删除 channel.gc, messages.qos2.expired, messages.qos2.dropped, auth.mqtt.anonymous 等 Github PR: emqx/emqx#3128 日志格式支持配置行号 Github PR: emqx/emqx#3117 为 emqx_connection 增加更多的测试用例 Github PR: emqx/emqx#3116 修复 MQTT/WS 消息乱序的 BUG Github PR: emqx/emqx#3115 emqx-dashboard (plugin) 进行了以下更改: 优化 SQL 编辑器使用体验: Github PR: emqx/emqx-dashboard#176, emqx/emqx-dashboard#177 优化 Overview 页面显示 Github PR: emqx/emqx-dashboard#179 emqx-management (plugin) 进行了以下更改: 支持返回共享订阅的真实主题 Github PR: emqx/emqx-management#151 错误修复: 修复无法获取单个主题的多条路由信息的问题 Github PR: emqx/emqx-management#150 emqx-coap (plugin) 错误修复: 修复停止插件后，无法正常启动的问题 Github PR: emqx/emqx-coap#151 emqx-delayed-publish (plugin) 进行了以下更改: 新增 messages.delayed Metrics 计数 Github PR: emqx/emqx-delayed-publish#55 emqx-statsd (plugin) 进行了以下更改: 对新的 Metrics 进行适配 Github PR: emqx/emqx-statsd#43 emqx-bridge-mqtt (plugin) 进行了以下修复: 修正 Keepalive 单位为秒 Github PR: emqx/emqx-bridge-mqtt#43 emqx-auth-http (plugin) 进行了以下更改: 支持 '%p' 占位符，以获取客户端所连接的端口 Github PR: emqx/emqx-auth-http#167 All of Authentication Plugins 进行了以下更改: 重命名认证成功或失败的计数 Metrics 的前缀为 client.auth.; 重命名 ACL 检查成功或失败的 Metrics 前缀为 client.acl. Github PR: emqx/emqx-auth-username#132, emqx/emqx-auth-clientid#127, emqx/emqx-auth-http#168, emqx/emqx-auth-jwt#107, emqx/emqx-auth-ldap#96, emqx/emqx-auth-mongo#197, emqx/emqx-auth-mysql#193, emqx/emqx-auth-pgsql#174, emqx/emqx-auth-redis#144 4.0-rc.2 版本 发布日期: 2019-12-16 EMQ X 4.0-rc.2 版本现已发布，其中包括以下更改: emqx 功能增强: 为更多模块增加测试用例，提升原有测试用例的测试覆盖率 Github PR: emqx/emqx#3091, emqx/emqx#3095, emqx/emqx#3096, emqx/emqx#3100, emqx/emqx#3106, emqx/emqx#3107 Get the timestamp uniformly by erlang:system_time Github PR: emqx/emqx#3088, emqx/emqx#3089 移除 sessions.persistent.count 与 sessions.persistent.max 计数 Github PR: emqx/emqx#3111 WebSocket 支持会话机制 Github PR: emqx/emqx#3106, emqx/cowboy#1, emqx/cowboy#3 emqx-retainer (plugin) 错误修复: 存在大量保留消息时 EMQ X 不能及时向客户端回复 SUBACK Github PR: emqx/emqx-retainer#126 emqx-dashboard (plugin) 进行了以下更改: 客户端列表增加 IP 字段，不需要进入详情才能查看 Github PR: emqx/emqx-dashboard#172 4.0-rc.1 版本 发布日期: 2019-12-07 EMQ X 4.0-rc.1 版本发布。此版本主要优化了内部模块和 MQTT 报文处理流程。 emqx 功能增强: 优化 MQTT 报文优化逻辑 Github PR: emqx/emqx#3079, emqx/emqx#3082, emqx/emqx#3083 emqx-auth-username (plugin) 功能增强: 重新支持通过配置文件配置默认的 username Github PR: emqx/emqx-auth-username#126 emqx-auth-clientid (plugin) 功能增强: 重新支持通过配置文件配置默认的 clientid Github PR: emqx/emqx-auth-clientid#122 emqx-management (plugin) 功能增强: HTTP API 服务器默认监听端口由 8080 改为 8081 Github PR: emqx/emqx-management#144 3.2.7 版本 发布日期: 2019-12-03 EMQ X 3.2.7 版本发布。此版本主要重新支持了通过配置文件配置默认的 username 和 clientid。 emqx-auth-username (plugin) 功能增强: 重新支持了通过配置文件配置默认的 username Github PR: emqx/emqx-auth-username#127 emqx-auth-clientid (plugin) 功能增强: 重新支持了通过配置文件配置默认的 clientid Github PR: emqx/emqx-auth-clientid#123 3.2.6 版本 发布日期: 2019-11-23 EMQ X 3.2.6 版本发布。此版本主要关注功能改进和错误修复。 emqx (major) 错误修复: 修复通过 gen_rpc 向远程节点转发消息时可能失序的问题 Github PR: emqx/emqx#3049 修复认证插件崩溃会导致 emqx \b\b崩溃的问题 Github PR: emqx/emqx#3048 4.0-beta.4 版本 发布日期: 2019-11-18 EMQ X 4.0-beta.4 版本发布。此版本主要关注功能改进和错误修复。 emqx (major) 功能增强: 被检测到 flapping 的客户端会被 banned Github PR: emqx/emqx#3033 优化 emqx_vm 模块并更新测试用例 Github PR: emqx/emqx#3034 emqx-management (plugin) 功能增强: 更新 banned API Github PR: emqx/emqx-management#141 错误修复: 修复一些错误的返回值 Github PR: emqx/emqx-management#142 minirest (plugin) 错误修复: 添加错误处理并增加日志 Github PR: emqx/minirest#20 esockd (dependency) 功能增强: 调整部分接口并增加测试用例 Github PR: emqx/esockd#124 ekka (dependency) 功能增强: 调整部分接口并增加测试用例 Github PR: emqx/ekka#67 3.2.5 版本 发布日期: 2019-11-15 EMQ X 3.2.5 版本发布。此版本主要进行了错误修复。 emqx-rule-engine (plugin) 错误修复: 支持 SQL 关键字: FOREACH/DO/INCASE Github Commit: emqx/emqx-rule-engine#a962e3 支持 SQL 关键字: CASE/WHEN Github Commit: emqx/emqx-rule-engine#40e68e 支持在 SQL 的 WHERE 子句中比较原子与二进制 Github Commit: emqx/emqx-rule-engine#b240cc 修复 select 和 foreach 中的列验证失败 Github Commit: emqx/emqx-rule-engine#6a1267 修复重建规则时出现竞争的问题 Github Commit: emqx/emqx-rule-engine#af8967 修复重发消息时没有确证设置标志的问题 Github Commit: emqx/emqx-rule-engine#60e45c minirest (plugin) 错误修复: 修复日志没有记录错误数据的问题 Github PR: emqx/minirest#20 emqx-web-hook (plugin) 错误修复: 修复错误的匹配 Github Commit: emqx/emqx-web-hook#3dd041 4.0-beta.3 版本 发布日期: 2019-11-01 EMQ X 4.0-beta.3 版本发布。此版本主要针对错误修复以及测试覆盖率提升。 错误修复: 修复跨集群转发时消息失序的问题 Github PR: emqx/emqx#3000 emqx-management (plugin) 功能增强: REST API 支持 IPv6 Github PR: emqx/emqx-management#135 错误修复: 修复转码后的 URI 没有被正确处理的问题 Github PR: emqx/emqx-management#137 emqx-dashboard (plugin) 功能增强: 支持使用 IPv6 访问 Dashbaord Github PR: emqx/emqx-dashboard#162 emqx-delayed-publish (plugin) 错误修复: 修复插件在集群环境下只能在一个节点中开启的问题 Github PR: emqx/emqx-delay-publish#50 修复延迟发布消息失序的问题，感谢 soldag 的贡献 Github PR: emqx/emqx-delay-publish#49 Github Issue: emqx/emqx-delay-publish#15 3.2.4 版本 发布日期: 2019-10-28 EMQ X 3.2.4 版本发布。此版本主要为 Dashbaord 和 REST API 添加了 IPv6 支持，并修复了一些错误。 错误修复: 修复 max_subscriptions 配置不生效的问题 Github PR: emqx/emqx#2922 Github Issue: emqx/emqx#2908 emqx-auth-mysql (plugin) 错误修复: 使用占位符时更安全地取值 Github PR: emqx/emqx-auth-mysql#180 Github Issue: emqx/emqx#2937 emqx-dashboard (plugin) 功能增强: 支持使用 IPv6 访问 Dashbaord Github PR: emqx/emqx-dashboard#161 emqx-management (plugin) 功能增强: REST API 支持 IPv6 Github PR: emqx/emqx-management#134 emqx-delay-publish (plugin) 错误修复: 修复延迟发布消息失序的问题，感谢 soldag 的贡献 Github PR: emqx/emqx-delay-publish#48 Github Issue: emqx/emqx-delay-publish#15 emqx-rule-engine (plugin) 功能增强: 优化规则引擎中 JSON Payload 解析语句 Github Repository: emqx/emqx-rule-engine 4.0-beta.2 版本 发布日期: 2019-10-12 EMQ X 4.0-beta.2 版本发布。此版本主要针对错误修复以及继续优化内部模块设计。 错误修复: 修复 SSL 握手失败导致崩溃的问题 Github PR: emqx/emqx#2963 检查 PUBLISH 报文的主题层级 Github PR: emqx/emqx#2964 emqtt (plugin) 功能增强: 提供命令行接口 Github PR: emqx/emqtt#91 emqx-sn (plugin) 错误修复: 适配 MQTT-SN 插件到 4.0 版本 Github PR: emqx/emqx-sn#145 emqx-coap (plugin) 错误修复: 适配 CoAP 插件到 4.0 版本 Github Commit: emqx/emqx-coap#c7c175, emqx/emqx-coap#9b8ede 4.0-beta.1 版本 发布日期: 2019-09-30 EMQ X 4.0-beta.1 版本发布。此版本主要针对内部模块进行重新设计，实现吞吐大幅度提升。 3.2.3 版本 发布日期: 2019-09-16 EMQ X 3.2.3 版本改动主要为错误修复。 错误修复: 修复 emqx 容器运行时 CPU 占用率告警异常的问题 GitHub Commit: emqx/emqx#9cdaa7 修复消息过期机制不生效的问题 Github Commit: emqx/emqx#31671f 修复占位符在 mountpoint 中不生效的问题 Github Commit: emqx/emqx#58ba22 emqx-dashboard (plugin) 错误修复: 修复 SSL 无法使用的问题 Github Commit: emqx/emqx-dashboard#272a42 3.2.2 版本 发布日期: 2019-08-03 EMQ X 3.2.2 版本改动主要为错误修复。 功能增强: 扩展 gen_rpc 配置 Github PR: emqx/emqx#2732 emqx-rule-engine (plugin) 错误修复: 修复测试 URL 连通性的问题 Github PR: emqx/emqx-rule-engine#88 emqx-dashboard (plugin) 功能增强: 增加帮助页面 ekka (dependency) 错误修复: 修复释放锁可能导致崩溃的问题 Github PR: emqx/ekka#60 3.2.1 版本 发布日期: 2019-07-20 EMQ X 3.2.1 版本改动主要包括错误修复与性能增强。 功能增强: 优化 gen_rpc 的调用 Github PR: emqx/emqx#2694 支持使用 hostname 自动发现 k8s 集群 Github PR: emqx/emqx#2699 将默认 uptime 心跳时间改为 30s Github PR: emqx/emqx#2696 错误修复: 修复 WebSocket 非正常下线时出现 crash 的问题 Github PR: emqx/emqx#2697 修复 Session 异常关闭时，ws_channel 仍然在线的问题 Github PR: emqx/emqx#2704 emqx-rule-engine (plugin) 功能增强: 增强 republish 动作参数 Github PR: emqx/emqx-rule-engine#81 错误修复: 修复使用 '.' 筛选 payload 字段失败的问题 Github PR: emqx/emqx-rule-engine#83 emqx-dashboard (plugin) 错误修复: 修复 Dashboard 资源列表在 Safari 下渲染错误的问题 Github PR: emqx/emqx-dashboard#124, emqx/emqx-dashboard#125, emqx/emqx-dashboard#126 emqx-lwm2m (plugin) 功能增强: 兼容 LwM2M 1.1 版本客户端登录 Github Commit: emqx/emqx-lwm2m#1c03bf emqx-rel (build project) 功能增强: 内置 rebar3 脚本 Github PR: emqx/emqx-rel#394 EMQ X Windows 服务延迟启动 Github PR: emqx/emqx-rel#395 3.2.0 版本 发布日期: 2019-07-12 EMQ X 3.2.0 版本主要优化和改进了规则引擎。 规则引擎 改进规则引擎功能和规则管理界面(Dashboard)，支持更多动作。 项目构建 改用 rebar3 构建项目。 MQTT Broker 桥接 将 MQTT bridge 从 emqx 项目分离出来作为一个独立的插件，并提升了 RPC bridge 的性能。 HTTP 插件 支持 HTTPs。 集群 (ekka) 改善集群稳定性。 其他插件和依赖 修复 Windows 服务注册问题。 3.2-rc.3 版本 发布日期: 2019-07-06 EMQ X 3.2-rc.3 版本改动主要包括功能增强与错误修复。 错误修复: 修复 emqx/emqx: issue#2635 Github PR: emqx/emqx#2663 emqx-web-hook (plugin) 错误修复: 修复 actions.failure 无计数的问题 Github PR: emqx/emqx-web-hook#137 emqx-bridge-mqtt (plugin) 功能增强: 增加桥接模式选项 Github PR: emqx/emqx-bridge-mqtt#6 优化 RPC 消息的应答机制 支持规则引擎下的 MQTT/RPC Bridge 缓存消息到本地磁盘队列 修复规则引擎下的 RPC Bridge 无法桥接远程 EMQ X 节点的问题 Github PR: emqx/emqx-bridge-mqtt#7 emqx-rule-engine (plugin) 功能增强: Rule 与 Resource 的 API 支持集群 Github PR: emqx/emqx-rule-engine#75 新增返回触发事件的可用字段的 API Github PR: emqx/emqx-rule-engine#74, emqx/emqx-rule-engine#77 错误修复: 修复获取资源状态超时引起的问题 Github PR: emqx/emqx-rule-engine#76 emqx-dashboard (plugin) 功能增强: 规则引擎各项指标细分到节点 Github PR: emqx/emqx-dashboard#114 错误修复: 修复资源创建的 BUG Github PR: emqx/emqx-dashboard#114 3.2-rc.2 版本 发布日期: 2019-06-29 EMQ X 3.2-rc.2 版本改动主要包括错误修复。 功能增强: 把默认日志级别改为 warning Github PR: emqx/emqx#2657 增加获取历史告警的接口 Github PRs: emqx/emqx#2660 emqx/emqx-management#98 错误修复: 删除残留的 Session 记录 Github PR: emqx/emqx#2655 解决批量发送时，消息失序的问题 Github PR: emqx/emqx#2650 感谢 tradingtrace 的贡献! emqx-rule-engine (plugin) 功能增强: 新增一个动作 \"do nothing\" Github PR: emqx/emqx-rule-engine#70 将 retain flag 的数据类型改为 integer Github RP: emqx/emqx-rule-engine#72 错误修复: 修复 SQL 中无法使用 timestamp 关键字作为字段的问题 Github PR: emqx/emqx-rule-engine#71 emq-bridge-mqtt (plugin) 功能增强: 将 MQTT bridge 从 emqx 项目分离出来作为一个独立的插件 Github PR: emqx/emqx-bridge-mqtt#2 emqx-rel (build project) 错误修复: 解决 windows 服务注册的问题 Github PR: emqx/emqx-rel#381 3.2-rc.1 版本 发布日期: 2019-06-22 EMQ X 3.2-rc.1 版本发布。此版本改动主要包括功能增强与错误修复。 功能增强: 支持设置日志前缀 Github PR: emqx/emqx#2627 提升 connect/disconnect 系统消息中客户端上下线的时间戳精度 Github PR: emqx/emqx#2641 优化开发流程，支持 make run Github PR: emqx/emqx#2644 错误修复: 修复 flapping 模块无法正确读取配置的问题 Github PR: emqx/emqx#2628 修复 cpu_sup:util/0 在 Windows 环境不可用导致崩溃的问题 Github PR: emqx/emqx#2629 修复 emqx/emqx: issue#2619 Github PR: emqx/emqx#2646 emqx-rule-engine (plugin) 功能增强: 支持定期获取资源状态并设置告警 Github PR: emqx/emqx-rule-engine#67 emqx-sn (plugin) 错误修复: 修复误判 keepalive_timeout 的问题 Github PR: emqx/emqx-sn#127 修复没有正确获取 idle_timeout 的问题 Github PR: emqx/emqx-sn#128 修复测试用例 Github PR: emqx/emqx-sn#130 emqx-auth-jwt (plugin) 错误修复: 正确读取 pubkey Github PR: emqx/emqx-auth-jwt#88 emqx-rel (build-project) Enhancements: 使项目构建更加智能和健壮 GitHub PR: emqx/emqx-rel#375, emqx/emqx-rel#376 3.2-beta.3 版本 发布日期: 2019-06-14 EMQ X 3.2-beta.3 版本发布。此版本改动主要包括增强规则引擎和错误修复。 错误修复: 修复没有检查 Will Retain 的问题 Github PR: emqx/emqx#2607 修复 emqx/emqx: issue#2591 Github PR: emqx/emqx#2615 默认情况下删除日志记录的字符限制 Github PR: emqx/emqx#2617 修复无法处理分裂的 TCP 报文的问题 Github PR: emqx/emqx#2611 emqx-rule-engine (plugin) 功能增强: 支持规则命中次数等 Metrics 统计 Github PR: emqx/emqx-rule-engine#63 emqx-management (plugin) 错误修复: 修复 CLI 无法踢掉 websocket 连接的问题 Github PR: emqx/emqx-management#93 3.2-beta.2 版本 发布日期: 2019-06-06 EMQ X 3.2-beta.2 版本发布。此版本改动主要包括增强规则引擎和错误修复。 错误修复: 修复 emqx/emqx: issue#2553 Github PR: emqx/emqx#2596 emqx-rule-engine (plugin) 功能增强: 支持在 Dashboard 中测试 SQL 语句 Github Commit: emqx/emqx-rule-engine#3e7c4c 预处理 PreparedStatement 以获得更好的性能 Github Commit: emqx/emqx-rule-engine#fa3720, emqx/emqx-rule-engine#b00fad 规则引擎适配集群 Github Commit: emqx/emqx-rule-engine#3da7fe, emqx/emqx-rule-engine#4963b0 Dashboard 可以显示 Resource 状态 Github Commit: emqx/emqx-rule-engine#dd9a8d, emqx/emqx-rule-engine#d16224, emqx/emqx-rule-engine#e4574c 支持通过 Dashboard 重启 Resource Github Commit: emqx/emqx-rule-engine#ccbffd 支持检查 HTTP 是否可连通 Github Commit: emqx/emqx-rule-engine#3feffc 错误修复: 修复删除 Resource 前检查依赖发生错误的问题 Github Commit: emqx/emqx-rule-engine#3265ff 修复 Resource 无法被销毁的问题 Github Commit: emqx/emqx-rule-engine#58a1ce 修复 SQL 无法嵌套插入的问题 Github Commit: emqx/emqx-rule-engine#64776a emqx-auth-http (plugin) 功能增强: 支持 HTTPs Github PR: emqx/emqx-auth-http#133 emqx-docker 错误修复: 修复 emqx/emqx-docker: issue#115 Github Commit: emqx/emqx-docker#f3c219 emqx-management (plugin) 错误修复: 修复重新加载插件失败的问题 Github PR: emqx/emqx-management#91 ekka (deps) 错误修复: 修复导致 emqx_sm_locker 崩溃的问题 Github Commit: emqx/ekka#2d5bf2 3.2-beta.1 版本 发布日期: 2019-05-27 EMQ X 3.2.beta-1 版本发布。此版本改动主要包括支持 rebar3 构建和增强规则引擎。 功能增强: 支持通过 rabar3 构建项目 Github PR: emqx/emqx#2475, emqx/emqx#2510, emqx/emqx#2518, emqx/emqx#2521 SSL 连接支持 {active, N} 选项 Github PR: emqx/emqx#2531 更正匿名访问行为表现 Github PR: emqx/emqx#2355 提升 zone 的访问速度 Github PR: emqx/emqx#2548 错误修复: 修复 emqx_sm 中的致命错误 Github PR: emqx/emqx#2559 修复发布 MQTT-SN、CoAP 消息时的错误 Github PR: emqx/emqx#2556 emqx-rule-engine (plugin) 功能增强: 更好的规则引擎 Github Repository: emqx/emqx-rule-engine emqx-web-hook (plugin) 功能增强: 增加一个用于编码 payload 字段的选项 Github PR: emqx/emqx-web-hook#119 emqx-auth-http (plugin) 功能增强: HTTP 请求支持更多选项 Github PR: emqx/emqx-auth-http#128 emqx-sn (plugin) 错误修复: 修复错误的函数调用 Github PR: emqx/emqx-sn#118 3.1.2 版本 发布日期: 2019-06-06 EMQ X 3.1.1 版本发布。此版本改动主要包括错误修复、稳定性增强。 EMQ X Core Bug fixes: 修复 emqx/emqx: issue #2595 Github PR: emqx/emqx#2601 修复无法设置日志等级的问题 Github PR: emqx/emqx#2600 修复返回值不匹配的问题 Github PR: emqx/emqx#2560 热修复 emqx_sn 与 emqx_coap 插件 Github PR: emqx/emqx#2556 emqx-coap (plugin) 错误修复: 修复无法发布消息的问题 Github PR: emqx/emqx-coap#120 ekka (deps) 错误修复: 修复导致 emqx_sm_locker 崩溃的问题 Github PR: emqx/ekka#54 修复 k8s 无法使用 dns 集群的问题 Github PR: emqx/ekka#53 修复 etcd 集群不可用的问题 Github PR: emqx/ekka#52 3.1.1 版本 发布日期: 2019-05-10 EMQ X 3.1.1 版本发布。此版本改动主要包括错误修复、稳定性增强。 功能增强: 增大单条日志可打印的最大字符数量 Github PR: emqx/emqx#2509 force_shutdown_policy 将根据系统位数使用不同的默认值 Github PR: emqx/emqx#2515 错误修复: 正确地配置和使用 long_gc 与 long_schedule Github PR: emqx/emqx#2504, emqx/emqx#2513 修复没有更新 suboptions/count 的问题 Github PR: emqx/emqx#2507 emqx-lwm2m (plugin) 错误修复: 修复 mountpoint 没有生效的问题 Github PR: emqx/emqx-lwm2m#34 修复消息无法被 emqx-web-hook 转发的问题 Github PR: emqx/emqx-lwm2m#35 3.1.0 版本 发布日期: 2019-04-26 EMQ X 3.1.0 版本发布。此版本改动主要包括全面支持规则引擎、引入 storm 模块以支持 edge storm、 重构 flapping 代码。 功能改进: 添加 emqx_ct_helpers 依赖，并重构测试用例 Github PR: emqx/emqx#2480 重构 flapping 代码 Github PR: emqx/emqx#2476 emqx-management (plugin) 问题修复: 修复 listeners acceptors 的值没有正确获取的问题 Github PR: emqx/emqx-management#76 emqx-rule-engine (plugin) 功能改进: 支持规则动作参数的验证 Github PR: emqx/emqx-rule-engine#b28318 删除资源时检查是否存在依赖 Github PR: emqx/emqx-rule-engine#fa75b9 从 republish 动作中移除 from 参数 Github PR: emqx/emqx-rule-engine#8721eb 修复了 SQL where 子句不能处理整数的问题 Github PR: emqx/emqx-rule-engine#c9c761 emqx-storm (plugin) 功能改进: 支持 edge storm Github Repository: emqx/emqx-storm 3.1-rc.3 版本 发布日期: 2019-04-19 EMQ X 3.1-rc.3 版本发布。此版本改动主要包括规则引擎增强、错误修复。 注意: 从此版本开始，新增 OpenSUSE 安装包，并且不再提供 Debian 7 安装包。 功能改进: 支持对客户端进行 flapping 检测，以及禁止异常的客户端 Github PR: emqx/emqx#2438 支持配置日志输出长度 Github PR: emqx/emqx#2461 问题修复: 修复 emqx_client 没有正确设置 CONNECT 报文 Keep Alive 字段的问题 Github PR: emqx/emqx#2443 emqx-auth-mysql (plugin) 功能改进: 支持 proxysql Github PR: emqx/emqx-auth-mysql#134 emqx-statsd (plugin) 问题修复: 修复 Windows 兼容性引起的问题 Github PR: emqx/emqx-statsd#24 emqx-web-hook (plugin) 功能改进: 支持事件 actions Github Commit: emqx/emqx-web-hook#8367e0 优化 webhook 资源的 specs Github Commit: emqx/emqx-web-hook#5a1345 支持通过 hook 类型搜索 actions Github Commit: emqx/emqx-web-hook#fb3b1b emqx-rule-engine (plugin) 功能改进: 支持通过资源类型搜索 actions Github PR: emqx/emqx-rule-engine#25 注册资源提供者更改为加载资源提供者 Github PR: emqx/emqx-rule-engine#26 优化 actions 的输入数据 Github PR: emqx/emqx-rule-engine#27 emqx-rel 问题修复: 修复修改 log.rotation.size 后启动失败的问题 Github PR: emqx/emqx-rel#336 3.1-rc.2 版本 发布日期: 2019-04-13 EMQ X 3.1-rc.2 版本发布。此版本改动主要包括规则引擎增强、错误修复。 功能改进: 重新设计 emqx_bridge 的 ensure_start 与 ensure_stop API Github PR: emqx/emqx#2423 提供 Handler 以扩展 emqx_bridge Github PR: emqx/emqx#2414 问题修复: 修复 metrics 在某些情况下没有正确更新的问题 Github PR: emqx/emqx#2416 修复 trace log level 无法生效时没有提示的问题 Github PR: emqx/emqx#2408 emqx-auth-http (plugin) 功能增强: 支持用户的 WebServer 回传 Mountpoint Github PR: emqx/emqx-auth-http#116 emqx-auth-username (plugin) 功能增强: 移除在配置文件中配置默认 username 的功能 Github PR: emqx/emqx-auth-username#96 emqx-auth-clientid (plugin) 功能增强: 移除在配置文件中配置默认 clientid 的功能 Github PR: emqx/emqx-auth-clientid#81 emqx-rule-engine (plugin) 功能增强: 支持标准 POSIX CLI 格式 Github PR: emqx/emqx-rule-engine#23 问题修复: 修复 HTTP APIs 中的错误 Github PR: emqx/emqx-rule-engine#21 emqx-packages (plugin) 问题修复: 修复 EMQ X 在 CentOS 中开机启动失败的问题 Github Commit: emqx/emqx-packages#64760523ea29ca0ad1d85b763f0e8a8e6954db9c emqx-dashboard (plugin) 功能增强: 新增 Rule-Engine 前端页面 Github PR: emqx/emqx-dashboard#50 支持在集群中统一管理 Dashboard 用户 Github PR: emqx/emqx-dashboard#48 3.1-rc.1 版本 发布日期: 2019-04-04 EMQ X 3.1-rc.1 版本发布。此版本改动主要包括规则引擎增强、错误修复、稳定性增强等。 功能改进: 支持压缩 WebSocket 消息 Github PR: emqx/emqx#2356 etcd 集群支持 SSL 连接 Github PR: emqx/emqx#2367 支持 Websocket 的 proxy protocol Github PR: emqx/emqx#2372 问题修复: 修复 monitor 模块中的错误逻辑 Github PR: emqx/emqx#2353 修复 allow_anonymous 功能不符合预期的问题 Github PR: emqx/emqx#2355 修复 session 进程中无法一次性接收多个消息的问题 Github PR: emqx/emqx#2373 修复 message.dropped 的 hook 在某些情况下不会被触发的问题 Github PR: emqx/emqx#2399 emqx-auth-http (plugin) 功能增强: 支持从 SSL 双向连接中取出 Subject Name 与 Common Name 用于认证 Github PR: emqx/emqx-auth-http#113 emqx-auth-clientid (plugin) 功能增强: 支持通过 REST API 操作 ClientId Github PR: emqx/emqx-auth-clientid#78 emqx-auth-jwt (plugin) 功能增强: 支持验证指定的 claims 字段 Github PR: emqx/emqx-auth-jwt#69 emqx-rule-engine (plugin) 功能增强: 增强规则引擎 Github Repository: emqx/emqx-rule-engine emqx-rel 错误修复: 修复 Windows 环境下 EMQ X 需要启动两次的问题 Github Commit: emqx/emqx-rel#75de3441db9bf03d489609dcbb340a74de263508 修复 Windows 环境下 EMQ X 安装路径含有中文或空格时无法启动的问题 Github Commit: emqx/emqx-rel#75de3441db9bf03d489609dcbb340a74de263508 3.1-beta.3 版本 发布日期: 2019-03-22 EMQ X 3.1-beta.3 版本发布。此版本改动主要包括引入规则引擎，增强插件发现机制，和修复一些问题等。 功能改进: 增强插件发现机制 Github PR: emqx/emqx#2339 问题修复: 修复重复清除告警的错误 Github PR: emqx/emqx#2332 修复粘包解析失败的问题 Github PR: emqx/emqx#2333 正确设置 PUBLISH 文件中的 DUP 标识 Github PR: emqx/emqx#2337 emqx-rule-engine (plugin) 功能增强: 实现规则引擎原型 Github Repository: emqx/emqx-rule-engine emqx-lua-hook (plugin) 功能增强: 增加认证与 ACL 的 hook Github PR: emqx/emqx-lua-hook#63 emqx-auth-mysql (plugin) 问题修复: 修复 ACL 功能无法使用的问题 Github PR: emqx/emqx-auth-mysql#130 3.1-beta.2 版本 发布日期: 2019-03-16 EMQ X 3.1-beta.2 版本发布。此版本改动主要包括重新设计 hooks, 支持 TLS/PSK 和修复 gen_rpc 的一些问题等。 功能改进: 优化 emqx hooks Github PR: emqx/emqx#2309 支持 TLS/DTLS PSK Github PR: emqx/emqx#2297 将 Request/Response 从 emqx client 分离 Github PR: emqx/emqx#2293 错误修复: 修复某些情况下集群转发消息时 Broker 可能崩溃的问题 Github issues: emqx/emqx#2290 Github PR: emqx/emqx#2320 在 Broker 卸载插件并退出前卸载 emqx_alarm_handler Github PR: emqx/emqx#2316 修复一个与 emqx bridge 相关的错误 Github issues: emqx/emqx#2312 Github PR: emqx/emqx#2313 终结 inflight full error Github PR: emqx/emqx#2281 emqx-management (plugin) 功能增强: 增加默认的 secret 配置 Github PR: emqx/emqx-management#58 修复插件尚未启动时无法 reload 的问题 Github PR: emqx/emqx-management#59 插件相关的 HTTP API 由插件各自实现 Github PR: emqx/emqx-management#57 修复查询 io/max_fds 返回 undefined 的问题 Github issues: emqx/emqx-management#2222 Github PR: emqx/emqx-management#54 emqx-auth-jwt (plugin) 功能增强: 优化 JWT 认证插件 Github PR: emqx/emqx-auth-jwt#63 emqx-auth-usernmae (plugin) 功能增强: 增加 CURD HTTP API 以管理用户名密码 Github PR: emqx/emqx-auth-username#82 emqx-web-hook (plugin) 错误修复: 修复格式化消息时的错误 Github issues: emqx/emqx-web-hook#93 Github PR: emqx/emqx-web-hook#96 minirest (deps) 错误修复: 过滤未启动插件的 HTTP API Github PR: emqx/minirest#12 gen_rpc (deps) 错误修复: 修复 'gen_rpc' 的 raw socket flags Github PR: emqx/gen_rpc#5 3.1-beta.1 版本 发布日期: 2019-02-28 EMQ X 3.1-beta.1 版本发布。此版本主要\b针对功能改进，包括引入全新的 Bridge，支持消息批量发送，支持 redis 集群等。 功能改进: 引入新的 Bridge 实现，支持 EMQ Broker 节点间桥接和 MQTT 协议间桥接 Github PR: emqx/emqx#2199 支持消息批量发送 Github PR: emqx/emqx#2253 使用 gen_statem behaviour 改进 emqx_connection 模块 Github PR: emqx/emqx#2235 新增资源监控，优化告警处理 Github PR: emqx/emqx#2266 emqx-auth-redis 功能改进: 支持 redis 集群 Github PR: emqx/emqx-auth-redis#93 emqx-dashboard 功能改进: 为 emqx_dashboard_cli \b模块增加测试用例 Github PR: emqx/emqx-dashboard#34 emqx-auth-username 功能改进: 增加新的 CLI 以更新 username Github PR: emqx/emqx-auth-username#74 emqx-auth-clientid 功能改进: 增加新的\b CLI 以更新 clientid Github PR: emqx/emqx-auth-clientid#59 3.0.1 版本 发布日期: 2019-01-25 EMQ X 3.0.1 版本发布。此版本主要包含功能改进和错误修复。 功能改进: 为 emqx edge 增加 +L 虚拟机参数以减少内存 Github PR: emqx/emqx#2110 简化修改日志输出等级的命令 Github PR: emqx/emqx#2115 重构 bridge 代码; 支持 bridge 消息持久化 Github PR: emqx/emqx#2160, emqx/emqx#2117, emqx/emqx#2113, emqx/emqx#2108, emqx/emqx#2053 优化路由匹配 Github PR: emqx/emqx#2124 改进 'emqx_client' 模块设计 Github PR: emqx/emqx#2137 改进 'emqx_pool' 模块的设计 Github PR: emqx/emqx#2138 改进共享订阅调度实现 Github PR: emqx/emqx#2144 支持重启 emqx 时重新生成配置 Github PR: emqx/emqx#2175 问题修复: 修复对端关闭连接时崩溃的问题 Github PR: emqx/emqx#2074 修复客户端正常断开连接时依旧发送遗嘱消息的问题 Github PR: emqx/emqx#2156 emqx-lwm2m 问题修复: 移除认证功能 GitHub PR: emqx/emqx-lwm2m#14 emqx-auth-username 问题修复: 支持可选的加密模式 GitHub PR: emqx/emqx-auth-usernmae#64 emqx-auth-clientid 功能改进: 支持可选的加密模式 GitHub PR: emqx/emqx-auth-clientid#52 emqx-management 功能改进: 增加 'plugins reload \\' CLI 命令，支持重载插件时重新生成配置 Github PR: emqx/emqx-management#30 3.0.0 版本 发布日期: 2018-12-22 EMQ X 3.0.0版本，重新设计了订阅的 ETS 表，通过重构模块和调节 erlang 虚拟机参数提升了 EMQ 性能 功能改进: 将虚拟机参数移动到单独的 vm.args 文件 Github PR: emqx/emqx#2033, emqx/emqx#2057, emqx/emqx#2070 为遗嘱消息主题增加格式校验和 ACL 检查 Github PR: emqx/emqx#2075 增加 ACL 检查返回拒绝时是否断开客户端连接的配置选项 Github PR: emqx/emqx#2059 重构 session 监控树 Github PR: emqx/emqx#2077 增加 'active_n' 选项以优化 emqx_connection 的 CPU 占用率 Github PR: emqx/emqx#2060 支持客户端批量下线 Github PR: emqx/emqx#2060 增加订阅表分片机制 Github PR: emqx/emqx#2044 重构 'emqx_gc' 模块 Github PR: emqx/emqx#2090 问题修复: 修复 Topic Alias Maximum 的错误实现 Github PR: emqx/emqx#2074 修复部分情况下不会发送遗嘱消息的错误 Github PR: emqx/emqx#2068 emqx-auth-ldap 功能改进: 更好的设计 GitHub PR: emqx/emqx-auth-ldap#46 emqx-lua-hook 问题修复: 修复测试用例 GitHub PR: emqx/emqx-lua-hook#45 emqx-management 功能改进: 为 REST API 增加测试用例，并规范返回的响应格式 Github PR: emqx/emqx-management#21 3.0-rc.5 版本 发布日期: 2018-11-30 EMQ X 3.0-rc.5版本发布，该版本支持 metrics 的批量提交和修复错误: 功能改进: 减小依赖大小 Github PR: emqx/emqx#1981 支持 metrics 的批量提交 Github PR: emqx/emqx#2001 优化 mnesia/ets 的并行读写性能 Github PR: emqx/emqx#2006 问题修复: 修复 emqx_router 中的 'function_clause' 错误 Github PR: emqx/emqx#1998 启动过程中移除 simple 日志句柄 Github PR: emqx/emqx#2000 修复 emqx_reason_codes 模块可能出现参数异常的问题 Github PR: emqx/emqx#2008 emqx-passwd 功能改进: 支持 Rebar3 GitHub PR: emqx/emqx-passwd#6 emqx-web-hook 功能改进: 支持 Rebar3 GitHub PR: emqx/emqx-web-hook#77 问题修复: 修复 emqx-web-hook 发送 HTTP 请求时未携带 username 和 clientid 的错误 GitHub PR: emqx/emqx-web-hook#77 emqx-dashboard 问题修复: 修复火狐浏览器无法拷贝应用信息的问题 Github PR: emqx/emqx-dashboard#12 emqx-management 问题修复: 修复 clients 的 CLI 错误 Github PR: emqx/emqx-management#16 3.0-rc.4 版本 发布日期: 2018-11-24 EMQ X 3.0-rc.4版本发布，该版本改进日志功能，部分项目支持 Rebar3 构建: 功能改进: 为使用 MQTT v3.1.1的客户端提供避免 loop delivery 的功能 Github PR: emqx/emqx#1964 支持使用 username 代替 client_id，默认不开启 Github PR: emqx/emqx#1961 默认日志类型为 both Github PR: emqx/emqx#1979 添加控制日志等级的命令行接口 Github PR: emqx/emqx#1977 改进 log tracer 的命令行接口 Github PR: emqx/emqx#1973 优化日志性能 Github PR: emqx/emqx#1960 问题修复: 修复用户属性的类型验证 Github PR: emqx/emqx#1969 修复 max_topic_alias 配置项的错误描述 Github PR: emqx/emqx#1962 当 client_id 为空时，将 proc meta-data 设置为服务端生成的 client_id Github PR: emqx/emqx#1980 emqx-coap 功能改进: 支持 Rebar3 GitHub PR: emqx/emqx-coap#89 问题修复: 修复 sendfun 参数错误的问题 Github PR: emqx/emqx-coap#89 emqx-management 问题修复: 修复集群模式下通过 REST API 查找连接不稳定的问题 Github PR: emqx/emqx-management#11 ekka 问题修复: 修复分布式锁的错误判断 Github PR: emqx/ekka#39 minirest 功能改进: 支持Rebar3 Github PR: emqx/minirest#6 cuttlefish 问题修复: 将 cuttlefish 的日志输出到 std_error Github PR: emqx/cuttlefish#4 emqx-rel 功能改进: 构建时更新 cuttlefish Github PR: emqx/emqx-rel#253 默认不启用 delay_publish 插件 Github PR: emqx/emqx-rel#251 3.0-rc.3 版本 发布日期: 2018-11-10 EMQ X 3.0-rc.3版本发布，该版本重构 emqx_mqueue 代码，支持 MQTT-SN, CoAP 与 STOMP 协议: 功能改进: 将 QOS$i 替换为 QOS_$i Github PR: emqx/emqx#1948 更新配置文件中 ACL cache 的描述信息 Github PR: emqx/emqx#1950 重构 emqx_mqueue 代码 Github PR: emqx/emqx#1926 lager 替换为 OTP logger Github PR: emqx/emqx#1898 问题修复: 修复重复订阅时的 'badarg' 错误 Github PR: emqx/emqx#1943 修复 emqx_message:format 函数 'badarg' 错误 Github PR: emqx/emqx#1954 修复 MQTT bridge 无法使用 TLS 连接的问题 Github PR: emqx/emqx#1949 emqx-stomp 功能改进: 增强 receipt 报文支持，增加测试用例 GitHub PR: emqx/emqx-stomp#53 emqx-sn 功能改进: 增强对 MQTT-SN 协议的支持 GitHub PR: emqx/emqx-sn#90 emqx-lua-hook 问题修复: 修复 emqx-lua-hook 无法正常使用的问题 Github PR: emqx/emqx-lua-hook#41 emqx-statsd 功能改进: 增加统计指标 Github PR: emqx/emqx-statsd#4 emqx-dashboard 功能改进: 增加 qos2/forward 指标 Github PR: emqx/emqx-dashboard#7 emqx-auth-pgsql 问题修复: 修复并发量大时 emqx-auth-pgsql 出错的问题 Github PR: emqx/emqx-auth-pgsql#94 3.0-rc.2 版本 发布日期: 2018-10-27 EMQ X 3.0-rc.2版本发布，该版本改进 Will Message 发布机制，新增支持使用 ssl 证书作为 MQTT 用户名: 功能改进: 改进 Will Message 发布机制，增加取消发布处理 Github PR: emqx/emqx#1889 新增支持使用 ssl 证书作为 MQTT 用户名 Github PR: emqx/emqx#1913 提升代码测试覆盖率 Github PR: emqx/emqx#1921 问题修复: 修复 emqx_broker:subscribed 函数 'bad argument' 错误 Github PR: emqx/emqx#1921 3.0-rc.1 版本 发布日期: 2018-10-20 EMQ X 3.0-rc.1版本发布，该版本新增 request & response 以及 LwM2M 插件，修复 PUBLISH 验证问题: 功能改进: 为 CONNECT & CONNACK 报文添加 request & response 支持 Github PR: emqx/emqx#1819 为未认证的订阅添加警告信息 Github PR: emqx/emqx#1878 增加 emqx_hooks 的测试覆盖率, 为 emqx_mod_sup 模块增加测试用例 Github PR: emqx/emqx#1892 问题修复: 更新 ACL 文档链接 Github PR: emqx/emqx#1899 修复验证 PUBLISH 报文时的匹配问题 Github PR: emqx/emqx#1888 修复某些情况下不返回 Reason Code 给 client 的 BUG Github PR: emqx/emqx#1819 修复 emqx_client 模块中的兼容性问题 Github PR: emqx/emqx#1819 emqx-lwm2m 更新 LwM2M 插件以适配 EMQ X 3.0 Github PR: emqx/emqx-lwm2m#3 3.0-Beta.4 版本 发布日期: 2018-09-29 EMQ X 3.0-beta.4 版本发布，该版本改进连接 Shutdown 策略，改进共享订阅 sticky 策略，修复 Delayed Publish 问题： 功能改进: 为进程自定义 max_heap_size GitHub issues: emqx/emqx#1855 改进 Topic 别名 Maximum、连接 Receive Maximum GitHub issues: emqx/emqx#1873 修复共享订阅 sticky 策略 pick ID 方式 GitHub issues: emqx/emqx#1871 为 Zone 新增 Mountpoint 配置 GitHub issues: emqx/emqx#1869 修复make app.config 错误 GitHub issues: emqx/emqx#1868, 修复 Hooks 回调参数错误 GitHub issues: emqx/emqx#1866 改进 travis 构建支持 rebar3 xref GitHub issues: emqx/emqx#1861 升级依赖库 esockd 至 v5.4.2 GitHub issues: emqx/emqx#1875 升级依赖库 erlang-bcrypt 至0.5.1 GitHub issues: emqx/emqx-passwd#3 emqx-delayed-publish 修复消息延时发布 GitHub issues: emqx/emqx-delayed-publish#5 emqx-passwd 改进 check_pass 方式，供各类认证插件调用 GitHub issues: emqx/emqx-passwd#3 bcrypt 改进 bcrypt 验证方式 GitHub issues: emqx/erlang-bcrypt#1 esockd 新增 DTLS PSK 样例 GitHub issues: emqx/esockd#88 修复 DTLS 启动失败 GitHub issues: emqx/esockd#89 改进 SSL 启动方式 GitHub issues: emqx/esockd#90 3.0-Beta.3 版本 发布日期: 2018-09-22 EMQ X 3.0-beta.3版本发布，该版本新增共享订阅派发策略功能，改进GC策略、桥接设计: 功能改进: 修复 travis 构建 GitHub issues: emqx/emqx#1818 更新模块emqx_mqueue.erl文档说明 GitHub issues: emqx/emqx#1815 新增共享订阅派发策略 GitHub issues: emqx/emqx#1823 修复emqx_pool模块参数错误 GitHub issues: emqx/emqx#1827 新增强制shutdown策略 GitHub issues: emqx/emqx#1836 改进KeepAlive检测算法 GitHub issues: emqx/emqx#1839 修复跨节点消息投递 GitHub issues: emqx/emqx#1846 改进Bridge设计 GitHub issues: emqx/emqx#1849 改进force_gc_policy配置 GitHub issues: emqx/emqx#1851 修复Maximum-QoS选项值 GitHub issues: emqx/emqx#1852 升级依赖库esockd至v5.4.1 GitHub issues: emqx/emqx#1858 问题修复: 订阅API，主题属性支持通配符 GitHub issues: emqx/emqx#1706 WebSocket 连接新增Path配置 GitHub issues: emqx/emqx#1809 修复报文尺寸过大导致block问题 GitHub issues: emqx/emqx#1811 新增函数check_expiry GitHub issues: emqx/emqx#1813 修复DISCONNECT报文Session Expiry Interval不起作用 GitHub issues: emqx/emqx#1833 修复DISCONNECT报文Max Session Expiry Interval不起作用 GitHub issues: emqx/emqx#1834 emqx-management 改进Bridge CTL命令 修复函数调用emqx_mgmt_cli:print() crash问题 修复emqx_mgmt:subscribe函数'function_clause'错误 GitHub issues: emqx/emqx-management#1815 emqx-web-hook 修复加载emqx_web_hook错误 emqx-dashboard 修复 Dashboard -> OverView 中disconnect统计数据显示 在 Dashboard -> Websocket 新增WebSocket Path参数 GitHub issues: emqx/emqx-dashboard#5 emqx-retainer Retained 消息新增TTL GitHub issues: emqx/emqx-retainer#52 emqx-coap 新增emqx_coap插件 GitHub issues: emqx/emqx-coap#5 emqx/gen-coap#5 emqx-docker 优化Dockerfile GitHub issues: emqx/emqx-docker#5 esockd 改进esockd_connection_sup模块设计 GitHub issues: emqx/esockd#86 3.0-Beta.2 版本 发布日期: 2018-09-10 EMQ X 3.0-Beta.2 版本主要包含了对 MQTT 5.0 新特性的改进，以及问题修复。 EMQ X Core 功能改进: 支持 MQTT 5.0 'subscription options' GitHub issues: emqx/emqx#1788, emqx/emqx-retainer#58, emqx/emqx#1803 增加对 MQTT 5.0 'Topic-Alias' 的校验 GitHub issues: emqx/emqx#1789, emqx/emqx#1802 改进 hooks 的设计 GitHub issue: emqx/emqx#1790 将模块 'emqx_mqtt_properties' 重命名为 'emqx_mqtt_props' GitHub issue: emqx/emqx#1791 改进 emqx_zone GitHub issue: emqx/emqx#1795 问题修复: 修复了 'Will Delay Interval' 属性处理错误 GitHub issues: emqx/emqx#1800, emqx/emqx-delayed-publish#3 修复了 'Reserved' 标志位的处理错误 GitHub issue: emqx/emqx#1783 为单元测试生成配置文件 GitHub issue: emqx/emqx#1794 emqx-management (插件) 功能改进: 增加 'banned' 功能的 restful API GitHub issue: emqx/emqx-management#6 emqx-delayed-publish (插件) 功��改进: 重构代码 GitHub issue: emqx/emqx-delayed-publish#4 minirest (依赖工程) 功能改进: 回调函数里，同时传递 query 参数和 body 参数 GitHub issue: emqx/minirest#4 emqx-rel (编译工程) 功能改进: 编译时检查 OTP 版本 GitHub issue: emqx/emqx-rel#217 3.0-Beta.1 版本 发布日期: 2018-09-02 版本别名: The Promise of Tomorrow 3.0-beta.1 版本正式发布。兼容 MQTT-3.1.1 协议的同时， 完整支持 MQTT-5.0 协议。 此外还增加了很多实用的功能特性，重构了核心组件，提升了系统的伸缩性和扩展能力。 全面支持 MQTT-5.0 EMQX 3.0 版本实现了大多数的 MQTT-5.0 特性，主要的 MQTT-5.0 新特性一览: 增加了新的 MQTT 控制报文类型: AUTH MQTT-5.0 里新增加了一个 AUTH 类型的报文，用来实现相对复杂的认证交互流程。 Session 过期机制 之前版本的 \"Clean session flag\" 现在拆分成了两个字段: \"Clean Start Flag\"，\"Session Expiry Interval\"。 Message 过期机制 MQTT-5.0 里，在发布消息时允许设置一个消息过期时间。 所有的 ACK 都可携带 Reason Code MQTT-5.0 里，所有的回复报文都包含 Reason Code 字段。现在终端可以知道一个请求失败的原因了。 所有的 ACK 都可携带 Reason String 除了 Reason Code 之外，所有的回复报文都可包含一个 Reason String。 Server 端主动断开 MQTT-5.0 里，Server 端可以主动断开一个连接了。 Payload format and content type MQTT-5.0 里发消息的时候，可以指定 Payload 类型和一个 MIME 风格的 content type。 Request/Response 模式 增加了几个 property，来规范使用 MQTT 协议做 Request/Response 模式的交互。 共享订阅 EMQ X 2.x 支持单节点的共享订阅。 现在 EMQ X 3.0 支持了整个集群范围内的共享订阅。 订阅 ID 有了这个订阅 ID，终端可以获知某条消息是由哪个订阅来的。 Topic 别名 Topic 现在可以有一个整型的别名，这可以降低 MQTT 由于长 Topic 导致的网络交互损耗。 用户自定义的 User properties MQTT-5.0 里，多数报文都可以携带 User properties。 报文大小限制 EMQ X 2.x 里可以配置 Broker 端的最大报文限制，过大的报文会被丢弃，然后 Broker 会将连接断开。MQTT-5.0 里，通过 CONNECT/CONNECT ACK 报文，客户端和 Broker 端都可以指定最大报文限制。 可选的 Server 端能力通知 (TODO) Broker 端可以定义不支持的特性，并将其通知给终端。 订阅选项 MQTT-5.0 提供了一些订阅选项，主要是为了桥接的应用。 比如 nolocal，和 retained 消息处理相关的选项。 Will delay MQTT-5.0 允许指定一个时延，定义从连接断开到遗嘱消息被发送出去之前的延时。这样可以避免在短暂的网络断开和波动时发出遗嘱消息。 Broker 端的保活设置 MQTT-5.0 里，Broker 端可以指定一个期望终端使用的保活时间。 Assigned ClientID MQTT-5.0 里，如果 ClientID 是 Broker 分配的，服务端需要返回这个 ClientID 给终端。 Server reference MQTT-5.0 里，Broker 可以指定一个另外一个 Broker 让终端使用。可以用来做连接重定向。 集群架构演进 EQMX 3.0 引入了伸缩性较强的 RPC 机制，现在单集群可以支持千万级别的并发连接: -------- -------- EMQX EMQX | | Ekka Ekka | | Mnesia Mnesia | | Kernel Kernel | -------- -------- 引入 Ekka 以实现集群的自动建立和自动恢复。目前支持以下几种集群建立方式: manual: 手动加入集群; static: 使用预置的节点列表自动组建集群; mcast: 使用广播自动建立集群; dns: 使用 DNS A 记录自动建立集群; etcd: 使用 etcd 自动建立集群; k8s: 使用 k8s 自动建立集群。 消息速率限制 3.0 引入了消息速率限制，以增加 Broker 的可靠性。在 MQTT TCP 或 SSL 监听器配置里，可以配置: 并发连接数量: max_clients 连接速率限制: max_conn_rate 连接流量限制: rate_limit 发布速率限制: max_publish_rate Feature improvements and Bug Fixes 更新了 esockd; 改用 cowboy 以提升 HTTP 连接的性能; 重构了 ACL 缓存机制; 增加本地和远程 MQTT 桥接功能; 配置文件引入 \"zone\" 的概念，不同的 \"zone\" 可以使用不同的配置; 重构了 session 模块，减少了节点间的内存拷贝，提升了节点间通信效率; 改进了 OpenLDAP 的 Access Control; 增加了延时发布功能; 增加了支持 Prometheus 的新的监控和统计功能; 改进了 hook 机制。 2.3.11 版本 发布日期: 2018-07-23 Bugfix and Enhancements Fix the getting config REST API which throws exceptions. Support to restart listeners when emqttd is running. Specify a fixed tag for the dependency libraries. emq-auth-jwt Fix token verification with jwerl 1.0.0 emq-auth-mongo Support $all variable in ACL query. (emq-auth-mongo#123) Support both clientid and username variables in all queries. (emq-auth-mongo#123) 2.3.10 版本 发布日期: 2018-06-27 Bugfix and Enhancements Upgrade the esockd library to v5.2.2 emq-auth-http Ignore auth on ignore in body, allows for chaining methods 2.3.9 版本 发布日期: 2018-05-20 Bugfix and Enhancements Bugfix: check params for REST publish API (#1599) Upgrade the mongodb library to v3.0.5 esockd Bugfix: proxy protocol - set socket to binary mode (#78) 2.3.8 版本 发布日期: 2018-05-11 Bugfix and Enhancements Bugfix: unregister users CLI when unload emq_auth_username (#1588) Bugfix: Should be an info level when change CleanSession (#1590) Bugfix: emqttd_ctl crashed when emq_auth_usename doesn't exist (#1588) emq-auth-mongo Improve: Support authentication database (authSource) (#116) 2.3.7 版本 发布日期: 2018-04-22 Bugfix and Enhancements Bugfix: fixed spec of function setstats/3 (#1575) Bugfix: clean dead persistent session on connect (#1575) Bugfix: dup flag not set when re-deliver (#1575) Bugfix: Upgrade the lager_console_backend config (#1575) Improve: Support set k8s namespace (#1575) Upgrade the ekka library to v0.2.3 (#1575) Improve: move PIPE_DIR dir from /tmp/${WHOAMI}_erl_pipes/$NAME/ to /$RUNNER_DATA_DIR/${WHOAMI}_erl_pipes/$NAME/ (emq-relx#188) emq-auth-http Improve: Retry 3 times when httpc:request occurred socket_closed_remotely error (emq-auth-http#70) 2.3.6 版本 发布日期: 2018-03-25 Bugfix and Enhancements Security: LWT message checking the ACL (#1524) Bugfix: Retain msgs should not be sent to existing subscriptions (#1529) emq-auth-jwt Validate JWT token using a expired field (#29) 2.3.5 版本 发布日期: 2018-03-03 Bugfix and Enhancements Feature: Add etc/ssl_dist.conf file for erlang SSL distribution (emq-relx#178) Feature: Add node.ssl_dist_optfile option and etc/ssl_dist.conf file (#1512) Feature: Support Erlang Distribution over TLS (#1512) Improve: Tune off the 'tune_buffer' option for external MQTT connections (#1512) emq-sn Clean registered topics if mqtt-sn client send a 2nd CONNECT in connected state (#76) Upgrade the esockd library to v5.2.1 (#76) emq-auth-http Remove 'password' param from ACL and superuser requests (#66) 2.3.4 版本 发布日期: 2018-01-29 Bugfix and Enhancements Feature: Forward real client IP using a reverse proxy for websocket (#1335) Feature: EMQ node.name with link local ipv6 address not responding to ping (#1460) Feature: Add PROTO_DIST_ARG flag to support clustering via IPv6 address. (#1460) Bugfix: retain bit is not set when publishing to clients (when it should be set). (#1461) Bugfix: Can't search topic on web dashboard (#1473) emq-sn Bugfix: CONNACK is not always sent to the client (emq-sn#67) Bugfix: Setting the port to ::1:2000 causes error (emq-sn#66) 2.3.3 版本 发布日期: 2018-01-08 Bugfix and Enhancements Add a full documentation for emq.conf and plugins. Repair a dead link in README - missing emq-lwm2m. (#1430) Subscriber with wildcard topic does not receive retained messages with sub topic has $ sign (#1398) Web Interface with NGINX Reverse Proxy not working. (#953) emq-dashboard Add dashboard.default_user.login, dashboard.default_user.password options to support configuring default admin. emq-modules The emq-modules rewrite config is not right. (#35) emq-docker Upgrade alpine to 3.7 (#31) emq-packages Support ARM Platform (#12) 2.3.2 版本 发布日期: 2017-12-26 Bugfix and Enhancements Support X.509 certificate based authentication (#1388) Add proxy_protocol, proxy_protocol_timeout options for ws/wss listener. Cluster discovery etcd nodes key must be created manually. (#1402) Will read an incorrect password at the last line of emq_auth_username.conf (#1372) How can I use SSL/TLS certificate based client authentication? (#794) Upgrade the esockd library to v5.2. esockd Improve the parser of proxy protocol v2. Add 'send_timeout', 'send_timeout_close' options. Rename esockd_transport:port_command/2 function to async_send/2. Add test case for esockd_transport:async_send/2 function. Add esockd_transport:peer_cert_subject/1, peer_cert_common_name/1 functions. emq-auth-mysql Update depends on emqtt/mysql-otp. Fixed the issue that Cannot connect to MySQL 5.7 (#67). emq-relx Fix mergeconf/3 appending line break error. (#152) emq-sn Fix crash in emq_sn_gateway:transform() function which handles SUBACK. (#57) Define macro SN_RC_MQTT_FAILURE. (#59) emq-web-hook Filter auth_failure client for disconnected hook. (#30) 2.3.1 版本 发布日期: 2017-12-03 Bugfix and Enhancements Remove the unnecessary transactions to optimize session management. Should not exit arbitrarily when clientid conflicts in mnesia. Change the default value of 'mqtt.session.enable_stats' to 'on'. The DUP flag should be set to 0 for all QoS0 messages. (emqttd#1319) Fix the 'no function clause' exception. (emqttd#1293) The retained flags should be propagated for bridge. (emqttd#1293) The management API should listen on 0.0.0.0:8080. (emqttd#1353) Fast close the invalid websocket in init/1 function. erlang:demonitor/1 the reference when erasing a monitor. (emqttd#1340) emq-retainer Don't clean the retain flag after the retained message is stored. Add three CLIs for the retainer plugin. (emq-retainer#38) emq-dashboard Refactor(priv/www): improve the routing page. (emq-dashboard#185) emq-modules Turn off the subscription module by default. (emq-modules#26) emq-sn Add an integration test case for sleeping device. Do not send will topic if client is kicked out. Prevent crash information in log when emq_sn_gateway getting timeout, since it is a possible procedure. emq-relx Support node cookie value with = characters. (emq-relx#146) mochiweb Improve Req:get(peername) funciton to support x-forwarded-for and x-remote-port. (emqtt/mochiweb#9) 2.3.0 版本 \"Passenger's Log\" 发布日期: 2017-11-20 EMQ 2.3.0 版本正式发布，改进了 PubSub 设计与消息路由性能，更新 EMQ 自带的自签名 SSL 证书，改进 Dashboard 界面与 API 设计。 Bugfix and Enhancements Fix the issue that Retained message is not sent for Subscribe to existing topic. (emqttd#1314) Fix the issue that The DUP flag MUST be set to 0 for all QoS0 messages.(emqttd#1319) Improve the pubsub design and fix the race-condition issue. (emqttd#PR1342) Crash on macOS High Sierra (emqttd#1297) emq-dashboard Plugin (emq-dashboard#PR174) Upgraded the 'subscriptions' RESTful API. Improvement of the auth failure log. (emq-dashboard#59) emq-coap Plugin (emq-coap#PR61) Replaced coap_client with er_coap_client. Fix: correct the output format of coap_discover() to enable \".well-known/core\". Refactor the coap_discover method. emq-relx Upgraded the bin/nodetool script to fix the rpcterms command. emq-web-hook Plugin Fix the emq_web_hook plugin getting username from client.connected hook. (emq-web-hook#19) emq-auth-jwt Plugin(emq-auth-jwt#PR15) Added test cases for emq_auth_jwt. Fix jwt:decode/2 functions's return type. emq-auth-mongo Plugin(emq-auth-mongo#PR92) Updated the default MongoDB server configuration. 2.3-rc.2 版本 发布日期: 2017-10-22 Bugfix Change the default logging level of trace CLI. (emqttd#1306) emq-dashboard Plugin (emq-dashboard#164) Fix the 'Status' filters of plugins's management. Fix the URL Redirection when deleting an user. Compatible with IE,Safari,360 Browsers. 2.3-rc.1 版本 发布日期: 2017-10-12 Bugfix Fix the issue that invalid clients can publish will message. (emqttd#1230) Fix Dashboard showing no stats data (emqttd#1263) Fix a rare occurred building failure (emqttd#1284) Support Persistence Logs for longer time (emqttd#1275) Fix for users APIs (emqttd#1289) Changed passwd_hash/2 function's return type (emqttd#1289) emq-dashboard Plugin (emq-dashboard#154) Improved the Dashboard Interface of Monitoring/Management/Tools. Allow switching dashboard themes. Supoort both EN and CN languages. 2.3-beta.4 版本 发布日期: 2017-09-13 Highlights Released a new sexy dashboard. Add more RESTful APIs for manangement and monitoring. Configuring the broker through CLI or API without having to restart. Bugfix Job for emqttd.service failed because the control process exited with error code. (emqttd#1238) Travis-CI Build Failing (emqttd#1221) Https listener of Dashboard plugin won't work (emqttd#1220) Service not starting on Debian 8 Jessie (emqttd#1228) emq-dashboard Support switching to other clustered node. Configure and reboot the plugins on the dashboard. A login page to replace the basic authentication popup window. emq-coap 1.Try to clarify the relationship between coap and mqtt in EMQ. (emq-coap#54). 2.Fix crashes in coap concurrent test(gen-coap#3). 2.3-beta.3 版本 发布日期: 2017-08-21 2.3-beta.3 版本 发布日期: 2017-08-21 Enhancements Add HTTP API for hot configuration. Bugfix Parse 'auth.mysql.password_hash' error when hot configuration reload (emq-auth-mysql#68) Set 'auth.pgsql.server' error when hot configuration reload (emq-auth-pgsql#67) Set 'auth.redis.server' and 'auth.redis.password_hash' error when hot configuration reload (emq-auth-redis#47) Fix the issue that when deleting retained message subscribed clients are not notified (emqttd#1207) Support more parameters for hot configuration reload: mqtt.websocket_protocol_header = on mqtt.mqueue.low_watermark = 20% mqtt.mqueue.high_watermark = 60% mqtt.client.idle_timeout = 30s mqtt.client.enable_stats = off 2.3-beta.2 版本 发布日期: 2017-08-12 EMQ R2.3-beta.2 版本发布！该版本新增 HTTP 管理 API，支持配置 Keepalive 检测周期，支持配置参数热更新。 目前支持配置热更新的插件有: emq-stomp emq-coap emq-sn emq-lwm2m emq-retainer emq-recon emq-web-hook emq-auth-jwt emq-auth-http emq-auth-mongo emq-auth-mysql emq-auth-pgsql emq-auth-redis Note 为支持命令行更新配置参数，部分认证插件参数值采用','替代了空格分隔符。 Enhancements Introduce new HTTP management API. Add ClientId parameter for HTTP Publish API. Allow configuring keepalive backoff. Remove the fullsweep_after option to lower CPU usage. Authorize HTTP Publish API with clientId. emq-sn Plugin (emq-sn#49) Support CONNECT message in connected/wait_for_will_topic/wait_for_will_msg states. Clean registered topic for a restarted client. Bug fix of not clearing buffered PUBLISH messages received during asleep state as those messages are sent to client when client wakes up. emq-auth-ldap Plugin (emq-auth-ldap#21) Improve the design LDAP authentication. emq-coap Plugin (emq-coap#51) Support CoAP PubSub Specification (https://www.ietf.org/id/draft-ietf-core-coap-pubsub-02.txt) 2.3-beta.1 版本 发布日期: 2017-07-24 EMQ R2.3-beta.1版本发布！该版本正式支持集群节点自动发现与集群脑裂自动愈合，支持基于IP Multicast、Etcd、Kubernetes等多种策略自动构建集群。 节点发现与自动集群 EMQ R2.3 版本支持多种策略的节点自动发现与集群: 策略 说明 static 静态节点列表自动集群 mcast UDP组播方式自动集群 dns DNS A记录自动集群 etcd 通过etcd自动集群 k8s Kubernetes服务自动集群 集群脑裂与自动愈合 EMQ R2.3版本正式支持集群脑裂自动愈合(Network Partition Autoheal): cluster.autoheal = on 集群脑裂自动恢复流程: 节点收到Mnesia库的'inconsistent_database'事件3秒后进行集群脑裂确认； 节点确认集群脑裂发生后，向Leader节点(集群中最早启动节点)上报脑裂消息； Leader节点延迟一段时间后，在全部节点在线状态下创建脑裂视图(SplitView)； Leader节点在多数派(Majority)分区选择集群自愈的Coordinator节点； Coordinator节点重启少数派(minority)分区节点恢复集群。 节点宕机与自动清除 EMQ R2.3版本支持从集群自动删除宕机节点(Autoclean): cluster.autoclean = 5m LWM2M协议支持 EMQ R2.3 版本正式支持LWM2M协议网关，实现了LWM2M协议的大部分功能。MQTT客户端可以通过EMQ-LWM2M访问支持LWM2M的设备。设备也可以往EMQ-LWM2M上报notification，为EMQ后端的服务采集数据。 LWM2M是由Open Mobile Alliance(OMA)定义的一套适用于物联网的协议，它提供了设备管理和通讯的功能。LWM2M使用CoAP作为底层的传输协议，承载在UDP或者SMS上 JSON Web Token认证支持 EMQ R2.3 版本支持基于JWT(JSON Web Token)的MQTT客户端认证。 Retainer插件 Retainer插件支持'disc_only'模式存储retained消息。 Debian 9 安装包 EMQ R2.3 支持Debian 9系统安装包。 Erlang/OTP R20 EMQ R2.3 版本兼容Erlang/OTP R20，全部程序包基于Erlang/OTP R20构建。 2.2 正式版 \"Nostalgia\" 发布日期: 2017-07-08 版本别名: Nostalgia EMQ-2.2.0版本正式发布！EMQ R2.2版本完整支持CoAP(RFC 7252)、MQTT-SN协议，支持Web Hook、Lua Hook、Proxy Protocol V2，支持Elixir语言插件开发。 Feature: Add 'listeners restart/stop' CLI command (emqttd#1135) Bugfix: Exit Code from emqttd_ctl (emqttd#1133) Bugfix: Fix spec errors found by dialyzer (emqttd#1136) Bugfix: Catch exceptions thrown from rpc:call/4 (emq-dashboard#128) Bugfix: Topic has been decoded by gen-coap, no conversion needed (emq-coap#43) 2.2-rc.2 版本 发布日期: 2017-07-03 Warning 2.2-rc.2版本源码编译需要Erlang/OTP R19.3+ 问题与改进 Compatible with Erlang/OTP R20 (emq-relx#77) CoAP gateway plugin supports coap-style publish & subscribe pattern. (emq_coap#33) MQTT-SN gateway plugin supports sleeping device (emq_sn#32) Upgrade esockd and mochiweb libraries to support restarting a listener 2.2-rc.1 版本 发布日期: 2017-06-14 问题与改进 Add a new listener for HTTP REST API (emqttd#1094) Fix the race condition issue caused by unregister_session/1 (emqttd#1096) Fix the issue that we cannot remove a down node from the cluster (emqttd#1100) Passed org.eclipse.paho.mqtt_sn.testing/interoperability tests (emq_sn#29) Fix the issue that send http request and return non-200 status code, but AUTH/ACL result is denied (emq-auth-http#33) Fix the issue that fail to stop listener (emq_stomp#24) Support using systemctl to manage emqttd service on CentOS 2.2-beta.3 版本 发布日期: 2017-05-27 问题与改进 Call emit_stats when force GC (emqttd#1071) Update the default value of 'mqtt.mqueue.max_length' to 1000 (emqttd#1074) Update emq-auth-mongo READEME (emq-auth-mongo#66) Update default password field (emq-auth-mongo#67) Upgrade the mongodb library to v3.0.3 Remove ‘check password===undefined && userName!== undefined’ (emq-dashboard#120) emq_auth_redis插件 认证支持HGET查询 emq_auth_mongo插件 支持mongodb集群、Replica Set 文档更新 更新Windows源码编译安装 2.2-beta.2 版本 发布日期: 2017-05-20 问题与改进 Add a 'websocket_protocol_header' option to handle WebSocket connection from WeChat (emqttd#1060) Assign username and password to MQTT-SN's CONNECT message (emqttd#1041) Allow for Content-Type:application/json in HTTP Publish API (emqttd#1045) emqttd_http.erl:data conversion (emqttd#1059) Seperate emq_sn from emqttd (emq-sn#24) Check St0's type, making it easier to debug crash problems (emq-lua-hook#6) Fix error: load xxx.lua (emq-lua-hook#8) Leave luerl alone as a rebar project (emq-lue-hook#9) Display websocket data in reverse order (emq-dashboard#118) priv/www/assets/js/dashboard.js:Fixed a typo (emq-dashboard#118) Update README Update README of emq-auth-pgsql: add the 'ssl_opts' configuration (emq-auth-pgsql#56) Update README of emq-auth-mysql: fix the 'passwd_hash' typo (emq-auth-mysql#54) Update README of emq-auth-mongo: change 'aclquery' to 'acl_query' (emq-auth-mongo#63) Elixir Plugin Add a new plugin emq-elixir-plugin to support Elixir language. 2.2-beta.1 版本 发布日期: 2017-05-05 EMQ 2.2-beta.1版本正式发布！EMQ2.2 版本发布主要新功能包括: 支持MQTT协议多监听器配置，支持HAProxy的Proxy Protocol V1/V2 新增Web Hook插件(emq-web-hook)、Lua Hook插件(emq-lua-hook) MQTT协议监听器配置 一个EMQ节点可配置多个MQTT协议监听端口，例如下述配置external, internal监听器，分别用于设备连接与内部通信: ------- -- Ex，支持Web Hook、Lua Hook、ernal TCP 1883 --> | | EMQ | -- Internal TCP 2883 --> Service -- External SSL 8883--> | | EMQ 2.2 版本etc/emq.conf监听器配置方式: listener.tcp.${name}= 127.0.0.1:2883 listener.tcp.${name}.acceptors = 16 listener.tcp.${name}.max_clients = 102400 Proxy Protocol V1/2支持 EMQ 集群通常部署在负载均衡器(LB)后面，典型架构: ----- | | | L | --TCP 1883--> EMQ --SSL 8883--> | | | B | --TCP 1883--> EMQ | HAProxy、NGINX等常用的负载均衡器(LB)，一般通过Proxy Protocol协议传递TCP连接源地址、源端口给EMQ。 EMQ 2.2 版本的监听器开启Proxy Protocol支持: ## Proxy Protocol V1/2 ## listener.tcp.${name}.proxy_protocol = on ## listener.tcp.${name}.proxy_protocol_timeout = 3s Web Hook插件 新增WebHook插件: emq-web-hook ，支持在MQTT客户端上下线、消息发布订阅时触发WebHook回调。 Lua Hook插件 新增Lua Hook插件: emq-lua-hook ，支持Lua脚本注册EMQ扩展钩子来开发插件。 改进认证链设计 EMQ 2.2 版本改进认证链设计，当前认证模块返回ignore(例如用户名不存在等情况下)，认证请求将继续转发后面认证模块: ------------- ------------ ------------- Client --> | Redis认证 | -ignore-> | HTTP认证 | -ignore-> | MySQL认证 | ------------- ------------ ------------- | | ||/ |/ |/ allow | deny allow | deny allow | deny 支持bcrypt密码Hash EMQ 2.2 版本支持bcrypt密码Hash方式，例如Redis认证插件配置: auth.redis.password_hash = bcrypt etc/emq.conf配置变更 'mqtt.queue.' 配置变更为 'mqtt.mqueue.' emq-dashboard WebSocket页面支持Unsubscribe 2.1.2 版本 发布日期: 2017-04-21 Fix emqttd_ctl sessions list CLI Newline character in emq.conf causing error;(emqttd#1000) Fix crash caused by duplicated PUBREC packet (emqttd#1004) Unload the 'session.created' and 'session.teminated' hooks (emq-plugin-template) 2.1.1 版本 发布日期: 2017-04-14 Localhost:8083/status returns 404 when AWS LB check the health of EMQ (emqttd#984) Https listener not working in 2.1.0 as in 2.0.7 (emq-dashboard#105) Fix mqtt-sn Gateway not working (emq-sn#12) Upgrade emq-sn Plugin (emq-sn#11) Upgrade emq-coap Plugin (emq-coap#21) 2.1.0 版本 发布日期: 2017-04-07 The stable release of 2.1 version. Trouble with auth.mysql.acl_query (emq-auth-mysql#38) Filter the empty fields in ACL table (emq-auth-mysql#39) 2.1.0-rc.2 版本 发布日期: 2017-03-31 Support pbkdf2 hash (emq-auth-mongo#46) Kickout the conflict WebSocket connection (emqttd#963) Correct licence in app.src (emqttd#958) SSL options to connect to pgsql (emq-auth-pgsql#41) 2.1.0-rc.1 版本 发布日期: 2017-03-24 EMQ fails to start if run under a different linux user than that which first ran it (emqttd#842) Depend on emqtt/pbkdf2 to fix the building errors of Travis CI (emqttd#957) Depend on goldrush and emqtt/pbkdf2 to resolve the building errors (emqttd#956) Fix 'rebar command not found' (emq-relx#33) Compile error in v2.1.0-beta.2 (emq-relx#32) Support salt with passwords (emq-auth-mongo#11) Change the default storage_type to 'ram' (emq-retainer#13) 2.1.0-beta.2 版本 发布日期: 2017-03-13 Cannot find AwaitingAck (emqttd#597) EMQ V2.1 crash when public with QoS = 2 (emqttd#919) Support pbkdf2 hash (emqttd#940) Add src/emqttd.app.src to be compatible with rebar3 (emqttd#920) Add more test cases (emqttd#944) CRASH REPORT Process \\ with 0 neighbours crashed with reason: {ssl_error,{tls_alert,\"certificate unknown\"}} in esockd_connection:upgrade (emqttd#915) 'auth.redis.password_hash = plain' by default (emq-auth-redis#20) 2.1.0-beta.1 版本 发布日期: 2017-02-24 EMQ 2.1.0-beta.1版本发布。 Warning 2.1.x版本源码编译需要Erlang/OTP R19+ EMQ正式采用 Semantic Versioning 2.0.0 规范创建发布版本号，按'Tick-Tock'方式按月发布迭代版本。奇数版本问题修复与性能改进，偶数版本架构改进和新功能布。 GC优化 WebSocket、Client、Session进程空置一段时间后自动Hibernate与GC。 新增'mqtt.conn.force_gc_count'配置，Client、Session进程处理一定数量消息后强制GC。 大幅降低WebSocket、Client、Session进程fullsweep_after设置，强制进程深度GC。 API改进 Hooks API支持注册带Tag的回调函数，解决相同模块函数多次Hook注册问题。 问题修复 emqttd#916: Add 'mqtt_msg_from()' type emq-auth-http#15: ACL endpoint isnt called 2.1-beta 版本 发布日期: 2017-02-18 EMQ v2.1-beta版本正式发布，改进Session/Inflight窗口设计，一个定时器负责全部Inflight QoS1/2消息重传，大幅降低高消息吞吐情况下的CPU占用。 Client, Session统计信息 支持对单个Client、Session进程进行统计，etc/emq.conf配置文件中设置'enable_stats'开启: mqtt.client.enable_stats = 60s mqtt.session.enable_stats = 60s 新增missed统计指标 EMQ收到客户端PUBACK、PUBREC、PUBREL、PUBCOMP报文，但在Inflight窗口无法找到对应消息时，计入missed统计指标: packets/puback/missed packets/pubrec/missed packets/pubrel/missed packets/pubcomp/missed Syslog日志集成 支持输出EMQ日志到Syslog，etc/emq.config配置项: ## Syslog. Enum: on, off log.syslog = on ## syslog level. Enum: debug, info, notice, warning, error, critical, alert, emergency log.syslog.level = error Tune QoS支持 支持订阅端升级QoS，etc/emq.conf配置项: mqtt.session.upgrade_qos = on 'acl reload'管理命令 Reload acl.conf without restarting emqttd service (#885) 配置项变更 变更 mqtt.client_idle_timeout 为 mqtt.client.idle_timeout 新增 mqtt.client.enable_stats 配置项 新增 mqtt.session.upgrade_qos 配置项 删除 mqtt.session.collect_interval 配置项 新增 mqtt.session.enable_stats 配置项 变更 mqtt.session.expired_after 为 mqtt.session.expiry_interval 合并扩展模块到emq_modules项目 合并emq_mod_presence, emq_mod_subscription, emq_mod_rewrite到emq_modules项目 变更emq_mod_retainer为emq_retainer项目 Dashboard插件 Overview页面增加missed相关统计指标。 Client页面增加SendMsg、RecvMsg统计指标。 Session页面增加DeliverMsg、EnqueueMsg指标。 recon插件 变更recon.gc_interval配置项类型为duration reloader插件 变更reloader.interval配置项类型为duration 2.0.7 版本 发布日期: 2017-01-20 The Last Maintenance Release for EMQ 2.0, and support to build RPM/DEB Packages. emq-auth-http#9: Update the priv/emq_auth_http.schema, cuttlefish:unset() if no super_req/acl_req config exists emq-auth-mongo#31: cuttlefish:unset() if no ACL/super config exists emq-dashboard#91: Fix the exception caused by binary payload emq-relx#21: Improve the bin\\emqttd.cmd batch script for windows emqttd#873: Documentation: installing-from-source emqttd#870: Documentation: The word in Documents is wrong emqttd#864: Hook 'client.unsubscribe' need to handle 'stop' emqttd#856: Support variables in etc/emq.conf: , , 2.0.6 版本 发布日期: 2017-01-08 Upgrade the esockd library to v4.1.1 esockd#41: Fast close the TCP socket if ssl:ssl_accept failed emq-relx#15: The EMQ 2.0 broker cannot run on Windows. emq-auth-mongo#31: Mongodb ACL Cannot work? 2.0.5 版本 发布日期: 2016-12-24 emq-auth-http#9: Disable ACL support emq-auth-mongo#29: Disable ACL support emq-auth-mongo#30: {datatype, flag} 2.0.4 版本 发布日期: 2016-12-16 emqttd#822: Test cases for SSL connections emqttd#818: trap_exit to link WebSocket process emqttd#799: Can't publish via HTTPS 2.0.3 版本 发布日期: 2016-12-12 emqttd#796: Unable to forbidden tcp lisener emqttd#814: Cannot remove a 'DOWN' node from the cluster emqttd#813: Change parameters order emqttd#795: Fix metrics of websocket connections emq-dashboard#88: Rename the default topic from “/World” to “world” emq-dashboard#86: Lookup all online clients emq-dashboard#85: Comment the default listener port emq-mod-retainer#3: Retained messages get lost after EMQTT broker restart. 2.0.2 版本 发布日期: 2016-12-05 emqttd#787: Stop plugins before the broker stopped, clean routes when a node down emqttd#790: Unable to start emqttd service if username/password contains special characters emq-auth-clientid#4: Improve the configuration of emq_auth_clientid.conf to resolve emqttd#790 emq-auth-username#4: Improve the configuration of emq_auth_username.conf to resolve emqttd#790 2.0.1 版本 发布日期: 2016-11-30 emqttd#781: 更新项目README到2.0版本 emq_dashboard#84: 显示节点集群状态 emq_dashboard#79: 集群节点采用disc_copies存储mqtt_admin表 emq_auth_clientid: 集群节点采用disc_copies存储mqtt_auth_clientid表 emq_auth_username: 集群节点采用disc_copies存储mqtt_auth_username表 emq_mod_subscription#3: 删除emq_mod_subscription表与module.subscription.backend配置 emq_plugin_template#5: 插件停止时注销认证/ACL模块 2.0 正式版 \"西湖以西\" 发布日期: 2016-11-24 版本别名: 西湖以西(West of West Lake) EMQ-2.0版本正式发布！EMQ-1.0版本产品环境下已支持900K并发连接，EMQ-2.0版本重构了整个项目架构并正式支持共享订阅功能: 支持共享订阅(Shared Subscription)与本地订阅(Local Subscription)，解决MQTT协议负载平衡消费问题； 支持CoAP(RFC 7252)、MQTT-SN协议和网关，支持CoAP、MQTT-SN客户端与MQTT客户端互通； 重构配置文件格式与加载方式，支持用户友好的'K = V'文件格式，支持操作系统环境变量； 增加了扩展钩子和大量的认证插件，支持与大部分数据库或NoSQL的认证集成； 支持全平台编译部署，Linux/Unix/Windows以及ARM平台网关，支持Docker镜像制作。 共享订阅(Shared Subscription) 共享订阅(Shared Subscription)支持在多订阅者间采用分组负载平衡方式派发消息: --------- | | --Msg1--> Subscriber1 Publisher--Msg1,Msg2,Msg3-->| EMQ | --Msg2--> Subscriber2 | --Msg3--\\> Subscriber3 使用方式: 订阅者在主题(Topic)前增加'$queue'或'$share/\\/'前缀。 本地订阅(Local Subscription) 本地订阅(Local Subscription)只在本节点创建订阅与路由表，不会在集群节点间广播全局路由，非常适合物联网数据采集应用。 使用方式: 订阅者在主题(Topic)前增加'$local/'前缀。 erlang.mk与relx 2.0版本分离 emqttd 主项目和发布项目 emq-relx, 采用 erlang.mk 和 relx 编译发布工具替换1.x版本使用的rebar，项目可以跨平台在Linux/Unix/Windows系统下编译。 CoAP协议支持 2.0版本支持CoAP协议(RFC7252)，支持CoAP网关与MQTT客户端互通。 CoAP插件: https://github.com/emqtt/emq_coap MQTT-SN协议支持 2.0版本支持MQTT-SN协议，支持MQTT-SN网关与MQTT客户端互通。 MQTT-SN插件: https://github.com/emqtt/emq_sn 'K = V'格式配置文件 2.0版本支持用户友好的'K = V'格式配置文件etc/emq.conf: node.name = emqttd@127.0.0.1 ... mqtt.listener.tcp = 1883 ... 操作系统环境变量 2.0版本支持操作系统环境变量。启动时通过环境变量设置EMQ节点名称、安全Cookie以及TCP端口号: EMQ_NODE_NAME=emqttd@127.0.0.1 EMQ_NODE_COOKIE=emq_dist_cookie EMQ_MAX_PORTS=65536 EMQ_TCP_PORT=1883 EMQ_SSL_PORT=8883 EMQ_HTTP_PORT=8083 EMQ_HTTPS_PORT=8084 Docker镜像支持 EMQ-2.0版本支持Docker镜像制作，Dockerfile开源在: https://github.com/emqtt/emq_docker Windows平台支持 2.0版本完整支持Windows平台的编译、发布与运行，支持Windows平台下的'emqttd_ctl'控制命令，支持在Windows节点间的集群。 问题与改进 #764: add mqtt.cache_acl option #667: Configuring emqttd from environment variables #722: mqtt/superuser calls two times emqtt_auth_http #754: \"-heart\" option for EMQ 2.0 #741: emq_auth_redis cannot use hostname as server address 扩展插件 2.0版本发布的认证与扩展插件列表: 插件 说明 emq_dashboard Web控制台插件(默认加载) emq_auth_clientid ClientId认证插件 emq_auth_username 用户名、密码认证插件 emq_auth_ldap LDAP认证/访问控制 emq_auth_http HTTP认证/访问控制 emq_auth_mysql MySQL认证/访问控制 emq_auth_pgsql PostgreSQL认证/访问控制 emq_auth_redis Redis认证/访问控制 emq_auth_mongo MongoDB认证/访问控制 emq_mod_rewrite 重写主题(Topic)插件 emq_mod_retainer Retain消息存储模块 emq_mod_presence 客户端上下线状态消息发布 emq_mod_subscription 客户端上线自动主题订阅 emq_coap CoAP协议支持 emq_sn MQTT-SN协议支持 emq_stomp Stomp协议支持 emq_sockjs Stomp over SockJS协议支持 emq_recon Recon性能调试 emq_reloader Reloader代码热加载插件 emq_plugin_template 插件开发模版 2.0-rc.3 版本 2.0-rc.3 版本 发布日期: 2016-11-01 将Presence、Retainer、Subscription三个扩展模块改为独立插件: emq_mod_retainer Retain消息存储模块 emq_mod_presence 客户端上下线状态消息发布 emq_mod_subscription 客户端上线自动主题订阅 更新EMQ自带的自签名SSL证书，修复SSL双向认证配置文件错误 Bugfix: Fixed a typo (#716) Bugfix: emqttd_http can not use emq_auth_http? #739 Bugfix: emq_auth_redis cannot use hostname as server address (#741) 升级Redis, MySQL, Postgre, MongoDB插件，支持主机名或域名配置 2.0-rc.2 版本 发布日期: 2016-10-19 集成cuttlefish库，支持'K = V'通用配置文件格式，重构EMQ与全部插件配置文件: node.name = emqttd@127.0.0.1 ... mqtt.listener.tcp = 1883 ... 支持操作系统环境变量。启动时通过环境变量设置EMQ节点名称、Cookie以及TCP端口号: EMQ_NODE_NAME EMQ_NODE_COOKIE EMQ_MAX_PORTS EMQ_TCP_PORT EMQ_SSL_PORT EMQ_HTTP_PORT EMQ_HTTPS_PORT 重构认证模块、ACL模块与扩展模块，更新全部插件项目名称以及配置文件。 TODO: issues closed. 2.0-rc.1 版本 发布日期: 2016-10-03 超级用户认证成功后，发布订阅时不进行ACL鉴权 (#696) MQTT客户端认证失败后，EMQ服务器主动关闭TCP连接 (#707) 改进插件管理设计，新增插件无需修改rel/sys.config配置 改进全部插件Makefile的emqttd依赖: BUILD_DEPS = emqttd dep_emqttd = git https://github.com/emqtt/emqttd emq20 重新设计Redis插件的ACL鉴权模块 2.0-beta.3 版本 发布日期: 2016-09-18 共享订阅(Shared Subscription) Shared Suscriptions (#639, #416): mosquitto_sub -t '$queue/topic' mosquitto_sub -t '$share/group/topic' 本地订阅(Local Subscription) Local Subscriptions that will not create global routes: mosquitto_sub -t '$local/topic' 问题修复 Error on Loading emqttd_auth_http (#691) Remove 'emqttd' application from dependencies (emqttd_coap PR#3) 2.0-beta.2 版本 发布日期: 2016-09-10 CoAP协议支持 CoAP协议支持插件(Beta): https://github.com/emqtt/emqttd_coap API Breaking Changes '$u', '$c' variables in emqttd.conf and modules/acl.conf changed to '%u', '%c' Improve the design of mqtt retained message, replace emqttd_retainer with emqttd_mod_retainer. Add 'session.subscribed', 'session.unsubscribed' hooks, remove 'client.subscribe.after' hook Tab 'retained_message' -> 'mqtt_retained' Bugfix [2.0 beta1] FORMAT ERROR: \"~s PUBLISH to ~s: ~p\" (PR #671) Fixing issues in cluster mode. (PR #681) Fixing issues with unsubscribe hook (PR #673) 2.0-beta.1 版本 发布日期: 2016-08-30 版本别名: 西湖以西(West of West Lake) EMQ 2.0-beta1预览版本(Preview Release)发布。EMQ 2.0版本改进了项目结构、发布方式、Git分支结构以及配置文件格式，以奠定EMQ消息服务器项目长期演进基础。 Note 1.x版本产品部署用户请勿升级到该版本，2.0正式版本发布前会有API变更。 项目简称 - EMQ 项目简称变更为EMQ(Erlang/Enterprise/Elastic MQTT Broker)，E含义Erlang/OTP平台、企业(Enterprise)、弹性(Elastic)。 项目发布方式 2.0 版本后采用预览版(Preview Release) + 候选版本(Release Candidate)版本方式迭代发布，2.0版本将陆续发布beta1, beta2, beta3, rc1, rc2等迭代，直到2.0正式版本发布。 应用与发布 2.0 版本后 emqttd 项目只包括消息服务器应用源码，分离发布(rel)为独立项目: emqttd_relx ，以解决1.0版本的插件(plugins)与emqttd应用编译依赖问题。 源码编译请clone emqttd_relx: git clone https://github.com/emqtt/emqttd-relx.git cd emqttd-relx && make cd _rel/emqttd && ./bin/emqttd console erlang.mk与relx 2.0 版本发布项目 emqttd_relx 采用 erlang.mk 和 relx 编译发布工具替换1.x版本使用的rebar。原因: https://erlang.mk/guide/why.html Git分支结构 stable 1.x 稳定版本分支 master 2.x 主版本分支 emq10 1.x 版本开发分支 emq20 2.x 版本开发分支 emq30 3.x 版本开发分支 issue#{id} Issue修复分支 etc/emqttd.conf配置文件 ---------=------------- 2.0 版本改进项目配置文件格式，采用rebar.config、relx.config类似格式，提高配置文件的可读性和可编辑性。 etc/emqttd.conf配置示例: %% Max ClientId Length Allowed. {mqtt_max_clientid_len, 512}. %% Max Packet Size Allowed, 64K by default. {mqtt_max_packet_size, 65536}. %% Client Idle Timeout. {mqtt_client_idle_timeout, 30}. % Second MQTT-SN协议支持 2.0-beta1版本正式发布 emqttd_sn 项目支持MQTT-SN协议，插件加载方式启用emqttd_sn项目，MQTT-SN默认UDP端口: 1884: ./bin/emqttd_ctl plugins load emqttd_sn 改进插件架构 2.0 版本从emqttd项目删除plugins/目录，插件作为一个普通的Erlang应用，直接依赖(deps)方式在编译到lib目录，插件配置文件统一放置在etc/plugins/目录中: ▾ emqttd-relx/ ▾ etc/ ▸ modules/ ▾ plugins/ emqtt_coap.conf emqttd.conf emqttd_auth_http.conf emqttd_auth_mongo.conf emqttd_auth_mysql.conf emqttd_auth_pgsql.conf emqttd_auth_redis.conf emqttd_coap.conf emqttd_dashboard.conf emqttd_plugin_template.conf emqttd_recon.conf emqttd_reloader.conf emqttd_sn.conf emqttd_stomp.conf 2.0 版本项目文档 2.0 版本中文文档: http://emqtt.com/docs/v2/index.html 或 http://docs.emqtt.cn/zh_CN/emq20 2.0 版本英文文档: https://developer.emqx.io/docs/emq/v2/en/index.html 或 http://docs.emqtt.com/ 发布订阅流程 1.1.3 版本 发布日期: 2016-08-19 Support './bin/emqttd_ctl users list' CLI (#621) Cannot publish payloads with a size of the order 64K using WebSockets (#643) Optimize the procedures that retrieve the Broker version and Borker description in the tick timer (PR#627) Fix SSL certfile, keyfile config (#651) 1.1.2 版本 发布日期: 2016-06-30 Upgrade mysql-otp driver to 1.2.0 (#564, #523, #586, #596) Fix WebSocket Client Leak (PR #612) java.io.EOFException using paho java client (#551) Send message from paho java client to javascript client (#552) Compatible with the Qos0 PUBREL packet (#575) Empty clientId with non-clean session accepted (#599) Update docs to fix typos (#601, #607) 1.1.1 版本 发布日期: 2016-06-04 Compatible with the Qos0 PUBREL packet (#575) phpMqtt Client Compatibility (#572) java.io.EOFException using paho java client (#551) 1.1 版本 发布日期: 2016-06-01 1.1版本升级eSockd库到4.0，支持IPv6与监听特定IP地址。新增MongoDB认证插件、HTTP认证插件与Reloader插件。升级MySQL、PostgreSQL、Redis认证插件，采用参数化查询避免SQL注入，并支持超级用户(superuser)认证。 问题与改进 Allow human-friendly IP addresses (PR#395) File operation error: emfile (#445) emqttd_plugin_mongo not found in emqttd (#489) emqttd_plugin_mongo Error While Loading in emqttd (#505) Feature request: HTTP Authentication (#541) Compatible with the Qos0 PUBREL packet (#575) Bugfix: function_clause exception occurs when registering a duplicated authentication module (#542) Bugfix: ./emqttd_top msg_q result: {\"init terminating in do_boot\",{undef,[{etop,start,[],[]},{init,start_it,1,[]},{init,start_em,1,[]}]}} (#557) Dashboard插件 WebSocket连接页面支持Clean Session, Qos, Retained参数设置 (emqttd_dashboard#52) 升级eSockd库到4.0版本，Overview页面显示OTP版本 (emqttd_dashboard#61) Changing dashboard credentials for username authentication (emqttd_dashboard#56) 新增'./bin/emqttd_ctl admins'管理命令，支持通过命令行重新设置admin密码 HTTP认证插件 支持通过HTTP API认证/鉴权MQTT客户端: https://github.com/emqtt/emqttd_auth_http MongoDB认证插件 升级Erlang Mongodb驱动到v1.0.0 (emqttd_plugin_mongo#1) 支持超级用户认证 支持基于MongoDB的ACL (emqttd_plugin_mongo#3) MySQL认证插件 支持超级用户认证 采用参数化查询避免SQL注入 Postgre认证插件 支持超级用户认证 采用参数化查询避免SQL注入 Redis认证插件 支持超级用户认证 支持ClientId认证/ACL (emqttd_plugin_redis#4) Reloader插件 开发调试代码热升级插件: https://github.com/emqtt/emqttd_reloader 1.0.2 版本 发布日期: 2016-05-04 Issue#534 - './bin/emqttd_ctl vm' - add 'port/count', 'port/limit' statistics Issue#535 - emqttd_client should be terminated properly even if exception happened when sending data PR#519 - The erlang '-name' requires the fully qualified host name emqttd_reloader plugin - help reload modified modules during development. 1.0.1 版本 发布日期: 2016-04-16 PR#515 - Fix '$queue' pubsub, add 'pubsub_queue' test and update docs 1.0 (七英里) 版本 发布日期: 2016-04-13 版本别名: 七英里(The Seven Mile Journey) 经过两年开发，五十个版本迭代，我们正式发布1.0(七英里)版本，和完整的中英文项目文档。 1.0版本基本实现了设计目标: 稳定承载来自移动互联网或物联网终端的大量并发MQTT连接，并实现在大数量的终端间快速低延时的MQTT消息路由。 完整支持MQTT V3.1.1协议，扩展支持WebSocket、Stomp或私有TCP等多协议。 稳定承载大规模的并发MQTT客户端连接，单服务器节点支持50万到100万连接。 分布式节点集群或桥接，快速低延时的消息路由，单集群支持1000万规模的路由。 支持消息服务器内扩展，支持定制多种认证方式，插件方式存储消息到后端数据库。 问题与改进 1.0版本主要发布完整项目文档，相比0.17.1版本很少代码变更: Possible race condition using emqttd_cm (#486) Improve the design of retained message expiration (#503) Should not expire the retained messages from $SYS/# topics (#500) 项目文档 1.0 版本中文文档: http://emqtt.com/docs/ 或 http://docs.emqtt.cn 1.0 版本英文文档: https://developer.emqx.io/docs/emq/v1/en/index.html 或 http://docs.emqtt.com/ 官方站点 中文站点: http://emqtt.com 英文站点: https://www.emqx.io/ 致谢 爱立信与Erlang/OTP语言平台团队(http://www.erlang.org/)! 贡献者(GitHub帐户): @callbay @lsxredrain @hejin1026 @desoulter @turtleDeng @Hades32 @huangdan @phanimahesh @dvliman @Prots @joaohf 公司: 开源中国，鲁能电力，太极计算机，电信天翼云直播，研色科技，杭州华思 乐队: 七英里(The Seven Mile Journey)，腰乐队，万能青年旅店 0.17.1-beta 版本 发布日期: 2016-03-22 Enhancements Time unit of session 'expired_after' changed to minute. (#479) Dashboard Code Review and improve the design of Dashboard. 0.17.0-beta 版本 发布日期: 2016-03-15 Highlights Installation and Configuration Guide released on http://docs.emqtt.com Improve and Consolidate the design of Hook, Server, PubSub and Router Upgrade the [Web Dashboard](https://github.com/emqtt/emqttd_dashboard) to support pagination Bridge emqttd broker to another emqttd broker & emqttd to mosquitto bridge (#438) Enhancements emqttd_ctl: better error message (#450) ./bin/emqttd_ctl: add 'routes' command ` routes list # List all routes routes show # Show a route` Add 'backend_subscription' table and support static subscriptions (emqttd_backend) Add 'retained_message' table and refactor emqttd_retainer module (emqttd_backend) A New Hook and Callback Design (emqttd_hook) Add PubSub, Hooks APIs to emqttd module (emqttd) Move start_listeners/0, stop_listeners/0 APIs to emqttd_app module (emqttd_app) Tests Add 100+ common test cases. Plugins Upgrade Dashboard, Redis, Stomp and Template Plugins 0.16.0-beta 版本 发布日期: 2016-02-16 Highlights Licensed under the Apache License, Version 2.0 Now. Improve the design of cluster, support to join or leave the cluster (#449): ` $ ./bin/emqttd_ctl cluster cluster join #Join the cluster cluster leave #Leave the cluster cluster remove #Remove the node from cluster cluster status #Cluster status` Improve the design of Trie and Route, only the wildcard topics stored in Trie. Common Test to replace EUnit. Enhancements mqtt_message record: add 'sender' field (#440) refactor the emqttd, emqttd_time, emqttd_opts, emqttd_node modules. Bugfix noproc error when call to gen_server2:call(false, {add_route,Topic,\\}, infinity) (#446) #### Plugins Changed the license of all plugins. 0.15.0-beta 版本 发布日期: 2016-01-31 Highlights Optimize for Push Application, 500K+ Subscribers to a Topic. Optimization for Route ETS insertion (#427) Priority Message Queue for Persistent Session (#432) Add Redis, MongoDB Plugins (#417) Enhancements Username/Password Authentication: Support to configure default users (#428) Improve CLI Commands: pubsub, bridges, trace (#429) emqttd_mod_subscription: fix client_connected/3 emqttd_auth_mod: add passwd_hash/2 function priority_queue: add plen/2, out/2 functions Bugfix Fix dequeue/1 of emqttd_bridge... Add emqttd:seed_now/0 function Plugins emqttd_plubin_mysql: Changed mysql driver to mysql-otp emqttd_plugin_pgsql: Integrate with ecpool emqttd_plugin_redis: First release emqttd_plugin_mongo: First release 0.14.1-beta 版本 发布日期: 2015-12-28 Bugfix: emqttd_ws_client.erl: Unexpected Info: {'EXIT',\\,{shutdown,destroy}} (#413) Improve: fix spec errors found by dialyzer 0.14.0-beta 版本 发布日期: 2015-12-18 Highlights Scaling to 1.3 Million Concurrent MQTT Connections on a 12 Core, 32G CentOS server. New PubSub, Router Design (#402). Prepare for scaling to 10 millions on one cluster. Enhancements Improve the gproc_pool usage with a general emqttd_pool_sup Improve the design of emqttd_pubsub, add a new emqttd_router module Improve the design of the whole supervisor tree Route aging mechanism to remove the topics that have no subscriptions Improve the dashboard, mysql, pgsql, stomp, sockjs plugins Add 'topics', 'subscriptions' admin commands Avoid using mnesia table index and mnesia:index_read API to lower CPU usage Subscribe timeout exception (#366) Long Delay on Multiple Topic Subscription (#365) Subscriptions persistence (#344) emqttd_ctl: 'subscriptions' command to force clients to subscribe some topics (#361) Bugfix emqttd_sm: spec of lookup_session/1 is not right BUG (#411) Observer application should be removed from reltool.config for 'wx' app is not available (#410) Benchmark 1.3 million concurrent MQTT connections on a 12 Core, 32G CentOS Server, consume about 15G Memory and 200% CPU. 0.13.1-beta 版本 发布日期: 2015-11-28 Bugfix: Plugin pathes error under windows (#387) Improve: Too many error logs \"[error] Session ..... Unexpected EXIT: client_pid=\\, exit_pid=\\, reason=nop...\" (#383) Improve: Define QOS0/1/2, Pooler Error (PR#382) Improve: High CPU load when 400K unstable mobile connections (#377) BugFix: emqttd_plugin_pgsql - error using same query with latest update plugin (pgsql#5) 0.13.0-beta 版本 发布日期: 2015-11-08 Highlights Rate Limiting based on [Token Bucket](https://en.wikipedia.org/wiki/Token_bucket) and [Leaky Bucket](https://en.wikipedia.org/wiki/Leaky_bucket#The_Leaky_Bucket_Algorithm_as_a_Meter) Algorithm Upgrade eSockd and MochiWeb libraries to support Parameterized Connection Module Improve emqttd_client to support fully asynchronous socket networking Enhancements Protocol Compliant - Session Present Flag (#163) Compilation fails if repo is cloned with a different name (#348) emqttd_client: replace gen_tcp:send with port_command (#358) TCP sndbuf, recbuf, buffer tuning (#359) emqttd_client.erl to handle 'inet_async', 'inet_reply' properly (#360) Refator the [client/session management design](https://github.com/emqtt/emqttd/blob/master/doc/design/ClientSession.md) Bugfix Cannot kick transient client out when clientId collision (#357) Fix the order of emqttd_app:start_server/1 (#367) emqttd_ will crash (#374) Benchmark [benchmark for 0.13.0 release](https://github.com/emqtt/emqttd/wiki/benchmark-for-0.13.0-release) 3.1G memory and 50+ CPU/core: Connections: 250K Subscribers: 250K Topics: 50K Qos1 Messages/Sec In: 4K Qos1 Messages/Sec Out: 20K Traffic In(bps): 12M+ Traffic Out(bps): 56M+ 0.12.3-beta 版本 发布日期: 2015-10-22 Bugfix: emqttd_sysmon crasher for 'undefined' process_info (#350) Bugfix: emqttd_client: catch parser exception (#353) 0.12.2-beta 版本 发布日期: 2015-10-16 Bugfix: Retained messages should not be expired if 'broker.retained.expired_after = 0' (#346) 0.12.1-beta 版本 发布日期: 2015-10-15 Highlight: Release for Bugfix and Code Refactor. Feature: Retained message expiration (#182) Improve: '$SYS/#' publish will not match '#' or '+/#' (#68) Improve: Add more metrics and ignore '$SYS/#' publish (#266) Improve: emqttd_sm should be optimized for clustered nodes may be crashed (#282) Improve: Refactor emqttd_sysmon and suppress 'monitor' messages (#328) Task: benchmark for 0.12.0 release (#225) Benchmark: About 900K concurrent connections established on a 20Core, 32G CentOS server. 0.12.0-beta 版本 发布日期: 2015-10-08 Highlights Enhance the emqttd_ctl module to allow plugins to register new commands (#256) Add [emqttd_recon plugin](https://github.com/emqtt/emqttd_recon) to debug/optimize the broker (#235) Add './bin/emqttd_ctl broker pubsub' command to check the status of core pubsub processes Add './bin/emqttd_top' command(like etop) to show the top 'msg_q', 'reductions', 'memory' or 'runtime' processes 'rel/files/emqttd.config.production' for production deployment(default) 'rel/files/emqttd.config.development' for development deployment Enhancements Qos1/2 messages will not be dropped under unstable mobile network (#264) emqttd_, emqttd_ APIs should be asynchronous (#292) etc/emqttd.config: 'idle_timeout' option to close the idle client(socket connected but no 'CONNECT' frame received) etc/emqttd.config: 'unack_retry_interval' option for redelivering Qos1/2 messages How to monitor large 'message_queue_len' (#283) Bugfix Behaviour emqttd_auth_mod is missing init callback (#318) Benchmark Write a new [benchmark tool](https://github.com/emqtt/emqtt_benchmark) to benchmark this release Hw requirements - 5K users, 25-50 msgs/sec, QoS=1 (#209) Supported Number of Connections Greatly Reduced When Clients are Subscribing (#324) 0.11.0-beta 版本 发布日期: 2015-09-25 Highlight: Rebar to manage plugin dependencies. Highlight: [Stomp](https://github.com/emqtt/emqttd_stomp) and [SockJS](https://github.com/emqtt/emqttd_sockjs) Plugins! Improve: add rel/files/emqttd.config.development|production. Improve: rel/reltool.config.script to release deps of plugin. Improve: persist mnesia schema on slave nodes. Improve: use timer:seconds/1 api. Improve: The binary release will be compiled with R18.1 now. Bugfix: issue#306 - emqttd_cm should unregister the duplicated client Bugfix: issue#310 - usage of emqttd_ctl error: 'session list' should be 'sessions list' Bugfix: issue#311 - './bin/emqttd_ctl sessions list' error Bugfix: issue#312 - unsubcribe will lead to crash if emqttd_plugin_template plugin loaded 0.10.4-beta 版本 发布日期: 2015-09-18 Optimize session management and upgrade eSockd library to 2.7.1 [Benchmark for 0.10.4 release](https://github.com/emqtt/emqttd/wiki/benchmark-for-0.10.4-release) Improve: issue#294 - [error] failed to start connection on 0.0.0.0:1883 - enotconn Improve: issue#297 - How do I allow user with some pattern to access topic with some pattern? Bugfix: issue#291 - \"./bin/emqttd attach ...\" cannot work Bugfix: issue#284 - Should not use erlang:list_to_atom/1 in emqttd_vm.erl 0.10.3-beta 版本 发布日期: 2015-08-30 Bugfix: issue#271 - add emqttd_ws_client:subscribe/2 function Bugfix: issue#269 - bin/emqttd Syntax error on ubuntu Improve: issue#265 - client under unstable mobile network generate a lot of logs 0.10.2-beta 版本 发布日期: 2015-08-26 Improve: issue#257 - After the node name changed, the broker cannot restart for mnesia schema error. 0.10.1-beta 版本 发布日期: 2015-08-25 Bugfix: issue#259 - when clustered the emqttd_dashboard port is close, and the 'emqttd' application cannot stop normally. Feature: issue#262 - Add 'http://host:8083/mqtt/status' Page for health check 0.10.0-beta 版本 发布日期: 2015-08-20 [Web Dashboard](https://github.com/emqtt/emqttd_dashboard) and [MySQL](https://github.com/emqtt/emqttd_plugin_mysql), [PostgreSQL](https://github.com/emqtt/emqttd_plugin_pgsql) Authentication/ACL Plugins! Highlight: Web Dashboard to monitor Statistics, Metrics, Clients, Sessions and Topics of the broker. Highlight: JSON/HTTP API to query all clients connected to broker. Highlight: A new [Plugin Design](https://github.com/emqtt/emqttd/wiki/Plugin%20Design) and a [Template project](https://github.com/emqtt/emqttd_plugin_template) for plugin development. Highlight: Authentication/ACL with MySQL, PostreSQl databases (#194, #172) Feature: Session Statistics including inflight_queue, message_queue, message_dropped, awaiting_rel, awaiting_ack, awaiting_comp (#213) Feature: Cookie based authentication for MQTT over websocket connections (#231) Feature: Get all clients connected to the broker (#228, #230, #148, #129) Feature: \"./bin/emqttd_ctl clients show ClientId\" to query client status (#226) Feature: \"./bin/emqttd_ctl clients kick ClientId\" to kick out a client Feature: \"./bin/emqttd_ctl sessions list\" to show all sessions Feature: \"./bin/emqttd_ctl sessions show ClientId\" to show a session Feature: Erlang VM metrics monitor with Web Dashboard (#59) Improve: Too many \"inflight queue is full!\" log when session is overloaded (#247) Improve: There are two many \"MQueue(~s) drop ~s\" logs if the message queue of session is small (#244) Improve: gen_server2(from RabbitMQ) to improve emqttd_session, emqttd_pubsub Improve: Makefile to build plugins Bugfix: emqttd_broker:unhook/2 cannot work (#238) Bugfix: emqttd plugin cannot include_lib(\"emqttd/include/emqttd.hrl\") (#233) Bugfix: Too many 'Session ~s cannot find PUBACK' logs (#212) Bugfix: emqttd_pooler cannot work 0.9.3-alpha 版本 发布日期: 2015-07-25 Wiki: [Bridge](https://github.com/emqtt/emqttd/wiki/Bridge) Improve: emqttd_protocol.hrl to define 'QOS_I' Improve: emqttd_pubsub to add subscribe/2 API Improve: ./bin/emqttd_ctl to support new bridges command Bugfix: issue #206 - Cannot bridge two nodes 0.9.2-alpha 版本 发布日期: 2015-07-18 Improve: issue #196 - Add New Hook 'client.subscribe.after' 0.9.1-alpha 版本 发布日期: 2015-07-10 Bugfix: issue #189 - MQTT over WebSocket(SSL) cannot work? Bugfix: issue #193 - 'client.ack' hook should be renamed to 'message.acked', and called by emqttd_broker:foreach_hooks 0.9.0-alpha 版本 发布日期: 2015-07-09 [Session, Queue, Inflight Window, Hooks, Global MessageId and More Protocol Compliant](https://github.com/emqtt/emqttd/releases/tag/0.9.0-alpha) Now! Feature: Session/Queue/Inflight Window Design (#145). Feature: Support to resume a persistent session on other clustered node. Feature: Support alarm management. Feature: emqttd_guid to generate global unique message id. Feature: Hooks for message pub/ack. Feature: Protocol compliant - message ordering, timeout and retry. Improve: Every client will start_link a session process, whether or not the client is persistent. Improve: etc/emqttd.config to support more session, queue configuration. Improve: issue #179 - Max offline message queue {max_queue, 100} meaning. Improve: issue #180 - Should change project structure for other projects maybe depend on 'emqttd'. Merge emqtt, emqttd apps. Improve: issue #185 - PacketId and MessageId: the broker should generate global unique message id. Improve: issue #187 - etc/emqttd.config to support https listener Improve: issue #186 - emqttd_cm to store client details Improve: issue #174 - add 'from' field to mqtt_message record. Improve: issue #170 - $SYS Topics should support alarms. Improve: issue #169 - Add More [Hooks](https://github.com/emqtt/emqttd/wiki/Hooks-Design) Improve: issue #167 - Inflight window to assure message ordering. Improve: issue #166 - Message delivery timeout and retry. Improve: issue #143 - Qos1, Qos2 PubSub message timeout. Improve: issue #122 - Labeling message with unique id. emqttd_guid module to generate global unique msgid. Improve: emqttd_bridge to support pending message queue, and fix the wrong Qos design. Improve: mqtt_message record to add 'msgid', 'from' and 'sys' fields. Change: Add emqttd_mqueue, emqttd_guid, emqttd_alarm modules. Bugfix: issue #184 - emqttd_stats:setstats is not right. Bugfix: Closed issues #181, #119. Tests: fix the parser, acl test cases. 0.8.6-beta 版本 发布日期: 2015-06-17 Bugfix: issue #175 - publish Will message when websocket is closed without 'DISCONNECT' packet 0.8.5-beta 版本 发布日期: 2015-06-10 Bugfix: issue #53 - client will receive duplicate messages when overlapping subscription 0.8.4-beta 版本 发布日期: 2015-06-08 Bugfix: issue #165 - duplicated message when publish 'retained' message to persistent client 0.8.3-beta 版本 发布日期: 2015-06-05 Bugfix: issue #158 - should queue:in new message after old one dropped Bugfix: issue #155 - emqtt_parser.erl: parse_topics/3 should reverse topics Bugfix: issue #149 - Forget to merge plugins/emqttd_auth_mysql from 'dev' branch to 'master' in 0.8.x release 0.8.2-alpha 版本 发布日期: 2015-06-01 Bugfix: issue #147 - WebSocket client cannot subscribe queue '$Q/queue/${clientId}' Bugfix: issue #146 - emqttd_auth_ldap: fill(Username, UserDn) is not right 0.8.1-alpha 版本 发布日期: 2015-05-28 Client [Presence](https://github.com/emqtt/emqttd/wiki/Presence) Support and [$SYS Topics](https://github.com/emqtt/emqttd/wiki/$SYS-Topics) Redesigned! Bugfix: issue #138 - when client disconnected normally, broker will not publish disconnected $SYS message Bugfix: fix websocket url in emqttd/priv/www/websocket.html Improve: etc/emqttd.config to allow websocket connections from any hosts Improve: rel/reltool.config to exclude unnecessary apps. 0.8.0-alpha 版本 发布日期: 2015-05-25 [Hooks](https://github.com/emqtt/emqttd/wiki/Hooks%20Design), Modules and [Plugins](https://github.com/emqtt/emqttd/wiki/Plugin%20Design) to extend the broker Now! Plugin: emqttd_auth_mysql - MySQL authentication plugin (issues #116, #120) Plugin: emqttd_auth_ldap - LDAP authentication plugin Feature: emqttd_broker to support Hooks API Feature: issue #111 - Support 'Forced Subscriptions' by emqttd_mod_autosub module Feature: issue #126 - Support 'Rewrite rules' by emqttd_mod_rewrite module Improve: Support hooks, modules to extend the broker Improve: issue #76 - dialyzer check Improve: 'Get Started', 'User Guide', 'Developer Guide' Wiki Improve: emqtt_topic to add join/1, feed_var/3, is_queue/1 Improve: emqttd_pooler to execute common tasks Improve: add emqttd_sm_sup module, and use 'hash' gproc_pool to manage sessions Tests: add more test cases for 'emqttd' app 0.7.1-alpha 版本 发布日期: 2015-05-04 Add doc/design/* and merge doc/* to github Wiki Bugfix: issue #121 - emqttd cluster issuse Bugfix: issue #123 - emqttd:unload_all_plugins/0 cannot unload any plugin Bugfix: fix errors found by dialyzer 0.7.0-alpha 版本 发布日期: 2015-05-02 [MQTT over WebSocket(SSL)](https://github.com/emqtt/emqttd/wiki/MQTT-Over-WebSocket) Now! [Plugin Achitecture](https://github.com/emqtt/emqttd/wiki/Plugin%20Design) based on OTP application [Trace MQTT Packets or Messages](https://github.com/emqtt/emqttd/wiki/Trace%20Design) to log files Feature: issue #40, #115 - WebSocket/SSL Support Feature: issue #49, #105 - Plugin Architecture Support Feature: issue #93 - Trace API Design Improve: issue #109 - emqttd_broker should add subscribe, notify API Improve: update README.md to add 'Goals', 'Contributors' chapters Change: rename etc/app.config to etc/emqttd.config Change: etc/emqttd.config changed Bugfix: critical issue #54 - error when resume session! Bugfix: issue #118 - error report when UNSUBSCRIBE with no topics Bugfix: issue #117 - sys_interval = 0 config cannot work Bugfix: issue #112 - Makefile to support build plugins Bugfix: issue #96 - \"make clean\" cannot work 0.6.2-alpha 版本 发布日期: 2015-04-24 Bugfix: critical issue #54, #104, #106 - error when resume session Improve: add emqttd_cm_sup module, and use 'hash' gproc_pool to register/unregister client ids Improve: kick old client out when session is duplicated. Improve: move mnesia dir config from etc/app.config to etc/vm.args 0.6.1-alpha 版本 发布日期: 2015-04-20 Integrate with [gproc library](https://github.com/uwiger/gproc) to support pool Feature: issues#91 - should use worker_pool to handle some async work? Feature: issues#95 - Topic filters in ACL rule should support 'eq' tag Improve: issues#84 - emqttd_pubsub is redesigned again to protect mnesia transaction Improve: issues#74 - ACL Support and update [ACL Design Wiki](https://github.com/emqtt/emqttd/wiki/ACL-Design) 0.6.0-alpha 版本 发布日期: 2015-04-17 ACL Support Now: [ACL-Design Wiki](https://github.com/emqtt/emqttd/wiki/ACL-Design) Authentication with username, clientid Now: [Authentication Wiki](https://github.com/emqtt/emqttd/wiki/Authentication) Seperate common MQTT library to 'emqtt' application Redesign message pubsub, route and retain modules Redesign mnesia database cluster Feature: issues#47 - authentication, authorization support Feature: issues#92 - merge emqttd_acl and emqttd_auth to emqttd_access_control Feature: emqttd_acl_mod, emqttd_auth_mod behaviour to extend ACL, authentication Feature: issues#85 - lager:info to log subscribe, unsubscribe actions Feature: issues#77 - authentication with clientid, ipaddress Improve: issues#90 - fix lager_file_backend log format, and rotate 10 log files Improve: issues#88 - use '-mneisa_create', '-mnesia_replicate' attributes to init mneisa Improve: issues#87 - record mqtt_user and mqtt_client is duplicated Improve: issues#81 - redesign nodes cluster to support disc_copies mnesia tables Improve: issues#80 - redesign emqttd_cm to handle more concurrent connections Improve: issues#70 - how to handle connection flood? Now could support 2K+ CONNECT/sec Change: redesign mnesia tables: message, topic, subscriber, trie, trie_node Bugfix: issues#83 - emqttd_broker stats cannot work Bugfix: issues#75 - careless about function name when emqttd_pubsub handle getstats message 0.5.5-beta 版本 发布日期: 2015-04-09 Bugfix: issue #75 - careless about function name when emqttd_pubsub handle getstats message. Bugfix: issue #79 - cannot find topic_subscriber table after cluster with other nodes. 0.5.4-alpha 版本 发布日期: 2015-03-22 Benchmark this release on a ubuntu/14.04 server with 8 cores, 32G memory from QingCloud.com: : 200K Connections, 30K Messages/Sec, 20Mbps In/Out Traffic, 200K Topics, 200K Subscribers, Consumed 7G memory, 40% CPU/core Benchmark code: https://github.com/emqtt/emqttd_benchmark Change: rewrite emqttd_pubsub to handle more concurrent subscribe requests. Change: ./bin/emqttd_ctl add 'stats', 'metrics' commands. Bugfix: issue #71, #72 0.5.3-alpha 版本 发布日期: 2015-03-19 Bugfix: issues#72 - emqttd_cm, emqtt_sm ets:match_delete/2 with wrong pattern 0.5.2-alpha 版本 发布日期: 2015-03-18 Change: upgrade esockd to 2.1.0-alpha, do not tune socket buffer for mqtt connection. 0.5.1-alpha 版本 发布日期: 2015-03-13 Change: upgrade esockd to v1.2.0-beta, rename 'acceptor_pool' to 'acceptors' 0.5.0-alpha 版本 发布日期: 2015-03-12 RENAME 'emqtt' to 'emqttd'! Support [Broker Bridge](https://github.com/emqtt/emqttd/wiki/Bridge-Design) Now! Change: rename project from 'emqtt' to 'emqttd' Change: lager:debug to dump RECV/SENT packets Feature: emqttd_bridge, emqttd_bridge_sup to support broker bridge Feature: emqtt_event to publish client connected/disconnected message to $SYS topics Feature: ./bin/emqttd_ctl add more commands: listeners, broker, bridges, start_bridge, stop_bridge... Feature: issue#57 - support to configure max packet size Feature: issue#68 - if sys_interval = 0, emqttd_broker will not publish messages to $SYS/brokers/# Bugfix: issue#67 - subscribe '#' to receive all messages Bugfix: issue#64 - emqtt_app start/2: should wait_for_databases Test: emqttd_topic_tests add more '_match_test' 0.4.0-alpha 版本 发布日期: 2015-03-10 Support [$SYS Topics of Broker](https://github.com/emqtt/emqttd/wiki/$SYS-Topics-of-Broker) Now! Feature: emqtt_broker to publish version, uptime, datetime to $SYS/brokers/# topics Feature: emqtt_broker to publish count of clients, sessions, suscribers to $SYS/brokers/# topics Feature: emqtt_metrics to publish bytes, packets, messages metrics to $SYS/brokers/# topics Feature: add include/emqtt_systop.hrl Change: emqtt_cm to count current clients Change: emqtt_sm to count current sessions Change: emqtt_pubsub to count current topics and suscribers Change: emqtt_pubsub to add create/1 API Change: emqtt_pubsub dispatch/2 to return number of subscribers Change: emqtt_pubsub to count 'dropped' messages Change: emqtt_opts to add merge/2 function Test: add emqtt_serialiser_tests.erl 0.3.4-beta 版本 发布日期: 2015-03-08 Bugfix: emqtt_serialiser.erl cannot serialise UNSUBACK packets 0.3.3-beta 版本 发布日期: 2015-03-07 Bugfix: emqtt_serialiser.erl cannot serialise PINGRESP issue#60 0.3.2-beta 版本 发布日期: 2015-03-05 Improve: merge emqttc serialiser, parser, packet Add: emqtt_opts to merge socket options 0.3.1-beta 版本 发布日期: 2015-03-02 Feature: SSL Socket Support Feature: issue#44 HTTP API should add Qos parameter Bugfix: issue#52 emqtt_session crash Bugfix: issue#53 sslsocket keepalive error Upgrade: esockd to v0.2.0 Upgrade: mochiweb to v3.0.0 0.3.0-beta 版本 发布日期: 2015-01-19 Feature: HTTP POST API to support 'qos', 'retain' parameters Feature: $SYS system topics support Change: Rewrite emqtt_topic.erl, use '', '#', '+' to replace \\>, \\>, \\> Change: fix emqtt_pubsub.erl to match '#', '+' Tests: emqtt_topic_tests.erl add more test cases 0.3.0-alpha 版本 发布日期: 2015-01-08 NOTICE: Full MQTT 3.1.1 support now! Feature: Passed org.eclipse.paho.mqtt.testing/interoperability tests Feature: Qos0, Qos1 and Qos2 publish and suscribe Feature: session(clean_sess=false) management and offline messages Feature: redeliver awaiting puback/pubrec messages(doc: Chapter 4.4) Feature: retain messages, add emqtt_server module Feature: MQTT 3.1.1 null client_id support Bugfix: keepalive timeout to send will message Improve: overlapping subscription support Improve: add emqtt_packet:dump to dump packets Test: passed org.eclipse.paho.mqtt.testing/interoperability Test: simple cluster test Closed Issues: #22, #24, #27, #28, #29, #30, #31, #32, #33, #34, #36, #37, #38, #39, #41, #42, #43 0.2.1-beta 版本 发布日期: 2015-01-08 pull request 26: Use binaries for topic paths and fix wildcard topics emqtt_pubsub.erl: fix wildcard topic match bug caused by binary topic in 0.2.0 Makefile: deps -> get-deps rebar.config: fix mochiweb git url tag emqtt release accoding to [Semantic Versioning](http://semver.org/) max clientId length is 1024 now. 0.2.0 版本 发布日期: 2014-12-07 rewrite the project, integrate with esockd, mochiweb support MQTT 3.1.1 support HTTP to publish message 0.1.5 版本 发布日期: 2013-01-05 Bugfix: remove QOS_1 match when handle PUBREL request Bugfix: reverse word in emqtt_topic:words/1 function 0.1.4 版本 发布日期: 2013-01-04 Bugfix: fix \"mosquitto_sub -q 2 ......\" bug Bugfix: fix keep alive bug 0.1.3 版本 发布日期: 2013-01-04 Feature: support QOS2 PUBREC, PUBREL,PUBCOMP messages Bugfix: fix emqtt_frame to encode/decoe PUBREC/PUBREL messages 0.1.2 版本 发布日期: 2012-12-27 Feature: release support like riak Bugfix: use ?INFO/?ERROR to print log in tcp_listener.erl 0.1.1 版本 发布日期: 2012-09-24 Feature: use rebar to generate release Feature: support retained messages Bugfix: send will msg when network error 0.1.0 版本 发布日期: 2012-09-21 The first public release. .emqxee { display: none; }"},"changes/upgrade.html":{"url":"changes/upgrade.html","title":"升级指南","summary":null,"keywords":"","body":"升级指南升级到 4.0 版本核心REST APIDashboard规则引擎升级到3.1版本2.0升级到2.0.3版本升级到2.0版本升级到1.1.2版本升级指南 升级到 4.0 版本 下文提供了一套从 EMQ X 3.x 版本迁移到最新 EMQ X 4.0 版本的准则。尽管我们试图减少一些重大更改，但为了兼顾性能、简化使用方式，我们在几个地方进行了修改。 EMQ X 3.x 版本迁移 EMQ X 4.0 要花多长时间？ EMQ X 始终保证接入协议的规范性和持续更新，版本迁移时客户端部分 无需做任何调整，这意味着您无需停止设备功能、重新烧录设备程序固件。您仅需关注插件、配置项、命令行以及 REST API 的变更。 所需时长取决于您的项目规模和变更涉及范围，中小型的项目基本一天内就可以搞定。 核心 client_id 改为 clientid 在此处变量命名上我们做了较大的变动，EMQ X 内部所有 client_id 字符都更改为 clientid，包括： REST API 的 URL、请求/相应数据中的字段名称 源代码中的命名规范 命令行 CLI REST API v3 改为 v4 REST API 由 http(s)://host:8081/api/v3/ 变更为 http(s)://host:8081/api/v4/。 连接 (connection) 改为客户端 (clients) 将 connections 概念改为 clients，涉及节点与集群相关的 API： 获取集群连接列表：GET /connections -> /clients 获取集群指定连接信息：GET /connections/:clientid -> GET /connections/:clientid 获取节点连接列表：GET /nodes/:node/connections -> GET /nodes/:node/clients 获取节点指定连接信息：GET /nodes/:node/connections/:clientid -> GET /nodes/:node/clients/:clientid 请求/相应数据中的 client_id 字段名称均变为 clientid 同时 API 返回内容有较大变动，变动部分详见 4.0 文档。 移除会话 (session) 相关的 API 4.0 中引入 Channel 概念，将会话 (session) 和客户端 (client) 合二为一，4.0 版本中以下 API 已被 移除： 获取集群会话列表：GET /sessions 获取集群指定客户端会话信息：GET /sessions/:clientid 获取节点会话列表：GET /nodes/:node/sessions 获取节点指定客户端会话信息：GET /nodes/:node/sessions/:clientid 4.0 以后如需获取会话相关信息，请使用客户端相关 API。 移除插件配置获取与更改 API 插件配置中可能包含敏感信息，同时插件配置不支持持久化为用户使用带来了很大疑惑。考虑到安全问题与实用性问题，我们 移除 了插件获取与更改 API。 获取插件配置信息：GET /nodes/:node/plugins/:plugin_name 更新插件配置：PUT /nodes/:node/plugins/:plugin_name 我们计划在 企业版 中通过安全规范及配置项本地存储提供解决以上问题，重新提供插件热配置相关的 API 以，*目前企业版本已经支持关键配置的热配置操作*。 Dashboard 连接 (connection) 改为客户端 (clients) Dashboard 中 连接 (connections) 概念改为 客户端 (clients)，原连接信息可在现 客户端 (clients) 页面查看。 移除 会话 (sessions) 管理页面 Dashboard 中移除 会话 (sessions) 管理页面，相关信息整合到 客户端 (clients) 页面中。 规则引擎 规则引擎 SQL 语法有所变动，规则创建时 Dashboard 中不再提供 事件 下拉选择框，SQL 语法详细变更参照本文 规则引擎 部分。 规则引擎 SQL 语法变更 4.0 版本中规则引擎 SQL 语法更加易用，3.x 版本中所有事件 FROM 子句后面均需要指定事件名称，4.0 以后我们引入 事件主题 概念，默认情况下 消息发布 事件不再需要指定事件名称： ## 3.x 版本 ## 需要指定事件名称进行处理 SELECT * FROM \"message.publish\" WHERE topic =~ 't/#' ## 4.0 及以后版本 ## 默认处理 message.publish 事件, FROM 后面直接筛选 MQTT 主题 ## 上述 SQL 语句等价于: SELECT * FROM 't/#' ## 其他事件通过 事件主题 进行筛选 SELECT * FROM \"$events/message_acked\" where topic =~ 't/#' SELECT * FROM \"$events/client_connected\" Dashboard 中提供了旧版 SQL 语法转换功能可以完成 SQL 升级迁移。 事件名称变更 4.0 版本中 订阅/取消订阅 主体变为 会话 (session)，*事件* 在转换为 事件主题 时，需要注意以下变更： 终端订阅 变更为 会话订阅：client.subscribe -> $events/session_subscribe 终端取消订阅 变更为 会话取消订阅：client.unsubscribe -> $events/session_unsubscribe 升级到3.1版本 Note 3.1版本全新设计了项目架构、配置方式与插件管理方式。2.x与1.x版本升级需要重新配置部署。 升级流程: 下载解压3.1版本到新安装目录，例如 /opt/emqx-3.1/； 参考旧版本 etc/vm.args、etc/emqttd.config 或 etc/emq.conf，配置3.1版本的 etc/emqx.conf； 重新配置插件 etc/plugins/${your-plugin}.conf； 编辑插件加载文件 data/loaded_plugins； 停止旧版本，启动新版。 2.0升级到2.0.3版本 升级流程: 下载解压2.0.3版本到新安装目录，例如 /opt/emqttd-2.0.3/； 旧版本的 'etc/' 配置文件、'data/' 数据文件覆盖到新版目录； 停止旧版本，启动新版。 升级到2.0版本 Note 2.0版本全新设计了项目架构、配置方式与插件管理方式。1.x版本升级需要重新配置部署。 升级流程: 下载解压2.0版本到新安装目录，例如 /opt/emqttd-2.0/ 参考旧版本 etc/vm.args、etc/emqttd.config，配置2.0版本的 etc/emq.conf 重新配置插件 etc/plugins/${your-plugin}.conf 编辑插件加载文件 data/loaded_plugins 停止旧版本，启动新版。 升级到1.1.2版本 Note 1.0以后版本可平滑升级到1.1.2 升级流程: 下载解压1.1.2版本到新安装目录，例如 /opt/emqttd_112； 旧版本的 'etc/' 配置文件、'data/' 数据文件覆盖到新版目录； 如果有加载插件，将旧版插件配置文件覆盖到新版； 停止旧版本，启动新版。 .emqxee { display: none; }"},"design/design.html":{"url":"design/design.html","title":"架构设计","summary":null,"keywords":"","body":"架构设计前言100 万连接全异步架构消息持久化系统架构概念模型设计原则系统分层连接层设计会话层设计报文 ID 与消息 ID路由层设计分布层设计Mnesia/ETS 表设计Erlang 设计相关架构设计 前言 EMQ X 在设计上，首先分离了前端协议 (FrontEnd) 与后端集成 (Backend)，其次分离了消息路由平面 (Flow Plane) 与监控管理平面 (Monitor/Control Plane): 100 万连接 多核服务器和现代操作系统内核层面，可以很轻松支持 100 万 TCP 连接，核心问题是应用层面如何处理业务瓶颈。 EMQ X 在业务和应用层面，解决了单节点承载100万连接的各类瓶颈问题。连接测试的操作系统内核、TCP 协议栈、Erlang 虚拟机参数参见: http://docs.emqtt.cn/zh_CN/latest/tune.html。 全异步架构 EMQ X 是基于 Erlang/OTP 平台的全异步的架构：异步 TCP 连接处理、异步主题 (Topic) 订阅、异步消息发布。只有在资源负载限制部分采用同步设计，比如 TCP 连接创建和 Mnesia 数据库事务执行。 EMQ X 3.0 版本中，一条 MQTT 消息从发布者 (Publisher) 到订阅者 (Subscriber)，在 EMQ X Broker 内部异步流过一系列 Erlang 进程 Mailbox: 消息持久化 EMQ X 开源产品不支持服务器内部消息持久化，这是一个架构设计选择。首先，EMQ X 解决的核心问题是连接与路由；其次，我们认为内置持久化是个错误设计。 传统内置消息持久化的 MQ 服务器，比如广泛使用的 JMS 服务器 ActiveMQ，几乎每个大版本都在重新设计持久化部分。内置消息持久化在设计上有两个问题: 如何权衡内存与磁盘的使用？消息路由是基于内存的，而消息存储是基于磁盘的。 多服务器分布集群架构下，如何放置 Queue 如何复制 Queue 的消息？ Kafka 在上述问题上，做出了正确的设计：一个完全基于磁盘分布式 Commit Log 的消息服务器。 EMQ X 在设计上分离消息路由与消息存储职责后，数据复制容灾备份甚至应用集成，可以在数据层面灵活实现。 EMQ X 企业版产品中，可以通过规则引擎或插件的方式，持久化消息到 Redis、MongoDB、Cassandra、MySQL、PostgreSQL 等数据库，以及 RabbitMQ、Kafka 等消息队列。 系统架构 概念模型 EMQ X 概念上更像一台网络路由器 (Router) 或交换机 (Switch)，而不是传统的企业级消息队列 (MQ)。相比网络路由器按 IP 地址或 MPLS 标签路由报文，EMQ X 按主题树 (Topic Trie) 发布订阅模式在集群节点间路由 MQTT 消息: 设计原则 EMQ X 核心解决的问题：处理海量的并发 MQTT 连接与路由消息。 充分利用 Erlang/OTP 平台软实时、低延时、高并发、分布容错的优势。 连接 (Connection)、会话 (Session)、路由 (Router)、集群 (Cluster) 分层。 消息路由平面 (Flow Plane) 与控制管理平面 (Control Plane) 分离。 支持后端数据库或 NoSQL 实现数据持久化、容灾备份与应用集成。 系统分层 连接层 (Connection Layer)：负责 TCP 连接处理、 MQTT 协议编解码。 会话层 (Session Layer)：处理 MQTT 协议发布订阅消息交互流程。 路由层 (Route Layer)：节点内路由派发 MQTT 消息。 分布层 (Distributed Layer)：分布节点间路由 MQTT 消息。 认证与访问控制 (ACL)：连接层支持可扩展的认证与访问控制模块。 钩子 (Hooks) 与插件 (Plugins)：系统每层提供可扩展的钩子，支持插件方式扩展服务器。 连接层设计 连接层处理服务端 Socket 连接与 MQTT 协议编解码： 基于 eSockd 框架的异步 TCP 服务端 TCP Acceptor 池与异步 TCP Accept TCP/SSL, WebSocket/SSL 连接支持 最大并发连接数限制 基于 IP 地址 (CIDR) 访问控制 基于 Leaky Bucket 的流控 MQTT 协议编解码 MQTT 协议心跳检测 MQTT 协议报文处理 会话层设计 会话层处理 MQTT 协议发布订阅 (Publish/Subscribe) 业务交互流程： 缓存 MQTT 客户端的全部订阅 (Subscription)，并终结订阅 QoS 处理 QoS 0/1/2 消息接收与下发，消息超时重传与离线消息保存 飞行窗口 (Inflight Window)，下发消息吞吐控制与顺序保证 保存服务器发送到客户端的，已发送未确认的 QoS 1/2 消息 缓存客户端发送到服务端，未接收到 PUBREL 的 QoS 2 消息 客户端离线时，保存持久会话的离线 QoS 1/2 消息 报文 ID 与消息 ID MQTT 协议定义了一个 16bits 的报文 ID (PacketId)，用于客户端到服务器的报文收发与确认。MQTT 发布报文 (PUBLISH) 进入 Broker 后，转换为一个消息对象并分配 128bits 消息 ID (MessageId)。 全局唯一时间序列消息 ID 结构: 64bits 时间戳: erlang:system_time if Erlang >= R18, otherwise os:timestamp Erlang 节点 ID: 编码为2字节 Erlang 进程 PID: 编码为4字节 进程内部序列号: 2字节的进程内部序列号 端到端消息发布订阅 (Pub/Sub) 过程中，发布报文 ID 与报文 QoS 终结在会话层，由唯一 ID 标识的 MQTT 消息对象在节点间路由: 路由层设计 路由层维护订阅者 (Subscriber) 与订阅关系表 (Subscription)，并在本节点发布订阅模式派发 (Dispatch) 消息: 消息派发到会话 (Session) 后，由会话负责按不同 QoS 送达消息。 分布层设计 分布层维护全局主题树 (Topic Trie) 与路由表 (Route Table)。主题树由通配主题构成，路由表映射主题到节点: 分布层通过匹配主题树 (Topic Trie) 和查找路由表 (Route Table)，在集群的节点间转发路由 MQTT 消息: Mnesia/ETS 表设计 Table Type Description emqx_conn ets 连接表 emqx_metrics ets 统计表 emqx_session ets 会话表 emqx_hooks ets 钩子表 emqx_subscriber ets 订阅者表 emqx_subscription ets 订阅表 emqx_admin mnesia Dashboard 用户表 emqx_retainer mnesia Retained 消息表 emqx_shared_subscription mnesia 共享订阅表 emqx_session_registry mnesia 全局会话注册表 emqx_alarm_history mnesia 告警历史表 emqx_alarm mnesia 告警表 emqx_banned mnesia 禁止登陆表 emqx_route mnesia 路由表 emqx_trie mnesia Trie 表 emqx_trie_node mnesia Trie Node 表 mqtt_app mnesia App 表 Erlang 设计相关 使用 Pool, Pool, Pool... 推荐 GProc 库: https://github.com/uwiger/gproc 异步，异步，异步消息...连接层到路由层异步消息，同步请求用于负载保护 避免进程 Mailbox 累积消息 消息流经的 Socket 连接、会话进程必须 Hibernate，主动回收 binary 句柄 多使用 Binary 数据，避免进程间内存复制 使用 ETS, ETS, ETS... Message Passing vs. ETS 避免 ETS 表非键值字段 select, match 避免大量数据 ETS 读写, 每次 ETS 读写会复制内存，可使用 lookup_element, update_counter 适当开启 ETS 表 {write_concurrency, true} 保护 Mnesia 数据库事务，尽量减少事务数量，避免事务过载(overload) 避免对 Mnesia 数据表非索引、或非键值字段 match, select .emqxee { display: none; }"},"awesome/awesome.html":{"url":"awesome/awesome.html","title":"资源","summary":null,"keywords":"","body":"资源官方资源社区、讨论、贡献和支持使用 EMQ X 的项目中文教程MQTT 规范资源 官方资源 EMQ 官方网站 EMQ 官方博客 EMQ X GitHub 仓库 社区、讨论、贡献和支持 你可通过以下途径与 EMQ 社区及开发者联系： EMQ X Slack Twitter Forum Medium Reddit 欢迎你将任何 bug、问题和功能请求提交到 emqx/emqx。 使用 EMQ X 的项目 以下是提交投稿的使用 EMQ X 的开源项目，未提交项目/商业项目不在此列： ActorCloud - 开源一站式物联网平台服务 中文教程 EMQ X 系列教程及 Erlang/IoT 相关博客、视频站点，欢迎留言或 Issues 投稿。 暂无 MQTT 规范 你可以通过以下链接了解与查阅 MQTT 协议： MQTT Version 3.1.1 MQTT Version 5.0 MQTT SN .emqxee { display: none; }"}}