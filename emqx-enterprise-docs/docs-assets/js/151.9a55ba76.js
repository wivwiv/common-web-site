(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{1433:function(a,s,t){a.exports=t.p+"docs-assets/img/schema-registry.8e2ee07b.png"},1434:function(a,s,t){a.exports=t.p+"docs-assets/img/arch.7ace76ac.png"},1435:function(a,s,t){a.exports=t.p+"docs-assets/img/SchemaAndRuleEngine.39bf7303.png"},1839:function(a,s,t){"use strict";t.r(s);var e=t(10),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"编解码-schema-registry-介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编解码-schema-registry-介绍"}},[a._v("#")]),a._v(" 编解码（Schema Registry）介绍")]),a._v(" "),e("p",[a._v("物联网设备终端种类繁杂，各厂商使用的编码格式各异，所以在接入物联网平台的时候就产生了统一数据格式的需求，以便平台之上的应用进行设备管理。")]),a._v(" "),e("p",[a._v("Schema Registry 管理编解码使用的 Schema、处理编码或解码请求并返回结果。Schema Registry 配合规则引擎，可适配各种场景的设备接入和规则设计。")]),a._v(" "),e("p",[a._v("EMQX Schema Registry 目前可支持三种格式的编解码："),e("a",{attrs:{href:"https://avro.apache.org",target:"_blank",rel:"noopener noreferrer"}},[a._v("Avro"),e("OutboundLink")],1),a._v("，"),e("a",{attrs:{href:"https://developers.google.com/protocol-buffers/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Protobuf"),e("OutboundLink")],1),a._v("，以及自定义编码。其中\nAvro 和 Protobuf 是依赖 Schema 的数据格式，编码后的数据为二进制，解码后为 Map 格式。解码后的数据可直接被规则引擎和其他插件使用。用户自定义的 (3rd-party)编解码服务通过 HTTP 或 GRPC 回调的方式，进行更加贴近业务需求的编解码。")]),a._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),e("p",[a._v("Schema Registry 为 Avro 和 Protobuf 等内置编码格式维护 Schema 文本，但对于自定义编解码\n(3rd-party) 格式，如需要，Schema 文本需由编解码服务自己维护")])]),a._v(" "),e("h2",{attrs:{id:"数据格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据格式"}},[a._v("#")]),a._v(" 数据格式")]),a._v(" "),e("p",[a._v("下图展示了 Schema Registry 的一个应用案例。多个设备上报不同格式的数据，经过 Schema Registry 解码之后，变为统一的内部格式，然后转发给后台应用。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(1433),alt:"schema-registry"}})]),a._v(" "),e("h3",{attrs:{id:"二进制格式支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制格式支持"}},[a._v("#")]),a._v(" 二进制格式支持")]),a._v(" "),e("p",[a._v("Schema Registry 数据格式包括 "),e("a",{attrs:{href:"https://avro.apache.org",target:"_blank",rel:"noopener noreferrer"}},[a._v("Avro"),e("OutboundLink")],1),a._v(" 和 "),e("a",{attrs:{href:"https://developers.google.com/protocol-buffers/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Protobuf"),e("OutboundLink")],1),a._v("。Avro 和 Protobuf 是依赖 Schema 的数据格式，编码后的数据为二进制，使用 Schema Registry 解码后的内部数据格式(Map，稍后讲解) 可直接被规则引擎和其他插件使用。此外 Schema Registry 支持用户自定义的 (3rd-party) 编解码服务，通过 HTTP 或 GRPC 回调的方式，进行更加贴近业务需求的编解码。")]),a._v(" "),e("h2",{attrs:{id:"架构设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#架构设计"}},[a._v("#")]),a._v(" 架构设计")]),a._v(" "),e("p",[a._v("Schema Registry 为 Avro 和 Protobuf 等内置编码格式维护 Schema 文本，但对于自定义编解码 (3rd-party) 格式，如需要 Schema，Schema 文本需由编解码服务自己维护。Schema API 提供了通过 Schema Name 的添加、查询和删除操作。")]),a._v(" "),e("p",[a._v("Schema Registry 既可以解码，也可以编码。编码和解码时需要指定 Schema Name。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(1434),alt:"architecture"}})]),a._v(" "),e("p",[a._v("编码调用示例：参数为 Schema")]),a._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("schema_encode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SchemaName"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" Data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" RawData\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("解码调用示例：")]),a._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("schema_decode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("SchemaName"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" RawData"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" Data\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("常见的使用案例是，使用规则引擎来调用 Schema Registry 提供的编码和解码接口，然后将编码或解码后的数据作为后续动作的输入。")]),a._v(" "),e("h2",{attrs:{id:"编解码-规则引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编解码-规则引擎"}},[a._v("#")]),a._v(" 编解码 + 规则引擎")]),a._v(" "),e("p",[a._v("EMQX 的消息处理层面可分为消息路由(Messaging)、规则引擎(Rule Engine)、数据格式转换(Data Conversion) 三个部分。")]),a._v(" "),e("p",[a._v("EMQX 的 PUB/SUB 系统将消息路由到指定的主题。规则引擎可以灵活地配置数据的业务规则，按规则匹配消息，然后指定相应动作。数据格式转换发生在规则匹配的过程之前，先将数据转换为可参与规则匹配的 Map 格式，然后进行匹配。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(1435),alt:"SchemaAndRuleEngine"}})]),a._v(" "),e("h3",{attrs:{id:"规则引擎内部数据格式-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#规则引擎内部数据格式-map"}},[a._v("#")]),a._v(" 规则引擎内部数据格式(Map)")]),a._v(" "),e("p",[a._v("规则引擎内部使用的数据格式为 Erlang Map，所以如果原数据内容为二进制或者其他格式，必须使用编解码函数(比如上面提到的 schema_decode 和 json_decode 函数) 将其转换为 Map。")]),a._v(" "),e("p",[a._v("Map 是一个 Key-Value 形式的数据结构，形如 #{key => value}。例如，"),e("code",[a._v('user = #{id => 1, name => "Steve"}')]),a._v(" 定义了一个 "),e("code",[a._v("id")]),a._v(" 为 "),e("code",[a._v("1")]),a._v("，"),e("code",[a._v("name")]),a._v(" 为 "),e("code",[a._v('"Steve"')]),a._v(" 的 "),e("code",[a._v("user")]),a._v(" Map。")]),a._v(" "),e("p",[a._v('SQL 语句提供了 "." 操作符嵌套地提取和添加 Map 字段。下面是使用 SQL 语句对这个 Map 操作的示例:')]),a._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("SELECT")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("user")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("id "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("AS")]),a._v(" my_id\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("SQL 语句的筛选结果为 "),e("code",[a._v("#{my_id => 1}")]),a._v("。")]),a._v(" "),e("h3",{attrs:{id:"json-编解码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#json-编解码"}},[a._v("#")]),a._v(" JSON 编解码")]),a._v(" "),e("p",[a._v("规则引擎的 SQL 语句提供了对 JSON 格式字符串的编解码支持，将 JSON 字符串和 Map 格式相互转换的 SQL 函数为 json_decode() 和 json_encode():")]),a._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("SELECT")]),a._v(" json_decode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("payload"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("AS")]),a._v(" p "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("FROM")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"t/#"')]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("WHERE")]),a._v(" p"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" p"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("y\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("上面这个 SQL 语句将会匹配到 payload 内容为 JSON 字符串： "),e("code",[a._v('{"x" = 1, "y" = 1}')]),a._v(" , 并且 topic 为 "),e("code",[a._v("t/a")]),a._v(" 的 MQTT 消息。")]),a._v(" "),e("p",[e("code",[a._v("json_decode(payload) as p")]),a._v(" 将 JSON 字符串解码为下面的 Map 数据结构，从而可以在 "),e("code",[a._v("WHERE")]),a._v(" 子句中使用 p.x 和 p.y 使用 Map 中的字段：")]),a._v(" "),e("div",{staticClass:"language-erlang line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-erlang"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("#")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token atom"}},[a._v("p")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("#")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token atom"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token atom"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("p",[e("strong",[a._v("注意:")]),a._v(" "),e("code",[a._v("AS")]),a._v(" 子句是必须的，将解码之后的数据赋值给某个Key，后面才能对其进行后续操作。")])])}),[],!1,null,null,null);s.default=r.exports}}]);