(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{1540:function(e,t,s){"use strict";s.r(t);var a=s(10),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[e._v("#")]),e._v(" Design")]),e._v(" "),a("h2",{attrs:{id:"foreword"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#foreword"}},[e._v("#")]),e._v(" Foreword")]),e._v(" "),a("p",[e._v("In terms of the design of EMQX Broker, it firstly separates the FrontEnd and Backend, and secondly separates the  Message Flow Plane and Monitor/Control Plane :")]),e._v(" "),a("p",[a("img",{attrs:{src:s(508),alt:"image"}})]),e._v(" "),a("h3",{attrs:{id:"_1-million-connections"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-million-connections"}},[e._v("#")]),e._v(" 1 million connections")]),e._v(" "),a("p",[e._v("With Multi-core servers and modern operating system kernel, it can easily support 1 million TCP connections. The core issue is how to deal with business bottlenecks at the application level.")]),e._v(" "),a("p",[e._v("EMQX Broker solves all kinds of bottleneck problems of single node carrying 1 million connections at the business and application level. For the operating system kernel, TCP protocol stack, and Erlang virtual machine parameters of connection testing, see: "),a("RouterLink",{attrs:{to:"/en/enterprise/latest/tutorial/tune.html"}},[e._v("System Tuning")])],1),e._v(" "),a("h3",{attrs:{id:"fully-asynchronous-architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fully-asynchronous-architecture"}},[e._v("#")]),e._v(" Fully asynchronous architecture")]),e._v(" "),a("p",[e._v("EMQX Broker is a fully asynchronous architecture based on the Erlang/OTP platform: asynchronous TCP connection processing, asynchronous Topic subscription, and asynchronous message publishing. Only for the resource load limitation part, it adopts synchronous design, such as TCP connection creation and Mnesia database transaction execution.")]),e._v(" "),a("p",[e._v("In the EMQX 3.0 version, from the Publisher to the Subscriber, a MQTT message flows   with a series of Erlang processes Mailbox flows asynchronously inside the EMQXBroker:")]),e._v(" "),a("p",[a("img",{attrs:{src:s(509),alt:"image"}})]),e._v(" "),a("h3",{attrs:{id:"message-persistence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#message-persistence"}},[e._v("#")]),e._v(" Message persistence")]),e._v(" "),a("p",[e._v("EMQX open source products do not support message persistence within the server, which is an architectural design choice. Firstly, the core problem solved by EMQX is connection and routing; secondly, we think that built-in persistence is a wrong design.")]),e._v(" "),a("p",[e._v("Traditional MQ servers with built-in message persistence, such as the widely used JMS server ActiveMQ, have redesigned the persistence part in almost every major version. There are two design issues with built-in message persistence:")]),e._v(" "),a("ol",[a("li",[e._v("How to balance the use of memory and disk? Message routing is based on memory, while message storage is based on disk.")]),e._v(" "),a("li",[e._v("In a multi-server distributed cluster architecture, how to place Queue and how to copy Queue messages?")])]),e._v(" "),a("p",[e._v("Kafka made a correct design on the above problem, which is a message server based entirely on disk-distributed Commit Log.")]),e._v(" "),a("p",[e._v("After EMQX separates message routing and message storage responsibilities in the design, the function of data replication, disaster recovery and even application integration can be implemented flexibly at the data level.")]),e._v(" "),a("p",[e._v("In EMQX Enterprise products, through rule engines or plugins, messages can be persisted to both databases such as Redis, MongoDB, Cassandra, MySQL, PostgreSQL, and message queues such as RabbitMQ, Kafka.")]),e._v(" "),a("h2",{attrs:{id:"system-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#system-structure"}},[e._v("#")]),e._v(" System structure")]),e._v(" "),a("h3",{attrs:{id:"conceptual-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conceptual-model"}},[e._v("#")]),e._v(" Conceptual model")]),e._v(" "),a("p",[e._v("EMQX Broker is more like a network Router or a Switch in concept, rather than the traditional enterprise-level message queue (MQ). Compared to network routers that route packets by IP address or MPLS label, EMQX Broker routes MQTT messages between cluster nodes by publish-subscribe model of Topic Trie:")]),e._v(" "),a("p",[a("img",{attrs:{src:s(510),alt:"image"}})]),e._v(" "),a("h3",{attrs:{id:"design-philosophy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design-philosophy"}},[e._v("#")]),e._v(" Design Philosophy")]),e._v(" "),a("ol",[a("li",[e._v("The core problem solved by the EMQX Broker is to process massive concurrent MQTT connection and routing messages.")]),e._v(" "),a("li",[e._v("Embrace Erlang/OTP, the Soft-Realtime, Low-Latency, Concurrent and Fault-Tolerant Platform.")]),e._v(" "),a("li",[e._v("Layered Design: Connection, Session, PubSub and Router Layers.")]),e._v(" "),a("li",[e._v("Separate the Message Flow Plane and the Control/Management Plane.")]),e._v(" "),a("li",[e._v("Support backend database or NoSQL for data persistence, disaster recovery and application integration.")])]),e._v(" "),a("h3",{attrs:{id:"system-layers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#system-layers"}},[e._v("#")]),e._v(" System Layers")]),e._v(" "),a("ol",[a("li",[e._v("Connection Layer: Handle TCP and WebSocket connections, encode/decode MQTT packets.")]),e._v(" "),a("li",[e._v("Session Layer: Process MQTT PUBLISH/SUBSCRIBE Packets received from client, and deliver MQTT messages to client.")]),e._v(" "),a("li",[e._v("Routing(Distributed) Layer: Route MQTT messages among clustered nodes.")]),e._v(" "),a("li",[e._v("Distributed Layer: Distributed MQTT messages routed between distributed nodes.")]),e._v(" "),a("li",[e._v("Authentication and access control (ACL): The connection layer supports extensible authentication and access control modules.")]),e._v(" "),a("li",[e._v("Hooks and Plugins: Each layer of the system provides extensible hooks and supports server expansion with plugin.")])]),e._v(" "),a("h2",{attrs:{id:"connection-layer-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#connection-layer-design"}},[e._v("#")]),e._v(" Connection Layer design")]),e._v(" "),a("p",[e._v("The connection layer handles the server-side Socket connection and MQTT protocol codec:")]),e._v(" "),a("ol",[a("li",[e._v("Asynchronous TCP server based on  "),a("a",{attrs:{href:"https://github.com/emqx/esockd",target:"_blank",rel:"noopener noreferrer"}},[e._v("eSockd"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("TCP Acceptor pool and asynchronous TCP Accept")]),e._v(" "),a("li",[e._v("TCP / SSL, WebSocket / SSL connection support")]),e._v(" "),a("li",[e._v("Maximum number of concurrent connections")]),e._v(" "),a("li",[e._v("Access control based on IP address (CIDR)")]),e._v(" "),a("li",[e._v("Flow control based on Leaky Bucket")]),e._v(" "),a("li",[e._v("MQTT protocol codec")]),e._v(" "),a("li",[e._v("MQTT protocol heartbeat detection")]),e._v(" "),a("li",[e._v("MQTT protocol packet processing")])]),e._v(" "),a("h2",{attrs:{id:"session-layer-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#session-layer-design"}},[e._v("#")]),e._v(" Session Layer design")]),e._v(" "),a("p",[e._v("The session layer handles the MQTT protocol Publish/Subscribe business interaction process:")]),e._v(" "),a("ol",[a("li",[e._v("Cache all subscriptions of the MQTT client, and terminate the subscription QoS")]),e._v(" "),a("li",[e._v("Handle QoS 0/1/2 message reception and delivery, message timeout retransmission and offline message saving")]),e._v(" "),a("li",[e._v("Inflight Window, delivering message throughput control and order guarantee")]),e._v(" "),a("li",[e._v("Save the unacknowledged QoS 1/2 message sent by the server to the client")]),e._v(" "),a("li",[e._v("Cache  QoS 2 message that client sends to the server, but does not receive PUBREL")]),e._v(" "),a("li",[e._v("When the client is offline, save the offline QoS 1/2 message of the persistent session")])]),e._v(" "),a("h3",{attrs:{id:"packet-id-and-message-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#packet-id-and-message-id"}},[e._v("#")]),e._v(" Packet ID and message ID")]),e._v(" "),a("p",[e._v("The MQTT protocol defines a 16-bit PacketId, which is used to send, receive and confirm messages from the client to the server. After MQTT PUBLISH packet arrives at the broker, it is converted into a message object and assigned a 128-bit MessageId.")]),e._v(" "),a("p",[e._v("Global unique time series message ID structure:")]),e._v(" "),a("p",[a("img",{attrs:{src:s(511),alt:"image"}})]),e._v(" "),a("ol",[a("li",[e._v("64bits timestamp: erlang: system_time if Erlang > = R18, otherwise os: timestamp")]),e._v(" "),a("li",[e._v("Erlang node ID: encoded as 2 bytes")]),e._v(" "),a("li",[e._v("Erlang process PID: encoded as 4 bytes")]),e._v(" "),a("li",[e._v("Process internal serial number: 2-byte process internal serial number")])]),e._v(" "),a("p",[e._v("During the end-to-end message Pub/Sub process, the published message ID and packet QoS are terminated at the session layer, and the MQTT message object identified by the unique ID is routed between the nodes:")]),e._v(" "),a("p",[a("img",{attrs:{src:s(512),alt:"image"}})]),e._v(" "),a("h2",{attrs:{id:"routing-layer-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#routing-layer-design"}},[e._v("#")]),e._v(" Routing layer  design")]),e._v(" "),a("p",[e._v("The routing layer maintains the Subscriber and Subscription, and Dispatch message at this node with Pub/Sub model :")]),e._v(" "),a("p",[a("img",{attrs:{src:s(513),alt:"image"}})]),e._v(" "),a("p",[e._v("After the message is dispatched to the session, the session is responsible for delivering the message according to different QoS.")]),e._v(" "),a("h2",{attrs:{id:"distribution-layer-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#distribution-layer-design"}},[e._v("#")]),e._v(" Distribution layer design")]),e._v(" "),a("p",[e._v("The distribution layer maintains a Topic Trie and a Route Table. The Topic Trie is composed of wildcard topics, and the Route Table maps topics to nodes:")]),e._v(" "),a("p",[a("img",{attrs:{src:s(514),alt:"image"}})]),e._v(" "),a("p",[e._v("The distribution layer forwards routed MQTT messages between nodes in the cluster by matching the Topic Trie and querying Route Table:")]),e._v(" "),a("p",[a("img",{attrs:{src:s(399),alt:"image"}})]),e._v(" "),a("h2",{attrs:{id:"mnesia-ets-table-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mnesia-ets-table-design"}},[e._v("#")]),e._v(" Mnesia/ETS  table design")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[e._v("Table")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Type")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_conn")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("ets")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Connection Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_metrics")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("ets")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Metrics Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_session")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("ets")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Session Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_hooks")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("ets")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Hooks Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_subscriber")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("ets")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Subscriber Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_subscription")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("ets")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Subscription Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_admin")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("The Dashboard admin users Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_retainer")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Retained Message Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_shared_subscription")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Shared Subscription Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_session_registry")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Global Session Registry Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_alarm_history")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Alarms History")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_alarm")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Alarms")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_banned")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Built-In Banned Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_route")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Global Route Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_trie")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Trie Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("emqx_trie_node")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Trie Node Table")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("mqtt_app")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("mnesia")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("App table")])])])]),e._v(" "),a("h2",{attrs:{id:"erlang-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#erlang-design"}},[e._v("#")]),e._v(" Erlang design")]),e._v(" "),a("ol",[a("li",[e._v("Use Pool, Pool, Pool ... Recommende GProc library: "),a("a",{attrs:{href:"https://github.com/uwiger/gproc",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/uwiger/gproc"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Asynchronous, asynchronous, asynchronous message ... asynchronous message between connection layer and the routing layer, and the synchronous request is used for load protection")]),e._v(" "),a("li",[e._v("Avoid process Mailbox accumulating messages")]),e._v(" "),a("li",[e._v("The Socket connection and session process through which the message flows must be Hibernate, and actively recover the binary handle")]),e._v(" "),a("li",[e._v("Use Binary data more to avoid memory copying between processes")]),e._v(" "),a("li",[e._v("Use ETS, ETS, ETS ... Message Passing vs. ETS")]),e._v(" "),a("li",[e._v("Avoid ETS table non-key value field select, match")]),e._v(" "),a("li",[e._v("Avoid large amounts of data ETS read and write, for each time of ETS read and write, it will copy memory, and you can use lookup_element, update_counter")]),e._v(" "),a("li",[e._v("Properly open the ETS table {write_concurrency, true}")]),e._v(" "),a("li",[e._v("Protect Mnesia database transactions, minimize the number of transactions, and avoid transaction overload")]),e._v(" "),a("li",[e._v("Avoid match, select for non-index or non-key value field of Mnesia data table")])])])}),[],!1,null,null,null);t.default=i.exports},399:function(e,t,s){e.exports=s.p+"docs-assets/img/design_9.46b9a10f.png"},508:function(e,t,s){e.exports=s.p+"docs-assets/img/design_1.c66e66fe.png"},509:function(e,t,s){e.exports=s.p+"docs-assets/img/design_2.8f467a5f.png"},510:function(e,t,s){e.exports=s.p+"docs-assets/img/design_3.689a3c1e.png"},511:function(e,t,s){e.exports=s.p+"docs-assets/img/design_5.f94868b5.png"},512:function(e,t,s){e.exports=s.p+"docs-assets/img/design_6.563a1aeb.png"},513:function(e,t,s){e.exports=s.p+"docs-assets/img/design_7.2c4ff7ac.png"},514:function(e,t,s){e.exports=s.p+"docs-assets/img/design_8.9d1772d8.png"}}]);